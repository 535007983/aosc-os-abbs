reverted:
--- b/contrib/precompile_explicit.jl
+++ a/contrib/precompile_explicit.jl
@@ -595,8 +595,7 @@
 precompile(Tuple{typeof(Distributed.flush_gc_msgs), Distributed.Worker})
 precompile(Tuple{typeof(Distributed.flush_gc_msgs)})
 precompile(Tuple{typeof(Distributed.terminate_all_workers)})
+precompile(Tuple{typeof(LibGit2.__init__)})
-precompile(Tuple{typeof(LibGit2.ensure_initialized)})
-precompile(Tuple{typeof(LibGit2.initialize)})
 precompile(Tuple{typeof(Logging.__init__)})
 precompile(Tuple{typeof(Logging.default_metafmt), Base.CoreLogging.LogLevel, Module, Symbol, Symbol, String, Int64})
 precompile(Tuple{typeof(Logging.default_metafmt), Base.CoreLogging.LogLevel, Nothing, Symbol, Symbol, String, Int64})
reverted:
--- b/stdlib/LibGit2/src/LibGit2.jl
+++ a/stdlib/LibGit2/src/LibGit2.jl
@@ -16,9 +16,7 @@
 const GITHUB_REGEX =
     r"^(?:git@|git://|https://(?:[\w\.\+\-]+@)?)github.com[:/](([^/].+)/(.+?))(?:\.git)?$"i
 
+const REFCOUNT = Threads.Atomic{UInt}()
-const REFCOUNT = Threads.Atomic{Int}(0)
-
-function ensure_initialized end
 
 include("utils.jl")
 include("consts.jl")
@@ -965,29 +963,22 @@
     end
 end
 
+function set_ssl_cert_locations(cert_loc)
+    cert_file = isfile(cert_loc) ? cert_loc : Cstring(C_NULL)
+    cert_dir  = isdir(cert_loc) ? cert_loc : Cstring(C_NULL)
+    cert_file == C_NULL && cert_dir == C_NULL && return
+    @check ccall((:git_libgit2_opts, :libgit2), Cint,
+          (Cint, Cstring, Cstring),
+          Cint(Consts.SET_SSL_CERT_LOCATIONS), cert_file, cert_dir)
-## lazy libgit2 initialization
-
-function ensure_initialized()
-    x = Threads.atomic_cas!(REFCOUNT, 0, 1)
-    if x < 0
-        negative_refcount_error(x)::Union{}
-    end
-    if x == 0
-        initialize()
-    end
-    return nothing
-end
-
-@noinline function negative_refcount_error(x::Int)
-    error("Negative LibGit2 REFCOUNT $x\nThis shouldn't happen, please file a bug report!")
 end
 
+function __init__()
-@noinline function initialize()
     @check ccall((:git_libgit2_init, :libgit2), Cint, ())
+    REFCOUNT[] = 1
 
     atexit() do
+        if Threads.atomic_sub!(REFCOUNT, UInt(1)) == 1
+            # refcount zero, no objects to be finalized
-        # refcount zero, no objects to be finalized
-        if Threads.atomic_sub!(REFCOUNT, 1) >= 1
             ccall((:git_libgit2_shutdown, :libgit2), Cint, ())
         end
     end
@@ -1007,13 +998,5 @@
     end
 end
 
-function set_ssl_cert_locations(cert_loc)
-    cert_file = isfile(cert_loc) ? cert_loc : Cstring(C_NULL)
-    cert_dir  = isdir(cert_loc) ? cert_loc : Cstring(C_NULL)
-    cert_file == C_NULL && cert_dir == C_NULL && return
-    @check ccall((:git_libgit2_opts, :libgit2), Cint,
-          (Cint, Cstring, Cstring),
-          Cint(Consts.SET_SSL_CERT_LOCATIONS), cert_file, cert_dir)
-end
 
 end # module
reverted:
--- b/stdlib/LibGit2/src/blame.jl
+++ a/stdlib/LibGit2/src/blame.jl
@@ -9,7 +9,6 @@
 which commits to probe - see [`BlameOptions`](@ref) for more information.
 """
 function GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())
-    ensure_initialized()
     blame_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_blame_file, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Ptr{BlameOptions}),
@@ -26,7 +25,6 @@
 that function later.
 """
 function counthunks(blame::GitBlame)
-    ensure_initialized()
     return ccall((:git_blame_get_hunk_count, :libgit2), Int32, (Ptr{Cvoid},), blame.ptr)
 end
 
@@ -34,7 +32,6 @@
     if !(1 <= i <= counthunks(blame))
         throw(BoundsError(blame, (i,)))
     end
-    ensure_initialized()
     GC.@preserve blame begin
         hunk_ptr = ccall((:git_blame_get_hunk_byindex, :libgit2),
                           Ptr{BlameHunk},
reverted:
--- b/stdlib/LibGit2/src/blob.jl
+++ a/stdlib/LibGit2/src/blob.jl
@@ -1,7 +1,6 @@
 # This file is a part of Julia. License is MIT: https://julialang.org/license
 
 function Base.length(blob::GitBlob)
-    ensure_initialized()
     return ccall((:git_blob_rawsize, :libgit2), Int64, (Ptr{Cvoid},), blob.ptr)
 end
 
@@ -19,7 +18,6 @@
 is binary and not valid Unicode.
 """
 function rawcontent(blob::GitBlob)
-    ensure_initialized()
     ptr = ccall((:git_blob_rawcontent, :libgit2), Ptr{UInt8}, (Ptr{Cvoid},), blob.ptr)
     copy(unsafe_wrap(Array, ptr, (length(blob),), own = false))
 end
@@ -46,7 +44,6 @@
 the first 8000 bytes.
 """
 function isbinary(blob::GitBlob)
-    ensure_initialized()
     bin_flag = ccall((:git_blob_is_binary, :libgit2), Cint, (Ptr{Cvoid},), blob.ptr)
     return bin_flag == 1
 end
@@ -65,7 +62,6 @@
 ```
 """
 function addblob!(repo::GitRepo, path::AbstractString)
-    ensure_initialized()
     id_ref = Ref{GitHash}()
     @check ccall((:git_blob_create_fromdisk, :libgit2), Cint,
                  (Ptr{GitHash}, Ptr{Cvoid}, Cstring),
reverted:
--- b/stdlib/LibGit2/src/callbacks.jl
+++ a/stdlib/LibGit2/src/callbacks.jl
@@ -6,7 +6,6 @@
 """
 function mirror_callback(remote::Ptr{Ptr{Cvoid}}, repo_ptr::Ptr{Cvoid},
                          name::Cstring, url::Cstring, payload::Ptr{Cvoid})
-    ensure_initialized()
     # Create the remote with a mirroring url
     fetch_spec = "+refs/*:refs/*"
     err = ccall((:git_remote_create_with_fetchspec, :libgit2), Cint,
@@ -41,7 +40,6 @@
 end
 
 function user_abort()
-    ensure_initialized()
     # Note: Potentially it could be better to just throw a Julia error.
     ccall((:giterr_set_str, :libgit2), Cvoid,
           (Cint, Cstring), Cint(Error.Callback),
@@ -50,7 +48,6 @@
 end
 
 function prompt_limit()
-    ensure_initialized()
     ccall((:giterr_set_str, :libgit2), Cvoid,
           (Cint, Cstring), Cint(Error.Callback),
           "Aborting, maximum number of prompts reached.")
@@ -58,7 +55,6 @@
 end
 
 function exhausted_abort()
-    ensure_initialized()
     ccall((:giterr_set_str, :libgit2), Cvoid,
           (Cint, Cstring), Cint(Error.Callback),
           "All authentication methods have failed.")
@@ -66,7 +62,6 @@
 end
 
 function authenticate_ssh(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload, username_ptr)
-    ensure_initialized()
     cred = p.credential::SSHCredential
     revised = false
 
@@ -178,7 +173,6 @@
 end
 
 function authenticate_userpass(libgit2credptr::Ptr{Ptr{Cvoid}}, p::CredentialPayload)
-    ensure_initialized()
     cred = p.credential::UserPasswordCredential
     revised = false
 
@@ -332,7 +326,6 @@
     # with the requested authentication method.
     if err == 0
         if p.explicit !== nothing
-            ensure_initialized()
             ccall((:giterr_set_str, :libgit2), Cvoid, (Cint, Cstring), Cint(Error.Callback),
                   "The explicitly provided credential is incompatible with the requested " *
                   "authentication methods.")
reverted:
--- b/stdlib/LibGit2/src/commit.jl
+++ a/stdlib/LibGit2/src/commit.jl
@@ -9,7 +9,6 @@
 of any such newlines.
 """
 function message(c::GitCommit, raw::Bool=false)
-    ensure_initialized()
     GC.@preserve c begin
         local msg_ptr::Cstring
         msg_ptr = raw ? ccall((:git_commit_message_raw, :libgit2), Cstring, (Ptr{Cvoid},), c.ptr) :
@@ -29,7 +28,6 @@
 the person who made changes to the relevant file(s). See also [`committer`](@ref).
 """
 function author(c::GitCommit)
-    ensure_initialized()
     GC.@preserve c begin
         ptr = ccall((:git_commit_author, :libgit2), Ptr{SignatureStruct}, (Ptr{Cvoid},), c.ptr)
         @assert ptr != C_NULL
@@ -47,7 +45,6 @@
 a `committer` who committed it.
 """
 function committer(c::GitCommit)
-    ensure_initialized()
     GC.@preserve c begin
         ptr = ccall((:git_commit_committer, :libgit2), Ptr{SignatureStruct}, (Ptr{Cvoid},), c.ptr)
         sig = Signature(ptr)
@@ -68,7 +65,6 @@
                 committer::GitSignature,
                 tree::GitTree,
                 parents::GitCommit...)
-    ensure_initialized()
     commit_id_ptr = Ref(GitHash())
     nparents = length(parents)
     parentptrs = Ptr{Cvoid}[c.ptr for c in parents]
reverted:
--- b/stdlib/LibGit2/src/config.jl
+++ a/stdlib/LibGit2/src/config.jl
@@ -10,7 +10,6 @@
                    level::Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_APP,
                    repo::Union{GitRepo, Nothing}=nothing,
                    force::Bool=false)
-    ensure_initialized()
     # create new config object
     cfg_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_new, :libgit2), Cint, (Ptr{Ptr{Cvoid}},), cfg_ptr_ptr)
@@ -32,7 +31,6 @@
 used.
 """
 function GitConfig(repo::GitRepo)
-    ensure_initialized()
     cfg_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_config, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}), cfg_ptr_ptr, repo.ptr)
@@ -47,7 +45,6 @@
 options outside a specific git repository.
 """
 function GitConfig(level::Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_DEFAULT)
-    ensure_initialized()
     cfg_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_open_default, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}},), cfg_ptr_ptr)
@@ -88,7 +85,6 @@
                  level::Consts.GIT_CONFIG = Consts.CONFIG_LEVEL_APP,
                  repo::Union{GitRepo, Nothing} = nothing,
                  force::Bool=false)
-    ensure_initialized()
     @static if LibGit2.VERSION >= v"0.27.0"
         @check ccall((:git_config_add_file_ondisk, :libgit2), Cint,
                      (Ptr{Ptr{Cvoid}}, Cstring, Cint, Ptr{Cvoid}, Cint),
@@ -102,7 +98,6 @@
 end
 
 function get(::Type{<:AbstractString}, c::GitConfig, name::AbstractString)
-    ensure_initialized()
     buf_ref = Ref(Buffer())
     @check ccall((:git_config_get_string_buf, :libgit2), Cint,
                  (Ptr{Buffer}, Ptr{Cvoid}, Cstring), buf_ref, c.ptr, name)
@@ -113,7 +108,6 @@
 end
 
 function get(::Type{Bool}, c::GitConfig, name::AbstractString)
-    ensure_initialized()
     val_ptr = Ref(Cint(0))
     @check ccall((:git_config_get_bool, :libgit2), Cint,
           (Ptr{Cint}, Ptr{Cvoid}, Cstring), val_ptr, c.ptr, name)
@@ -121,7 +115,6 @@
 end
 
 function get(::Type{Int32}, c::GitConfig, name::AbstractString)
-    ensure_initialized()
     val_ptr = Ref(Cint(0))
     @check ccall((:git_config_get_int32, :libgit2), Cint,
           (Ptr{Cint}, Ptr{Cvoid}, Cstring), val_ptr, c.ptr, name)
@@ -129,7 +122,6 @@
 end
 
 function get(::Type{Int64}, c::GitConfig, name::AbstractString)
-    ensure_initialized()
     val_ptr = Ref(Cintmax_t(0))
     @check ccall((:git_config_get_int64, :libgit2), Cint,
           (Ptr{Cintmax_t}, Ptr{Cvoid}, Cstring), val_ptr, c.ptr, name)
@@ -163,32 +155,27 @@
 end
 
 function set!(c::GitConfig, name::AbstractString, value::AbstractString)
-    ensure_initialized()
     @check ccall((:git_config_set_string, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring, Cstring), c.ptr, name, value)
 end
 
 function set!(c::GitConfig, name::AbstractString, value::Bool)
-    ensure_initialized()
     bval = Int32(value)
     @check ccall((:git_config_set_bool, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring, Cint), c.ptr, name, bval)
 end
 
 function set!(c::GitConfig, name::AbstractString, value::Int32)
-    ensure_initialized()
     @check ccall((:git_config_set_int32, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring, Cint), c.ptr, name, value)
 end
 
 function set!(c::GitConfig, name::AbstractString, value::Int64)
-    ensure_initialized()
     @check ccall((:git_config_set_int64, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring, Cintmax_t), c.ptr, name, value)
 end
 
 function GitConfigIter(cfg::GitConfig)
-    ensure_initialized()
     ci_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_iterator_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}), ci_ptr, cfg.ptr)
@@ -196,7 +183,6 @@
 end
 
 function GitConfigIter(cfg::GitConfig, name::AbstractString)
-    ensure_initialized()
     ci_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_multivar_iterator_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Cstring),
@@ -205,7 +191,6 @@
 end
 
 function GitConfigIter(cfg::GitConfig, name::AbstractString, value::Regex)
-    ensure_initialized()
     ci_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_multivar_iterator_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Cstring),
@@ -214,7 +199,6 @@
 end
 
 function GitConfigIter(cfg::GitConfig, name::Regex)
-    ensure_initialized()
     ci_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_config_iterator_glob_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring),
@@ -223,7 +207,6 @@
 end
 
 function Base.iterate(ci::GitConfigIter, state=nothing)
-    ensure_initialized()
     entry_ptr_ptr = Ref{Ptr{ConfigEntry}}(C_NULL)
     err = ccall((:git_config_next, :libgit2), Cint,
                  (Ptr{Ptr{ConfigEntry}}, Ptr{Cvoid}), entry_ptr_ptr, ci.ptr)
reverted:
--- b/stdlib/LibGit2/src/consts.jl
+++ a/stdlib/LibGit2/src/consts.jl
@@ -2,7 +2,7 @@
 
 module Consts
 
+import ..LibGit2: version
-import ..LibGit2: version, ensure_initialized
 
 const HEAD_FILE  = "HEAD"
 const FETCH_HEAD  = "FETCH_HEAD"
reverted:
--- b/stdlib/LibGit2/src/diff.jl
+++ a/stdlib/LibGit2/src/diff.jl
@@ -24,7 +24,6 @@
 for example, be used to examine the changes in staged files before a commit.
 """
 function diff_tree(repo::GitRepo, tree::GitTree, pathspecs::AbstractString=""; cached::Bool=false)
-    ensure_initialized()
     diff_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     if cached
         @check ccall((:git_diff_tree_to_index, :libgit2), Cint,
@@ -49,7 +48,6 @@
 to compare a commit on another branch with the current latest commit on `master`.
 """
 function diff_tree(repo::GitRepo, oldtree::GitTree, newtree::GitTree)
-    ensure_initialized()
     diff_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_diff_tree_to_tree, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{DiffOptionsStruct}),
@@ -65,7 +63,6 @@
 files were changed, how many insertions were made, and how many deletions were made.
 """
 function GitDiffStats(diff::GitDiff)
-    ensure_initialized()
     diff_stat_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_diff_get_stats, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}),
@@ -82,7 +79,6 @@
 are to be included or not).
 """
 function files_changed(diff_stat::GitDiffStats)
-    ensure_initialized()
     return ccall((:git_diff_stats_files_changed, :libgit2), Csize_t, (Ptr{Cvoid},), diff_stat.ptr)
 end
 
@@ -95,7 +91,6 @@
 are to be included or not).
 """
 function insertions(diff_stat::GitDiffStats)
-    ensure_initialized()
     return ccall((:git_diff_stats_insertions, :libgit2), Csize_t, (Ptr{Cvoid},), diff_stat.ptr)
 end
 
@@ -108,12 +103,10 @@
 are to be included or not).
 """
 function deletions(diff_stat::GitDiffStats)
-    ensure_initialized()
     return ccall((:git_diff_stats_deletions, :libgit2), Csize_t, (Ptr{Cvoid},), diff_stat.ptr)
 end
 
 function count(diff::GitDiff)
-    ensure_initialized()
     return ccall((:git_diff_num_deltas, :libgit2), Cint, (Ptr{Cvoid},), diff.ptr)
 end
 
@@ -121,7 +114,6 @@
     if i < 1 || i > count(diff)
         throw(BoundsError(diff, (i,)))
     end
-    ensure_initialized()
     delta_ptr = ccall((:git_diff_get_delta, :libgit2),
                       Ptr{DiffDelta},
                       (Ptr{Cvoid}, Csize_t), diff.ptr, i-1)
reverted:
--- b/stdlib/LibGit2/src/error.jl
+++ a/stdlib/LibGit2/src/error.jl
@@ -2,8 +2,6 @@
 
 module Error
 
-import ..LibGit2: ensure_initialized
-
 export GitError
 
 @enum(Code, GIT_OK          = Cint(0),   # no error
@@ -73,7 +71,6 @@
 Base.show(io::IO, err::GitError) = print(io, "GitError(Code:$(err.code), Class:$(err.class), $(err.msg))")
 
 function last_error()
-    ensure_initialized()
     err = ccall((:giterr_last, :libgit2), Ptr{ErrorStruct}, ())
     if err != C_NULL
         err_obj   = unsafe_load(err)
reverted:
--- b/stdlib/LibGit2/src/index.jl
+++ a/stdlib/LibGit2/src/index.jl
@@ -6,7 +6,6 @@
 Load the index file for the repository `repo`.
 """
 function GitIndex(repo::GitRepo)
-    ensure_initialized()
     idx_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_index, :libgit2), Cint,
                  (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}), idx_ptr_ptr, repo.ptr)
@@ -24,7 +23,6 @@
 has changed since the last time it was loaded into `idx`.
 """
 function read!(idx::GitIndex, force::Bool = false)
-    ensure_initialized()
     @check ccall((:git_index_read, :libgit2), Cint, (Ptr{Cvoid}, Cint), idx.ptr, Cint(force))
     return idx
 end
@@ -35,7 +33,6 @@
 Write the state of index `idx` to disk using a file lock.
 """
 function write!(idx::GitIndex)
-    ensure_initialized()
     @check ccall((:git_index_write, :libgit2), Cint, (Ptr{Cvoid},), idx.ptr)
     return idx
 end
@@ -49,7 +46,6 @@
 repository cannot be bare. `idx` must not contain any files with conflicts.
 """
 function write_tree!(idx::GitIndex)
-    ensure_initialized()
     oid_ptr = Ref(GitHash())
     @check ccall((:git_index_write_tree, :libgit2), Cint,
                  (Ptr{GitHash}, Ptr{Cvoid}), oid_ptr, idx.ptr)
@@ -72,7 +68,6 @@
 `idx`) into the index `idx`. The current index contents will be replaced.
 """
 function read_tree!(idx::GitIndex, tree::GitTree)
-    ensure_initialized()
     @check ccall((:git_index_read_tree, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}), idx.ptr, tree.ptr)
 end
@@ -103,7 +98,6 @@
 """
 function add!(idx::GitIndex, files::AbstractString...;
               flags::Cuint = Consts.INDEX_ADD_DEFAULT)
-    ensure_initialized()
     @check ccall((:git_index_add_all, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{StrArrayStruct}, Cuint, Ptr{Cvoid}, Ptr{Cvoid}),
                  idx.ptr, collect(files), flags, C_NULL, C_NULL)
@@ -119,7 +113,6 @@
 database.
 """
 function update!(idx::GitIndex, files::AbstractString...)
-    ensure_initialized()
     @check ccall((:git_index_update_all, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{StrArrayStruct}, Ptr{Cvoid}, Ptr{Cvoid}),
                  idx.ptr, collect(files), C_NULL, C_NULL)
@@ -133,7 +126,6 @@
 of the `repo`).
 """
 function remove!(idx::GitIndex, files::AbstractString...)
-    ensure_initialized()
     @check ccall((:git_index_remove_all, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{StrArrayStruct}, Ptr{Cvoid}, Ptr{Cvoid}),
                  idx.ptr, collect(files), C_NULL, C_NULL)
@@ -172,12 +164,10 @@
 end
 
 function count(idx::GitIndex)
-    ensure_initialized()
     return ccall((:git_index_entrycount, :libgit2), Csize_t, (Ptr{Cvoid},), idx.ptr)
 end
 
 function Base.getindex(idx::GitIndex, i::Integer)
-    ensure_initialized()
     GC.@preserve idx begin
         ie_ptr = ccall((:git_index_get_byindex, :libgit2),
                        Ptr{IndexEntry},
@@ -189,7 +179,6 @@
 end
 
 function Base.findall(path::String, idx::GitIndex)
-    ensure_initialized()
     pos_ref = Ref{Csize_t}(0)
     ret = ccall((:git_index_find, :libgit2), Cint,
                   (Ref{Csize_t}, Ptr{Cvoid}, Cstring), pos_ref, idx.ptr, path)
@@ -208,10 +197,7 @@
 stages `2` and larger are for changes from other branches (for instance, in the case
 of a multi-branch "octopus" merge, stages `2`, `3`, and `4` might be used).
 """
+stage(ie::IndexEntry) = ccall((:git_index_entry_stage, :libgit2), Cint, (Ptr{IndexEntry},), Ref(ie))
-function stage(ie::IndexEntry)
-    ensure_initialized()
-    return ccall((:git_index_entry_stage, :libgit2), Cint, (Ptr{IndexEntry},), Ref(ie))
-end
 
 function Base.show(io::IO, idx::GitIndex)
     println(io, "GitIndex:\nRepository: ", repository(idx), "\nNumber of elements: ", count(idx))
reverted:
--- b/stdlib/LibGit2/src/merge.jl
+++ a/stdlib/LibGit2/src/merge.jl
@@ -14,7 +14,6 @@
 branch head described using `GitReference`.
 """
 function GitAnnotated(repo::GitRepo, commit_id::GitHash)
-    ensure_initialized()
     ann_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_annotated_commit_lookup, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{GitHash}),
@@ -23,7 +22,6 @@
 end
 
 function GitAnnotated(repo::GitRepo, ref::GitReference)
-    ensure_initialized()
     ann_ref_ref = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_annotated_commit_from_ref, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{Cvoid}),
@@ -32,7 +30,6 @@
 end
 
 function GitAnnotated(repo::GitRepo, fh::FetchHead)
-    ensure_initialized()
     ann_ref_ref = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_annotated_commit_from_fetchhead, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Cstring, Ptr{GitHash}),
@@ -47,7 +44,6 @@
 end
 
 function GitHash(ann::GitAnnotated)
-    ensure_initialized()
     GC.@preserve ann begin
         oid = unsafe_load(ccall((:git_annotated_commit_id, :libgit2), Ptr{GitHash}, (Ptr{Cvoid},), ann.ptr))
     end
@@ -83,7 +79,6 @@
 `preference` can be controlled through the repository or global git configuration.
 """
 function merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated})
-    ensure_initialized()
     analysis = Ref{Cint}(0)
     preference = Ref{Cint}(0)
     anns_ref = Ref(Base.map(a->a.ptr, anns), 1)
@@ -145,7 +140,6 @@
 function merge!(repo::GitRepo, anns::Vector{GitAnnotated};
                 merge_opts::MergeOptions = MergeOptions(),
                 checkout_opts::CheckoutOptions = CheckoutOptions())
-    ensure_initialized()
     anns_size = Csize_t(length(anns))
     @check ccall((:git_merge, :libgit2), Cint,
                   (Ptr{Cvoid}, Ptr{Ptr{Cvoid}}, Csize_t,
@@ -256,7 +250,6 @@
 `one` and `two` may both be in string form. Return the `GitHash` of the merge base.
 """
 function merge_base(repo::GitRepo, one::AbstractString, two::AbstractString)
-    ensure_initialized()
     oid1_ptr = Ref(GitHash(one))
     oid2_ptr = Ref(GitHash(two))
     moid_ptr = Ref(GitHash())
reverted:
--- b/stdlib/LibGit2/src/oid.jl
+++ a/stdlib/LibGit2/src/oid.jl
@@ -11,7 +11,6 @@
     if ptr == C_NULL
         throw(ArgumentError("NULL pointer passed to GitHash() constructor"))
     end
-    ensure_initialized()
     oid_ptr = Ref(GitHash())
     ccall((:git_oid_fromraw, :libgit2), Cvoid, (Ptr{GitHash}, Ptr{UInt8}), oid_ptr, ptr)
     return oid_ptr[]
@@ -40,7 +39,6 @@
     if len < OID_HEXSZ
         throw(ArgumentError("Input string is too short, use `GitShortHash` for partial hashes"))
     end
-    ensure_initialized()
     oid_ptr = Ref{GitHash}()
     @check ccall((:git_oid_fromstrn, :libgit2), Cint,
               (Ptr{GitHash}, Ptr{UInt8}, Csize_t), oid_ptr, bstr, len)
@@ -53,7 +51,6 @@
 Construct a `GitShortHash` from the data stored in the given [`Buffer`](@ref).
 """
 function GitShortHash(buf::Buffer)
-    ensure_initialized()
     oid_ptr = Ref{GitHash}()
     @check ccall((:git_oid_fromstrn, :libgit2), Cint,
               (Ptr{GitHash}, Ptr{UInt8}, Csize_t), oid_ptr, buf.ptr, buf.size)
@@ -66,7 +63,6 @@
 Construct a `GitShortHash` from a string of at most $OID_HEXSZ hexadecimal digits.
 """
 function GitShortHash(id::AbstractString)
-    ensure_initialized()
     bstr = String(id)
     len = sizeof(bstr)
     oid_ptr = Ref{GitHash}()
@@ -110,7 +106,6 @@
 function GitHash(ref::GitReference)
     isempty(ref) && return GitHash()
     reftype(ref) != Consts.REF_OID && return GitHash()
-    ensure_initialized()
     GC.@preserve ref begin
         oid_ptr = ccall((:git_reference_target, :libgit2), Ptr{UInt8}, (Ptr{Cvoid},), ref.ptr)
         oid_ptr == C_NULL && return GitHash()
@@ -128,7 +123,6 @@
 """
 function GitHash(repo::GitRepo, ref_name::AbstractString)
     isempty(repo) && return GitHash()
-    ensure_initialized()
     oid_ptr  = Ref(GitHash())
     @check ccall((:git_reference_name_to_id, :libgit2), Cint,
                     (Ptr{GitHash}, Ptr{Cvoid}, Cstring),
@@ -142,7 +136,6 @@
 Get the identifier (`GitHash`) of `obj`.
 """
 function GitHash(obj::GitObject)
-    ensure_initialized()
     GitHash(ccall((:git_object_id, :libgit2), Ptr{UInt8}, (Ptr{Cvoid},), obj.ptr))
 end
 
@@ -156,7 +149,6 @@
 unambiuously identify the object in the repository.
 """
 function GitShortHash(obj::GitObject)
-    ensure_initialized()
     buf_ref = Ref(Buffer())
     @check ccall((:git_object_short_id, :libgit2), Cint,
                  (Ptr{Buffer},Ptr{Cvoid}), buf_ref, obj.ptr)
@@ -185,13 +177,11 @@
 Base.hash(id::GitHash, h::UInt) = hash(id.val, h)
 
 function Base.cmp(id1::GitHash, id2::GitHash)
-    ensure_initialized()
     Int(ccall((:git_oid_cmp, :libgit2), Cint,
               (Ptr{GitHash}, Ptr{GitHash}),
               Ref(id1), Ref(id2)))
 end
 function Base.cmp(id1::GitShortHash, id2::GitShortHash)
-    ensure_initialized()
     # shortened hashes appear at the beginning of the order, i.e.
     # 000 < 01 < 010 < 011 < 0112
     c = Int(ccall((:git_oid_ncmp, :libgit2), Cint,
reverted:
--- b/stdlib/LibGit2/src/rebase.jl
+++ a/stdlib/LibGit2/src/rebase.jl
@@ -3,7 +3,6 @@
 function GitRebase(repo::GitRepo, branch::GitAnnotated, upstream::GitAnnotated;
                    onto::Union{GitAnnotated, Nothing}=nothing,
                    opts::RebaseOptions = RebaseOptions())
-    ensure_initialized()
     rebase_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_rebase_init, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid},
@@ -14,7 +13,6 @@
 end
 
 function count(rb::GitRebase)
-    ensure_initialized()
     return ccall((:git_rebase_operation_entrycount, :libgit2), Csize_t, (Ptr{Cvoid},), rb.ptr)
 end
 
@@ -27,7 +25,6 @@
 `GIT_REBASE_NO_OPERATION`, which is equal to `typemax(Csize_t)`.
 """
 function current(rb::GitRebase)
-    ensure_initialized()
     return ccall((:git_rebase_operation_current, :libgit2), Csize_t, (Ptr{Cvoid},), rb.ptr)
 end
 
@@ -35,7 +32,6 @@
     if !(1 <= i <= count(rb))
         throw(BoundsError(rb, (i,)))
     end
-    ensure_initialized()
     GC.@preserve rb begin
         rb_op_ptr = ccall((:git_rebase_operation_byindex, :libgit2),
                           Ptr{RebaseOperation},
@@ -46,7 +42,6 @@
 end
 
 function Base.iterate(rb::GitRebase, state=nothing)
-    ensure_initialized()
     rb_op_ptr_ptr = Ref{Ptr{RebaseOperation}}(C_NULL)
     GC.@preserve rb begin
         err = ccall((:git_rebase_next, :libgit2), Cint,
@@ -75,7 +70,6 @@
 the commit has already been applied.
 """
 function commit(rb::GitRebase, sig::GitSignature)
-    ensure_initialized()
     oid_ptr = Ref(GitHash())
     try
         @check ccall((:git_rebase_commit, :libgit2), Error.Code,
@@ -99,7 +93,6 @@
 rebase had completed), and `-1` for other errors.
 """
 function abort(rb::GitRebase)
-    ensure_initialized()
     return ccall((:git_rebase_abort, :libgit2), Csize_t,
                       (Ptr{Cvoid},), rb.ptr)
 end
@@ -112,7 +105,6 @@
 rebase finishes successfully, `-1` if there is an error.
 """
 function finish(rb::GitRebase, sig::GitSignature)
-    ensure_initialized()
     return ccall((:git_rebase_finish, :libgit2), Csize_t,
                   (Ptr{Cvoid}, Ptr{SignatureStruct}),
                    rb.ptr, sig.ptr)
reverted:
--- b/stdlib/LibGit2/src/reference.jl
+++ a/stdlib/LibGit2/src/reference.jl
@@ -1,7 +1,6 @@
 # This file is a part of Julia. License is MIT: https://julialang.org/license
 
 function GitReference(repo::GitRepo, refname::AbstractString)
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_reference_lookup, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring),
@@ -11,7 +10,6 @@
 
 function GitReference(repo::GitRepo, obj_oid::GitHash, refname::AbstractString = Consts.HEAD_FILE;
                       force::Bool=false, msg::AbstractString="")
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_reference_create, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{UInt8}, Ptr{GitHash}, Cint, Cstring),
@@ -27,7 +25,6 @@
 to this branch will have no parents.
 """
 function isorphan(repo::GitRepo)
-    ensure_initialized()
     r = @check ccall((:git_repository_head_unborn, :libgit2), Cint,
                      (Ptr{Cvoid},), repo.ptr)
     r != 0
@@ -39,7 +36,6 @@
 Return a `GitReference` to the current HEAD of `repo`.
 """
 function head(repo::GitRepo)
-    ensure_initialized()
     head_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_head, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}), head_ptr_ptr, repo.ptr)
@@ -66,7 +62,6 @@
 """
 function shortname(ref::GitReference)
     isempty(ref) && return ""
-    ensure_initialized()
     GC.@preserve ref begin
         name_ptr = ccall((:git_reference_shorthand, :libgit2), Cstring, (Ptr{Cvoid},), ref.ptr)
         name_ptr == C_NULL && return ""
@@ -84,7 +79,6 @@
   * `2` if the reference is symbolic
 """
 function reftype(ref::GitReference)
-    ensure_initialized()
     return ccall((:git_reference_type, :libgit2), Cint, (Ptr{Cvoid},), ref.ptr)
 end
 
@@ -98,7 +92,6 @@
 function fullname(ref::GitReference)
     isempty(ref) && return ""
     reftype(ref) == Consts.REF_OID && return ""
-    ensure_initialized()
     GC.@preserve ref begin
         rname = ccall((:git_reference_symbolic_target, :libgit2), Cstring, (Ptr{Cvoid},), ref.ptr)
         rname == C_NULL && return ""
@@ -114,7 +107,6 @@
 """
 function name(ref::GitReference)
     isempty(ref) && return ""
-    ensure_initialized()
     GC.@preserve ref begin
         name_ptr = ccall((:git_reference_name, :libgit2), Cstring, (Ptr{Cvoid},), ref.ptr)
         name_ptr == C_NULL && return ""
@@ -125,7 +117,6 @@
 
 function branch(ref::GitReference)
     isempty(ref) && return ""
-    ensure_initialized()
     str_ptr_ptr = Ref{Cstring}()
     GC.@preserve ref begin
         @check ccall((:git_branch_name, :libgit2), Cint,
@@ -137,7 +128,6 @@
 
 function ishead(ref::GitReference)
     isempty(ref) && return false
-    ensure_initialized()
     err = ccall((:git_branch_is_head, :libgit2), Cint,
                   (Ptr{Cvoid},), ref.ptr)
     return err == 1
@@ -145,7 +135,6 @@
 
 function isbranch(ref::GitReference)
     isempty(ref) && return false
-    ensure_initialized()
     err = ccall((:git_reference_is_branch, :libgit2), Cint,
                   (Ptr{Cvoid},), ref.ptr)
     return err == 1
@@ -153,7 +142,6 @@
 
 function istag(ref::GitReference)
     isempty(ref) && return false
-    ensure_initialized()
     err = ccall((:git_reference_is_tag, :libgit2), Cint,
                   (Ptr{Cvoid},), ref.ptr)
     return err == 1
@@ -161,7 +149,6 @@
 
 function isremote(ref::GitReference)
     isempty(ref) && return false
-    ensure_initialized()
     err = ccall((:git_reference_is_remote, :libgit2), Cint,
                   (Ptr{Cvoid},), ref.ptr)
     return err == 1
@@ -197,7 +184,6 @@
     are references under `refs/tags/` which point directly to `GitCommit` objects.
 """
 function peel(::Type{T}, ref::GitReference) where T<:GitObject
-    ensure_initialized()
     obj_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_reference_peel, :libgit2), Cint,
                  (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint), obj_ptr_ptr, ref.ptr, Consts.OBJECT(T))
@@ -211,7 +197,6 @@
 Get a list of all reference names in the `repo` repository.
 """
 function ref_list(repo::GitRepo)
-    ensure_initialized()
     sa_ref = Ref(StrArrayStruct())
     @check ccall((:git_reference_list, :libgit2), Cint,
                       (Ptr{StrArrayStruct}, Ptr{Cvoid}), sa_ref, repo.ptr)
@@ -233,7 +218,6 @@
                        bname::AbstractString,
                        commit_obj::GitCommit;
                        force::Bool=false)
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_branch_create, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Ptr{Cvoid}, Cint),
@@ -247,7 +231,6 @@
 Delete the branch pointed to by `branch`.
 """
 function delete_branch(branch::GitReference)
-    ensure_initialized()
     @check ccall((:git_branch_delete, :libgit2), Cint, (Ptr{Cvoid},), branch.ptr)
 end
 
@@ -257,7 +240,6 @@
 Set the HEAD of `repo` to the object pointed to by `ref`.
 """
 function head!(repo::GitRepo, ref::GitReference)
-    ensure_initialized()
     ref_name = name(ref)
     @check ccall((:git_repository_set_head, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring), repo.ptr, ref_name)
@@ -277,7 +259,6 @@
 function lookup_branch(repo::GitRepo,
                        branch_name::AbstractString,
                        remote::Bool=false)
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     branch_type = remote ? Consts.BRANCH_REMOTE : Consts.BRANCH_LOCAL
     err = ccall((:git_branch_lookup, :libgit2), Cint,
@@ -305,7 +286,6 @@
 """
 function upstream(ref::GitReference)
     isempty(ref) && return nothing
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     err = ccall((:git_branch_upstream, :libgit2), Cint,
                   (Ref{Ptr{Cvoid}}, Ptr{Cvoid},), ref_ptr_ptr, ref.ptr)
@@ -324,7 +304,6 @@
 repository(ref::GitReference) = ref.owner
 
 function target!(ref::GitReference, new_oid::GitHash; msg::AbstractString="")
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_reference_set_target, :libgit2), Cint,
              (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{GitHash}, Cstring),
@@ -333,7 +312,6 @@
 end
 
 function GitBranchIter(repo::GitRepo, flags::Cint=Cint(Consts.BRANCH_LOCAL))
-    ensure_initialized()
     bi_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_branch_iterator_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint), bi_ptr, repo.ptr, flags)
@@ -341,7 +319,6 @@
 end
 
 function Base.iterate(bi::GitBranchIter, state=nothing)
-    ensure_initialized()
     ref_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     btype = Ref{Cint}()
     err = ccall((:git_branch_next, :libgit2), Cint,
reverted:
--- b/stdlib/LibGit2/src/remote.jl
+++ a/stdlib/LibGit2/src/remote.jl
@@ -12,7 +12,6 @@
 ```
 """
 function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString)
-    ensure_initialized()
     rmt_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_remote_create, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Cstring),
@@ -35,7 +34,6 @@
 ```
 """
 function GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString)
-    ensure_initialized()
     rmt_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_remote_create_with_fetchspec, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring, Cstring, Cstring),
@@ -55,7 +53,6 @@
 ```
 """
 function GitRemoteAnon(repo::GitRepo, url::AbstractString)
-    ensure_initialized()
     rmt_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_remote_create_anonymous, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring),
@@ -78,7 +75,6 @@
 ```
 """
 function lookup_remote(repo::GitRepo, remote_name::AbstractString)
-    ensure_initialized()
     rmt_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     err = ccall((:git_remote_lookup, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring),
@@ -93,7 +89,6 @@
 end
 
 function get(::Type{GitRemote}, repo::GitRepo, rmt_name::AbstractString)
-    ensure_initialized()
     rmt_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_remote_lookup, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cstring),
@@ -119,7 +114,6 @@
 ```
 """
 function url(rmt::GitRemote)
-    ensure_initialized()
     url_ptr = ccall((:git_remote_url, :libgit2), Cstring, (Ptr{Cvoid},), rmt.ptr)
     url_ptr == C_NULL && return ""
     return unsafe_string(url_ptr)
@@ -143,7 +137,6 @@
 ```
 """
 function push_url(rmt::GitRemote)
-    ensure_initialized()
     url_ptr = ccall((:git_remote_pushurl, :libgit2), Cstring, (Ptr{Cvoid},), rmt.ptr)
     url_ptr == C_NULL && return ""
     return unsafe_string(url_ptr)
@@ -169,7 +162,6 @@
 ```
 """
 function name(rmt::GitRemote)
-    ensure_initialized()
     name_ptr = ccall((:git_remote_name, :libgit2), Cstring, (Ptr{Cvoid},), rmt.ptr)
     name_ptr == C_NULL && return ""
     return unsafe_string(name_ptr)
@@ -192,7 +184,6 @@
 ```
 """
 function fetch_refspecs(rmt::GitRemote)
-    ensure_initialized()
     sa_ref = Ref(StrArrayStruct())
     @check ccall((:git_remote_get_fetch_refspecs, :libgit2), Cint,
                  (Ptr{StrArrayStruct}, Ptr{Cvoid}), sa_ref, rmt.ptr)
@@ -222,7 +213,6 @@
 ```
 """
 function push_refspecs(rmt::GitRemote)
-    ensure_initialized()
     sa_ref = Ref(StrArrayStruct())
     @check ccall((:git_remote_get_push_refspecs, :libgit2), Cint,
                  (Ptr{StrArrayStruct}, Ptr{Cvoid}), sa_ref, rmt.ptr)
@@ -246,7 +236,6 @@
 ```
 """
 function add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
-    ensure_initialized()
     @check ccall((:git_remote_add_fetch, :libgit2), Cint,
                  (Ptr{Cvoid}, Cstring, Cstring), repo.ptr,
                  name(rmt), fetch_spec)
@@ -275,7 +264,6 @@
     to work.
 """
 function add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
-    ensure_initialized()
     @check ccall((:git_remote_add_push, :libgit2), Cint,
                  (Ptr{Cvoid}, Cstring, Cstring), repo.ptr,
                  name(rmt), push_spec)
@@ -294,7 +282,6 @@
 function fetch(rmt::GitRemote, refspecs::Vector{<:AbstractString};
                options::FetchOptions = FetchOptions(),
                msg::AbstractString="")
-    ensure_initialized()
     msg = "libgit2.fetch: $msg"
     @check ccall((:git_remote_fetch, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{StrArrayStruct}, Ptr{FetchOptions}, Cstring),
@@ -320,7 +307,6 @@
 """
 function push(rmt::GitRemote, refspecs::Vector{<:AbstractString};
               force::Bool = false, options::PushOptions = PushOptions())
-    ensure_initialized()
     @check ccall((:git_remote_push, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{StrArrayStruct}, Ptr{PushOptions}),
                  rmt.ptr, isempty(refspecs) ? C_NULL : refspecs, Ref(options))
@@ -332,7 +318,6 @@
 Delete the `remote_name` from the git `repo`.
 """
 function remote_delete(repo::GitRepo, remote_name::AbstractString)
-    ensure_initialized()
     @check ccall((:git_remote_delete, :libgit2), Cint,
                  (Ptr{Cvoid}, Cstring),
                  repo.ptr, remote_name)
@@ -351,7 +336,6 @@
 function set_remote_fetch_url end
 
 function set_remote_fetch_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
-    ensure_initialized()
     @check ccall((:git_remote_set_url, :libgit2), Cint,
                  (Ptr{Cvoid}, Cstring, Cstring),
                  repo.ptr, remote_name, url)
@@ -374,7 +358,6 @@
 function set_remote_push_url end
 
 function set_remote_push_url(repo::GitRepo, remote_name::AbstractString, url::AbstractString)
-    ensure_initialized()
     @check ccall((:git_remote_set_pushurl, :libgit2), Cint,
                  (Ptr{Cvoid}, Cstring, Cstring),
                  repo.ptr, remote_name, url)
reverted:
--- b/stdlib/LibGit2/src/repository.jl
+++ a/stdlib/LibGit2/src/repository.jl
@@ -6,7 +6,6 @@
 Open a git repository at `path`.
 """
 function GitRepo(path::AbstractString)
-    ensure_initialized()
     repo_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_open, :libgit2), Cint,
                  (Ptr{Ptr{Cvoid}}, Cstring), repo_ptr_ptr, path)
@@ -20,7 +19,6 @@
 user must be a member of a special access group to read `path`).
 """
 function GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
-    ensure_initialized()
     separator = @static Sys.iswindows() ? ";" : ":"
     repo_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_open_ext, :libgit2), Cint,
@@ -31,7 +29,6 @@
 
 function cleanup(r::GitRepo)
     if r.ptr != C_NULL
-        ensure_initialized()
         ccall((:git_repository__cleanup, :libgit2), Cvoid, (Ptr{Cvoid},), r.ptr)
     end
 end
@@ -44,7 +41,6 @@
 is `true`, no working directory will be created.
 """
 function init(path::AbstractString, bare::Bool=false)
-    ensure_initialized()
     repo_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_repository_init, :libgit2), Cint,
                 (Ptr{Ptr{Cvoid}}, Cstring, Cuint), repo_ptr_ptr, path, bare)
@@ -95,7 +91,6 @@
 tree, and no tracking information for remote branches or configurations is present.
 """
 function isbare(repo::GitRepo)
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     return ccall((:git_repository_is_bare, :libgit2), Cint, (Ptr{Cvoid},), repo.ptr) == 1
 end
@@ -107,7 +102,6 @@
 (detached) or whether HEAD points to a branch tip (attached).
 """
 function isattached(repo::GitRepo)
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     ccall((:git_repository_head_detached, :libgit2), Cint, (Ptr{Cvoid},), repo.ptr) != 1
 end
@@ -136,7 +130,6 @@
 end
 
 function (::Type{T})(repo::GitRepo, spec::AbstractString) where T<:GitObject
-    ensure_initialized()
     obj_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @assert repo.ptr != C_NULL
     @check ccall((:git_revparse_single, :libgit2), Cint,
@@ -150,7 +143,6 @@
 end
 
 function (::Type{T})(repo::GitRepo, oid::GitHash) where T<:GitObject
-    ensure_initialized()
     oid_ptr  = Ref(oid)
     obj_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
 
@@ -162,7 +154,6 @@
     return T(repo, obj_ptr_ptr[])
 end
 function (::Type{T})(repo::GitRepo, oid::GitShortHash) where T<:GitObject
-    ensure_initialized()
     oid_ptr  = Ref(oid.hash)
     obj_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
 
@@ -188,7 +179,6 @@
 See also [`workdir`](@ref), [`path`](@ref).
 """
 function gitdir(repo::GitRepo)
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     return unsafe_string(ccall((:git_repository_path, :libgit2), Cstring,
                         (Ptr{Cvoid},), repo.ptr))
@@ -209,7 +199,6 @@
 See also [`gitdir`](@ref), [`path`](@ref).
 """
 function workdir(repo::GitRepo)
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     sptr = ccall((:git_repository_workdir, :libgit2), Cstring,
                 (Ptr{Cvoid},), repo.ptr)
@@ -252,7 +241,6 @@
 - A `GitCommit` will be peeled to a `GitTree`.
 """
 function peel(::Type{T}, obj::GitObject) where T<:GitObject
-    ensure_initialized()
     new_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
 
     @check ccall((:git_object_peel, :libgit2), Cint,
@@ -283,7 +271,6 @@
 """
 function GitDescribeResult(commitish::GitObject;
                            options::DescribeOptions=DescribeOptions())
-    ensure_initialized()
     result_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_describe_commit, :libgit2), Cint,
                  (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{DescribeOptions}),
@@ -309,7 +296,6 @@
 information.
 """
 function GitDescribeResult(repo::GitRepo; options::DescribeOptions=DescribeOptions())
-    ensure_initialized()
     result_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @assert repo.ptr != C_NULL
     @check ccall((:git_describe_workdir, :libgit2), Cint,
@@ -327,7 +313,6 @@
   * `options::DescribeFormatOptions=DescribeFormatOptions()`
 """
 function format(result::GitDescribeResult; options::DescribeFormatOptions=DescribeFormatOptions())
-    ensure_initialized()
     buf_ref = Ref(Buffer())
     @check ccall((:git_describe_format, :libgit2), Cint,
                  (Ptr{Buffer}, Ptr{Cvoid}, Ptr{DescribeFormatOptions}),
@@ -353,7 +338,6 @@
 """
 function checkout_tree(repo::GitRepo, obj::GitObject;
                        options::CheckoutOptions = CheckoutOptions())
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_checkout_tree, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{CheckoutOptions}),
@@ -369,7 +353,6 @@
 """
 function checkout_index(repo::GitRepo, idx::Union{GitIndex, Nothing} = nothing;
                         options::CheckoutOptions = CheckoutOptions())
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_checkout_index, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{CheckoutOptions}),
@@ -389,7 +372,6 @@
     conflicts.
 """
 function checkout_head(repo::GitRepo; options::CheckoutOptions = CheckoutOptions())
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_checkout_head, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{CheckoutOptions}),
@@ -408,7 +390,6 @@
     call [`commit`](@ref) yourself.
 """
 function cherrypick(repo::GitRepo, commit::GitCommit; options::CherrypickOptions = CherrypickOptions())
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_cherrypick, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{CherrypickOptions}),
@@ -417,7 +398,6 @@
 
 """Updates some entries, determined by the `pathspecs`, in the index from the target commit tree."""
 function reset!(repo::GitRepo, obj::Union{GitObject, Nothing}, pathspecs::AbstractString...)
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_reset_default, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{StrArrayStruct}),
@@ -430,7 +410,6 @@
 """Sets the current head to the specified commit oid and optionally resets the index and working tree to match."""
 function reset!(repo::GitRepo, obj::GitObject, mode::Cint;
                checkout_opts::CheckoutOptions = CheckoutOptions())
-    ensure_initialized()
     @assert repo.ptr != C_NULL
     @check ccall((:git_reset, :libgit2), Cint,
                  (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Ptr{CheckoutOptions}),
@@ -453,7 +432,6 @@
 """
 function clone(repo_url::AbstractString, repo_path::AbstractString,
                clone_opts::CloneOptions)
-    ensure_initialized()
     clone_opts_ref = Ref(clone_opts)
     repo_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_clone, :libgit2), Cint,
@@ -486,7 +464,6 @@
 ```
 """
 function fetchheads(repo::GitRepo)
-    ensure_initialized()
     fh = FetchHead[]
     ffcb = fetchhead_foreach_cb()
     @assert repo.ptr != C_NULL
@@ -502,7 +479,6 @@
 Return a vector of the names of the remotes of `repo`.
 """
 function remotes(repo::GitRepo)
-    ensure_initialized()
     sa_ref = Ref(StrArrayStruct())
     @assert repo.ptr != C_NULL
     @check ccall((:git_remote_list, :libgit2), Cint,
reverted:
--- b/stdlib/LibGit2/src/signature.jl
+++ a/stdlib/LibGit2/src/signature.jl
@@ -11,7 +11,6 @@
 Signature(sig::GitSignature) = Signature(sig.ptr)
 
 function Signature(name::AbstractString, email::AbstractString)
-    ensure_initialized()
     sig_ptr_ptr = Ref{Ptr{SignatureStruct}}(C_NULL)
     @check ccall((:git_signature_now, :libgit2), Cint,
                  (Ptr{Ptr{SignatureStruct}}, Cstring, Cstring), sig_ptr_ptr, name, email)
@@ -29,7 +28,6 @@
 end
 
 function Base.convert(::Type{GitSignature}, sig::Signature)
-    ensure_initialized()
     sig_ptr_ptr = Ref{Ptr{SignatureStruct}}(C_NULL)
     @check ccall((:git_signature_new, :libgit2), Cint,
                  (Ptr{Ptr{SignatureStruct}}, Cstring, Cstring, Int64, Cint),
@@ -64,7 +62,6 @@
 
 """Return signature object. Free it after use."""
 function default_signature(repo::GitRepo)
-    ensure_initialized()
     sig_ptr_ptr = Ref{Ptr{SignatureStruct}}(C_NULL)
     @check ccall((:git_signature_default, :libgit2), Cint,
                  (Ptr{Ptr{SignatureStruct}}, Ptr{Cvoid}), sig_ptr_ptr, repo.ptr)
reverted:
--- b/stdlib/LibGit2/src/status.jl
+++ a/stdlib/LibGit2/src/status.jl
@@ -10,7 +10,6 @@
 submodules or not. See [`StatusOptions`](@ref) for more information.
 """
 function GitStatus(repo::GitRepo; status_opts=StatusOptions())
-    ensure_initialized()
     stat_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_status_list_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Ptr{StatusOptions}),
@@ -19,14 +18,12 @@
 end
 
 function Base.length(status::GitStatus)
-    ensure_initialized()
     return Int(ccall((:git_status_list_entrycount, :libgit2), Csize_t,
                       (Ptr{Ptr{Cvoid}},), status.ptr))
 end
 
 function Base.getindex(status::GitStatus, i::Integer)
     1 <= i <= length(status) || throw(BoundsError())
-    ensure_initialized()
     GC.@preserve status begin
         entry_ptr = ccall((:git_status_byindex, :libgit2),
                           Ptr{StatusEntry},
@@ -47,7 +44,6 @@
 and needs to be staged and committed.
 """
 function status(repo::GitRepo, path::String)
-    ensure_initialized()
     status_ptr = Ref{Cuint}(0)
     ret =  ccall((:git_status_file, :libgit2), Cint,
                   (Ref{Cuint}, Ptr{Cvoid}, Cstring),
reverted:
--- b/stdlib/LibGit2/src/tag.jl
+++ a/stdlib/LibGit2/src/tag.jl
@@ -6,7 +6,6 @@
 Get a list of all tags in the git repository `repo`.
 """
 function tag_list(repo::GitRepo)
-    ensure_initialized()
     sa_ref = Ref(StrArrayStruct())
     @check ccall((:git_tag_list, :libgit2), Cint,
                  (Ptr{StrArrayStruct}, Ptr{Cvoid}), sa_ref, repo.ptr)
@@ -21,7 +20,6 @@
 Remove the git tag `tag` from the repository `repo`.
 """
 function tag_delete(repo::GitRepo, tag::AbstractString)
-    ensure_initialized()
     @check ccall((:git_tag_delete, :libgit2), Cint,
                   (Ptr{Cvoid}, Cstring), repo.ptr, tag)
 end
@@ -45,7 +43,6 @@
     with(GitCommit(repo, commit)) do commit_obj
         commit_obj === nothing && return oid_ptr[] # return empty oid
         with(convert(GitSignature, sig)) do git_sig
-            ensure_initialized()
             @check ccall((:git_tag_create, :libgit2), Cint,
                  (Ptr{GitHash}, Ptr{Cvoid}, Cstring, Ptr{Cvoid}, Ptr{SignatureStruct}, Cstring, Cint),
                   oid_ptr, repo.ptr, tag, commit_obj.ptr, git_sig.ptr, msg, Cint(force))
@@ -60,7 +57,6 @@
 The name of `tag` (e.g. `"v0.5"`).
 """
 function name(tag::GitTag)
-    ensure_initialized()
     GC.@preserve tag begin
         str_ptr = ccall((:git_tag_name, :libgit2), Cstring, (Ptr{Cvoid},), tag.ptr)
         str_ptr == C_NULL && throw(Error.GitError(Error.ERROR))
@@ -76,7 +72,6 @@
 The `GitHash` of the target object of `tag`.
 """
 function target(tag::GitTag)
-    ensure_initialized()
     GC.@preserve tag begin
         oid_ptr = ccall((:git_tag_target_id, :libgit2), Ptr{GitHash}, (Ptr{Cvoid},), tag.ptr)
         oid_ptr == C_NULL && throw(Error.GitError(Error.ERROR))
reverted:
--- b/stdlib/LibGit2/src/tree.jl
+++ a/stdlib/LibGit2/src/tree.jl
@@ -18,7 +18,6 @@
 that the entry will be skipped if `post` is `false`.
 """
 function treewalk(f, tree::GitTree, post::Bool = false)
-    ensure_initialized()
     # NOTE: don't use @check/GitError directly, because the code can be arbitrary
     payload = Any[ tree, f ]
     cbf = @cfunction(function treewalk_callback(root_cstr::Cstring, entry_ptr::Ptr{Cvoid}, payload::Vector{Any})::Cint
@@ -51,7 +50,6 @@
 Return the filename of the object on disk to which `te` refers.
 """
 function filename(te::GitTreeEntry)
-    ensure_initialized()
     str = ccall((:git_tree_entry_name, :libgit2), Cstring, (Ptr{Cvoid},), te.ptr)
     str != C_NULL && return unsafe_string(str)
     return nothing
@@ -63,7 +61,6 @@
 Return the UNIX filemode of the object on disk to which `te` refers as an integer.
 """
 function filemode(te::GitTreeEntry)
-    ensure_initialized()
     return ccall((:git_tree_entry_filemode, :libgit2), Cint, (Ptr{Cvoid},), te.ptr)
 end
 
@@ -74,7 +71,6 @@
 one of the types which [`objtype`](@ref) returns, e.g. a `GitTree` or `GitBlob`.
 """
 function entrytype(te::GitTreeEntry)
-    ensure_initialized()
     otype = ccall((:git_tree_entry_type, :libgit2), Cint, (Ptr{Cvoid},), te.ptr)
     return objtype(Consts.OBJECT(otype))
 end
@@ -85,7 +81,6 @@
 Return the [`GitHash`](@ref) of the object to which `te` refers.
 """
 function entryid(te::GitTreeEntry)
-    ensure_initialized()
     GC.@preserve te begin
         oid_ptr = ccall((:git_tree_entry_id, :libgit2), Ptr{UInt8}, (Ptr{Cvoid},), te.ptr)
         oid = GitHash(oid_ptr)
@@ -94,7 +89,6 @@
 end
 
 function count(tree::GitTree)
-    ensure_initialized()
     return ccall((:git_tree_entrycount, :libgit2), Csize_t, (Ptr{Cvoid},), tree.ptr)
 end
 
@@ -102,7 +96,6 @@
     if i < 1 || i > count(tree)
         throw(BoundsError(tree, i))
     end
-    ensure_initialized()
     te_ptr = ccall((:git_tree_entry_byindex, :libgit2),
                    Ptr{Cvoid},
                    (Ptr{Cvoid}, Csize_t), tree.ptr, i-1)
@@ -124,7 +117,6 @@
 """
 function GitObject(e::GitTreeEntry) end
 function (::Type{T})(te::GitTreeEntry) where T<:GitObject
-    ensure_initialized()
     repo = repository(te)
     obj_ptr_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_tree_entry_to_object, :libgit2), Cint,
@@ -176,7 +168,6 @@
             # we found the target, save the oid and stop the walk
             oid = entryid(entry)
             # workaround for issue: https://github.com/libgit2/libgit2/issues/4693
-            ensure_initialized()
             ccall((:giterr_set_str, :libgit2), Cvoid,
                   (Cint, Cstring), Cint(Error.Callback),
                   "git_tree_walk callback returned -1")
reverted:
--- b/stdlib/LibGit2/src/types.jl
+++ a/stdlib/LibGit2/src/types.jl
@@ -98,7 +98,6 @@
 StrArrayStruct() = StrArrayStruct(C_NULL, 0)
 
 function free(sa_ref::Base.Ref{StrArrayStruct})
-    ensure_initialized()
     ccall((:git_strarray_free, :libgit2), Cvoid, (Ptr{StrArrayStruct},), sa_ref)
 end
 
@@ -125,7 +124,6 @@
 Buffer() = Buffer(C_NULL, 0, 0)
 
 function free(buf_ref::Base.Ref{Buffer})
-    ensure_initialized()
     ccall((:git_buf_free, :libgit2), Cvoid, (Ptr{Buffer},), buf_ref)
 end
 
@@ -1001,7 +999,7 @@
                 @assert ptr != C_NULL
                 obj = new(ptr)
                 if fin
+                    Threads.atomic_add!(REFCOUNT, UInt(1))
-                    Threads.atomic_add!(REFCOUNT, 1)
                     finalizer(Base.close, obj)
                 end
                 return obj
@@ -1015,7 +1013,7 @@
                 @assert ptr != C_NULL
                 obj = new(owner, ptr)
                 if fin
+                    Threads.atomic_add!(REFCOUNT, UInt(1))
-                    Threads.atomic_add!(REFCOUNT, 1)
                     finalizer(Base.close, obj)
                 end
                 return obj
@@ -1029,10 +1027,9 @@
     end
     @eval function Base.close(obj::$typ)
         if obj.ptr != C_NULL
-            ensure_initialized()
             ccall(($(string(cname, :_free)), :libgit2), Cvoid, (Ptr{Cvoid},), obj.ptr)
             obj.ptr = C_NULL
+            if Threads.atomic_sub!(REFCOUNT, UInt(1)) == 1
-            if Threads.atomic_sub!(REFCOUNT, 1) == 1
                 # will the last finalizer please turn out the lights?
                 ccall((:git_libgit2_shutdown, :libgit2), Cint, ())
             end
@@ -1063,7 +1060,6 @@
 end
 function Base.close(obj::GitSignature)
     if obj.ptr != C_NULL
-        ensure_initialized()
         ccall((:git_signature_free, :libgit2), Cvoid, (Ptr{SignatureStruct},), obj.ptr)
         obj.ptr = C_NULL
     end
@@ -1160,10 +1156,8 @@
 Consts.OBJECT(::Type{GitUnknownObject}) = Consts.OBJ_ANY
 Consts.OBJECT(::Type{GitObject})        = Consts.OBJ_ANY
 
+Consts.OBJECT(ptr::Ptr{Cvoid}) =
-function Consts.OBJECT(ptr::Ptr{Cvoid})
-    ensure_initialized()
     ccall((:git_object_type, :libgit2), Consts.OBJECT, (Ptr{Cvoid},), ptr)
-end
 
 """
     objtype(obj_type::Consts.OBJECT)
reverted:
--- b/stdlib/LibGit2/src/walker.jl
+++ a/stdlib/LibGit2/src/walker.jl
@@ -19,7 +19,6 @@
 Since the `GitHash` is unique to a commit, `cnt` will be `1`.
 """
 function GitRevWalker(repo::GitRepo)
-    ensure_initialized()
     w_ptr = Ref{Ptr{Cvoid}}(C_NULL)
     @check ccall((:git_revwalk_new, :libgit2), Cint,
                   (Ptr{Ptr{Cvoid}}, Ptr{Cvoid}), w_ptr, repo.ptr)
@@ -27,7 +26,6 @@
 end
 
 function Base.iterate(w::GitRevWalker, state=nothing)
-    ensure_initialized()
     id_ptr = Ref(GitHash())
     err = ccall((:git_revwalk_next, :libgit2), Cint,
                 (Ptr{GitHash}, Ptr{Cvoid}), id_ptr, w.ptr)
@@ -50,7 +48,6 @@
 during the walk.
 """
 function push_head!(w::GitRevWalker)
-    ensure_initialized()
     @check ccall((:git_revwalk_push_head, :libgit2), Cint, (Ptr{Cvoid},), w.ptr)
     return w
 end
@@ -63,19 +60,16 @@
 of that year as `cid` and then passing the resulting `w` to [`map`](@ref LibGit2.map).
 """
 function push!(w::GitRevWalker, cid::GitHash)
-    ensure_initialized()
     @check ccall((:git_revwalk_push, :libgit2), Cint, (Ptr{Cvoid}, Ptr{GitHash}), w.ptr, Ref(cid))
     return w
 end
 
 function push!(w::GitRevWalker, range::AbstractString)
-    ensure_initialized()
     @check ccall((:git_revwalk_push_range, :libgit2), Cint, (Ptr{Cvoid}, Ptr{UInt8}), w.ptr, range)
     return w
 end
 
 function Base.sort!(w::GitRevWalker; by::Cint = Consts.SORT_NONE, rev::Bool=false)
-    ensure_initialized()
     rev && (by |= Consts.SORT_REVERSE)
     ccall((:git_revwalk_sorting, :libgit2), Cvoid, (Ptr{Cvoid}, Cint), w.ptr, by)
     return w
