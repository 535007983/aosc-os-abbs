From 0eeb66a3a85dff93577a1a7b20335745b8551a49 Mon Sep 17 00:00:00 2001
From: Luo Xionghu <xionghu.luo@intel.com>
Date: Wed, 8 Mar 2017 23:00:39 +0800
Subject: [PATCH 01/52] fix build error log not output issue.

v2: output build option and err if variable set.

Signed-off-by: Luo Xionghu <xionghu.luo@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/backend/program.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 09c79d81..8a4ad839 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -1114,8 +1114,8 @@ EXTEND_QUOTE:
                                     stringSize, err, errSize, optLevel, options);
       if (err != NULL)
         *errSize += clangErrSize;
-      if (OCL_OUTPUT_BUILD_LOG && options)
-        llvm::errs() << options;
+      if (OCL_OUTPUT_BUILD_LOG && err)
+        llvm::errs() << options << "\n" << err;
     } else
       p = NULL;
 
@@ -1168,8 +1168,8 @@ EXTEND_QUOTE:
 
       p = gbe_program_new_gen_program(deviceID, out_module, NULL, NULL);
 
-      if (OCL_OUTPUT_BUILD_LOG && options)
-        llvm::errs() << options;
+      if (OCL_OUTPUT_BUILD_LOG && err)
+        llvm::errs() << options << "\n" << err;
     } else
       p = NULL;
     releaseLLVMContextLock();

From fed38d1b30de24bcd74ec33b1c051cb564ff591e Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Thu, 9 Mar 2017 15:35:37 +0800
Subject: [PATCH 02/52] intel: Check that we can reserve the zero-offset

commit ff57cee0519d ("ocl20/runtime: take the first 64KB page table
entries") tries to allocate a bo at 0 offset, but failed to take into
account that something may already be allocated there that it is not
allowed to evict (particularly when not using full-ppgtt separation).
Failure to do so causes all execution to subsequentally fail with
"drm_intel_gem_bo_context_exec() failed: Device or resource busy"

Reported-by: Kenneth Johansson <ken@kenjo.org>
Fixes: https://bugs.freedesktop.org/show_bug.cgi?id=98647

Contributor: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/intel/intel_driver.c | 31 ++++++++++++++++++++-----------
 1 file changed, 20 insertions(+), 11 deletions(-)

diff --git a/src/intel/intel_driver.c b/src/intel/intel_driver.c
index b8a1b52f..3caf7378 100644
--- a/src/intel/intel_driver.c
+++ b/src/intel/intel_driver.c
@@ -137,19 +137,28 @@ return 1;
 static int
 intel_driver_context_init(intel_driver_t *driver)
 {
-driver->ctx = drm_intel_gem_context_create(driver->bufmgr);
-if (!driver->ctx)
-  return 0;
-driver->null_bo = NULL;
+  driver->ctx = drm_intel_gem_context_create(driver->bufmgr);
+  if (!driver->ctx)
+    return 0;
+  driver->null_bo = NULL;
 #ifdef HAS_BO_SET_SOFTPIN
-drm_intel_bo *bo = dri_bo_alloc(driver->bufmgr, "null_bo", 64*1024, 4096);
-drm_intel_bo_set_softpin_offset(bo, 0);
-// don't reuse it, that would make two bo trying to bind to same address,
-// which is un-reasonable.
-drm_intel_bo_disable_reuse(bo);
-driver->null_bo = bo;
+  drm_intel_bo *bo = dri_bo_alloc(driver->bufmgr, "null_bo", 64*1024, 4096);
+  drm_intel_bo_set_softpin_offset(bo, 0);
+  // don't reuse it, that would make two bo trying to bind to same address,
+  // which is un-reasonable.
+  drm_intel_bo_disable_reuse(bo);
+
+  drm_intel_bo_map(bo, 1);
+  *(uint32_t *)bo->virtual = MI_BATCH_BUFFER_END;
+  drm_intel_bo_unmap(bo);
+
+  if (drm_intel_gem_bo_context_exec(bo, driver->ctx, 0, 0) == 0) {
+    driver->null_bo = bo;
+  } else {
+    drm_intel_bo_unreference(bo);
+  }
 #endif
-return 1;
+    return 1;
 }
 
 static void

From ec455bc21ad17224f6a82edc900fabd7fad5ed56 Mon Sep 17 00:00:00 2001
From: Jan Beich <jbeich@freebsd.org>
Date: Fri, 17 Mar 2017 14:16:00 +0000
Subject: [PATCH 03/52] Properly check return value from __cxa_demangle

FreeBSD uses libcxxrt (via libc++) instead of GNU libiberty (via
libstdc++) for __cxa_demangle(). When *output_buffer* and *length*
both are NULL it doesn't modify *status* on success. Rather than rely
on maybe uninitialized variable check the function doesn't return NULL.

Fixes: https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=213732
Signed-off-by: Jan Beich <jbeich@freebsd.org>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/llvm/llvm_gen_backend.hpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/backend/src/llvm/llvm_gen_backend.hpp b/backend/src/llvm/llvm_gen_backend.hpp
index 1ab77c9d..ae486c5e 100644
--- a/backend/src/llvm/llvm_gen_backend.hpp
+++ b/backend/src/llvm/llvm_gen_backend.hpp
@@ -82,9 +82,9 @@ namespace gbe
       auto it = map.find(symbol);
 
       if (it == map.end()) {
-        int status;
+        int status = 0; /* set for libcxxrt */
         char *realName = abi::__cxa_demangle(symbol.c_str(), NULL, NULL, &status);
-        if (status == 0) {
+        if (realName) {
           std::string realFnName(realName), stripName;
           stripName = realFnName.substr(0, realFnName.find("("));
           it = map.find(stripName);

From 520af6d20381da9cacab47bbef4ed88fc16464cd Mon Sep 17 00:00:00 2001
From: Luo Xionghu <xionghu.luo@intel.com>
Date: Mon, 20 Mar 2017 22:34:06 +0800
Subject: [PATCH 04/52] llvm3.9 will assert if ouput is empty string.

Signed-off-by: Luo Xionghu <xionghu.luo@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/program.cpp | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 8a4ad839..8b8abc4d 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -1114,8 +1114,10 @@ EXTEND_QUOTE:
                                     stringSize, err, errSize, optLevel, options);
       if (err != NULL)
         *errSize += clangErrSize;
-      if (OCL_OUTPUT_BUILD_LOG && err)
-        llvm::errs() << options << "\n" << err;
+      if (OCL_OUTPUT_BUILD_LOG && options)
+        llvm::errs() << "options:" << options << "\n";
+      if (OCL_OUTPUT_BUILD_LOG && err && *errSize)
+        llvm::errs() << err << "\n";
     } else
       p = NULL;
 
@@ -1168,8 +1170,10 @@ EXTEND_QUOTE:
 
       p = gbe_program_new_gen_program(deviceID, out_module, NULL, NULL);
 
-      if (OCL_OUTPUT_BUILD_LOG && err)
-        llvm::errs() << options << "\n" << err;
+      if (OCL_OUTPUT_BUILD_LOG && options)
+        llvm::errs() << "options:" << options << "\n";
+      if (OCL_OUTPUT_BUILD_LOG && err && *errSize)
+        llvm::errs() << err << "\n";
     } else
       p = NULL;
     releaseLLVMContextLock();

From e59917a714b69b567676be0d8750edd91c59243a Mon Sep 17 00:00:00 2001
From: Jan Beich <jbeich@freebsd.org>
Date: Thu, 16 Mar 2017 10:13:21 +0000
Subject: [PATCH 05/52] Limit get_program_global_data() calls to OpenCL 2.0

https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=217635

Signed-off-by: Jan Beich <jbeich@freebsd.org>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 src/cl_program.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/cl_program.c b/src/cl_program.c
index 363aed5d..bb96d98f 100644
--- a/src/cl_program.c
+++ b/src/cl_program.c
@@ -675,7 +675,8 @@ cl_program_build(cl_program p, const char *options)
     memcpy(p->bin + copyed, interp_kernel_get_code(opaque), sz);
     copyed += sz;
   }
-  if ((err = get_program_global_data(p)) != CL_SUCCESS)
+  uint32_t ocl_version = interp_kernel_get_ocl_version(interp_program_get_kernel(p->opaque, 0));
+  if (ocl_version >= 200 && (err = get_program_global_data(p)) != CL_SUCCESS)
     goto error;
 
   p->is_built = 1;
@@ -784,7 +785,8 @@ cl_program_link(cl_context            context,
     copyed += sz;
   }
 
-  if ((err = get_program_global_data(p)) != CL_SUCCESS)
+  uint32_t ocl_version = interp_kernel_get_ocl_version(interp_program_get_kernel(p->opaque, 0));
+  if (ocl_version >= 200 && (err = get_program_global_data(p)) != CL_SUCCESS)
     goto error;
 
 done:

From 67bb6f9efc70158095061310fa10cbd1cc432ab3 Mon Sep 17 00:00:00 2001
From: "Rebecca N. Palmer" <rebecca_palmer@zoho.com>
Date: Wed, 15 Mar 2017 07:46:31 +0000
Subject: [PATCH 06/52] Docs: Fix spelling and grammar

Signed-off-by: Rebecca N. Palmer <rebecca_palmer@zoho.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 docs/howto/gl-buffer-sharing-howto.mdwn | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/docs/howto/gl-buffer-sharing-howto.mdwn b/docs/howto/gl-buffer-sharing-howto.mdwn
index 6b3a751c..5fb3d87e 100644
--- a/docs/howto/gl-buffer-sharing-howto.mdwn
+++ b/docs/howto/gl-buffer-sharing-howto.mdwn
@@ -1,16 +1,16 @@
 GL Buffer Sharing HowTo
 =========================
 
-Beignet now support cl_khr_gl_sharing partially(the most commonly used part), which is an offcial
+Beignet now supports cl_khr_gl_sharing partially (the most commonly used part), which is an official
 extension of Khronos OpenCL. With this extension, Beignet can create memory object from OpenGL/OpenGL
-ES buffer, texture or renderbuffer object with zero-copy. Currently, we just support create memory
-object from GL buffer object or 2d texture(the most common target type). We will support creating
+ES buffer, texture or renderbuffer object with zero-copy. Currently, we just support creating memory
+object from GL buffer object or 2d texture (the most common target type). We will support creating
 from other GL target type if necessary.
 
 Prerequisite
 ------------
 
-Mesa GL library and Mesa EGL libray are required. Both version should be greater or equal than
+Mesa GL library and Mesa EGL library are required. Both version should be greater or equal than
 13.0.0.
 
 Steps
@@ -18,7 +18,7 @@ Steps
 
 A typical procedure of using cl_khr_gl_sharing is as below:
 
-- Basic egl routine(eglGetDisplay, eglInitialize, eglCreateContext...).
+- Basic egl routine (eglGetDisplay, eglInitialize, eglCreateContext...).
 
 - Create GL 2d texture in normal OpenGL way.
 
@@ -44,7 +44,7 @@ A typical procedure of using cl_khr_gl_sharing is as below:
 
 - Access this cl image object as an usual cl image object.
 
-- Relase cl image object by calling clEnqueueReleaseGLObjects.
+- Release cl image object by calling clEnqueueReleaseGLObjects.
 
 - Ensure any pending OpenCL operations which access this cl image object have completed by clFinish.
 
@@ -54,7 +54,7 @@ Sample code
 -----------
 
 We have developed an example showing how to utilize cl_khr_gl_sharing in examples/gl_buffer_sharing
-directory. A cl image object is created from a gl 2d texutre and processed by OpenCL kernel, then
+directory. A cl image object is created from a gl 2d texture and processed by OpenCL kernel, then
 is shown on screen.
 
 Steps to build and run this example:

From fa82b1d1161b3c96e45444af03d8b98a951875fc Mon Sep 17 00:00:00 2001
From: "Rebecca N. Palmer" <rebecca_palmer@zoho.com>
Date: Wed, 15 Mar 2017 07:50:52 +0000
Subject: [PATCH 07/52] Docs: Fix broken link

Signed-off-by: Rebecca N. Palmer <rebecca_palmer@zoho.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 docs/Beignet.mdwn | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/docs/Beignet.mdwn b/docs/Beignet.mdwn
index b1019da2..75039d41 100644
--- a/docs/Beignet.mdwn
+++ b/docs/Beignet.mdwn
@@ -283,7 +283,7 @@ Documents for OpenCL application developers
 - [[OpenGL Buffer Sharing|Beignet/howto/gl-buffer-sharing-howto]]
 - [[Video Motion Estimation|Beignet/howto/video-motion-estimation-howto]]
 - [[Stand Alone Unit Test|Beignet/howto/stand-alone-utest-howto]]
-- [[Android build|Beignet/android-build-howto]]
+- [[Android build|Beignet/howto/android-build-howto]]
 
 The wiki URL is as below:
 [http://www.freedesktop.org/wiki/Software/Beignet/](http://www.freedesktop.org/wiki/Software/Beignet/)

From 307e30b4f3f5682f0d5770f59454a66860b70e3c Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Thu, 6 Apr 2017 16:26:36 +0800
Subject: [PATCH 08/52] Backend: Fix flag and subflag seting for src 3
 instruction

Before gen8, src 3 instruction has different flag and subflag bits
V2: Fix the sub flag bit.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen75_encoder.cpp    | 10 ++++++++--
 backend/src/backend/gen7_encoder.cpp     | 10 ++++++++--
 backend/src/backend/gen7_instruction.hpp |  5 +++--
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/backend/src/backend/gen75_encoder.cpp b/backend/src/backend/gen75_encoder.cpp
index b82cc431..06cca3c9 100644
--- a/backend/src/backend/gen75_encoder.cpp
+++ b/backend/src/backend/gen75_encoder.cpp
@@ -53,8 +53,14 @@ namespace gbe
     gen7_insn->header.quarter_control = this->curr.quarterControl;
     gen7_insn->bits1.ia1.nib_ctrl = this->curr.nibControl;
     gen7_insn->header.mask_control = this->curr.noMask;
-    gen7_insn->bits2.ia1.flag_reg_nr = this->curr.flag;
-    gen7_insn->bits2.ia1.flag_sub_reg_nr = this->curr.subFlag;
+    if (insn->header.opcode == GEN_OPCODE_MAD || insn->header.opcode == GEN_OPCODE_LRP)
+    {
+      gen7_insn->bits1.da3src.flag_reg_nr = this->curr.flag;
+      gen7_insn->bits1.da3src.flag_sub_reg_nr = this->curr.subFlag;
+    } else {
+      gen7_insn->bits2.ia1.flag_reg_nr = this->curr.flag;
+      gen7_insn->bits2.ia1.flag_sub_reg_nr = this->curr.subFlag;
+    }
     if (this->curr.predicate != GEN_PREDICATE_NONE) {
       gen7_insn->header.predicate_control = this->curr.predicate;
       gen7_insn->header.predicate_inverse = this->curr.inversePredicate;
diff --git a/backend/src/backend/gen7_encoder.cpp b/backend/src/backend/gen7_encoder.cpp
index 4b2cd9ab..d526f5dd 100644
--- a/backend/src/backend/gen7_encoder.cpp
+++ b/backend/src/backend/gen7_encoder.cpp
@@ -46,8 +46,14 @@ namespace gbe
     gen7_insn->header.quarter_control = this->curr.quarterControl;
     gen7_insn->bits1.ia1.nib_ctrl = this->curr.nibControl;
     gen7_insn->header.mask_control = this->curr.noMask;
-    gen7_insn->bits2.ia1.flag_reg_nr = this->curr.flag;
-    gen7_insn->bits2.ia1.flag_sub_reg_nr = this->curr.subFlag;
+    if (insn->header.opcode == GEN_OPCODE_MAD || insn->header.opcode == GEN_OPCODE_LRP)
+    {
+      gen7_insn->bits1.da3src.flag_reg_nr = this->curr.flag;
+      gen7_insn->bits1.da3src.flag_sub_reg_nr = this->curr.subFlag;
+    } else {
+      gen7_insn->bits2.ia1.flag_reg_nr = this->curr.flag;
+      gen7_insn->bits2.ia1.flag_sub_reg_nr = this->curr.subFlag;
+    }
     if (this->curr.predicate != GEN_PREDICATE_NONE) {
       gen7_insn->header.predicate_control = this->curr.predicate;
       gen7_insn->header.predicate_inverse = this->curr.inversePredicate;
diff --git a/backend/src/backend/gen7_instruction.hpp b/backend/src/backend/gen7_instruction.hpp
index 7d7eadaa..c985fb81 100644
--- a/backend/src/backend/gen7_instruction.hpp
+++ b/backend/src/backend/gen7_instruction.hpp
@@ -142,8 +142,9 @@ union Gen7NativeInstruction
 
       struct {
         uint32_t dest_reg_file:1;
-        uint32_t flag_subreg_num:1;
-        uint32_t pad0:2;
+        uint32_t flag_sub_reg_nr:1;
+        uint32_t flag_reg_nr:1;
+        uint32_t pad0:1;
         uint32_t src0_abs:1;
         uint32_t src0_negate:1;
         uint32_t src1_abs:1;

From 7fd1ba5f9640560f4b3832895aa9a8170c1d056a Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 17 Mar 2017 14:15:58 +0800
Subject: [PATCH 09/52] Backend: Remove old llvm support code.

LLVM 3.3 or older is not supportted by Beignet now, and we need delete
these codes.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_program.cpp     |  6 ------
 backend/src/backend/program.cpp         | 30 ------------------------------
 backend/src/llvm/llvm_gen_backend.cpp   | 22 ----------------------
 backend/src/llvm/llvm_printf_parser.cpp |  6 ------
 backend/src/llvm/llvm_profiling.cpp     | 20 --------------------
 backend/src/llvm/llvm_scalarize.cpp     |  6 ------
 6 files changed, 90 deletions(-)

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index 073ede64..376342b8 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -24,15 +24,9 @@
 
 #ifdef GBE_COMPILER_AVAILABLE
 #include "llvm/Config/llvm-config.h"
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 2
-#include "llvm/LLVMContext.h"
-#include "llvm/Module.h"
-#include "llvm/DataLayout.h"
-#else
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/DataLayout.h"
-#endif  /* LLVM_VERSION_MINOR <= 2 */
 #include "llvm-c/Linker.h"
 #include "llvm/Transforms/Utils/Cloning.h"
 #include "llvm/Bitcode/ReaderWriter.h"
diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 8b8abc4d..6b5fce06 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -52,33 +52,16 @@
 #include <mutex>
 
 #ifdef GBE_COMPILER_AVAILABLE
-/* Not defined for LLVM 3.0 */
-#if !defined(LLVM_VERSION_MAJOR)
-#define LLVM_VERSION_MAJOR 3
-#endif /* !defined(LLVM_VERSION_MAJOR) */
-
-/* Not defined for LLVM 3.0 */
-#if !defined(LLVM_VERSION_MINOR)
-#define LLVM_VERSION_MINOR 0
-#endif /* !defined(LLVM_VERSION_MINOR) */
 
 #include <clang/CodeGen/CodeGenAction.h>
 #include <clang/Frontend/CompilerInstance.h>
 #include <clang/Frontend/CompilerInvocation.h>
-#if LLVM_VERSION_MINOR <= 1
-#include <clang/Frontend/DiagnosticOptions.h>
-#else
 #include <clang/Basic/DiagnosticOptions.h>
-#endif  /* LLVM_VERSION_MINOR <= 1 */
 #include <clang/Frontend/TextDiagnosticPrinter.h>
 #include <clang/Basic/TargetInfo.h>
 #include <clang/Basic/TargetOptions.h>
 #include <llvm/ADT/IntrusiveRefCntPtr.h>
-#if LLVM_VERSION_MINOR <= 2
-#include <llvm/Module.h>
-#else
 #include <llvm/IR/Module.h>
-#endif  /* LLVM_VERSION_MINOR <= 2 */
 #include <llvm/Bitcode/ReaderWriter.h>
 #include <llvm/Support/raw_ostream.h>
 #endif
@@ -686,10 +669,6 @@ namespace gbe {
     args.push_back("-disable-llvm-optzns");
     if(bFastMath)
       args.push_back("-D __FAST_RELAXED_MATH__=1");
-#if LLVM_VERSION_MINOR <= 2
-    args.push_back("-triple");
-    args.push_back("nvptx");
-#else
     args.push_back("-x");
     args.push_back("cl");
     args.push_back("-triple");
@@ -698,7 +677,6 @@ namespace gbe {
       args.push_back("-fblocks");
     } else
       args.push_back("spir");
-#endif /* LLVM_VERSION_MINOR <= 2 */
     args.push_back("stringInput.cl");
     args.push_back("-ffp-contract=on");
     if(OCL_DEBUGINFO) args.push_back("-g");
@@ -791,11 +769,7 @@ namespace gbe {
       std::string err;
       llvm::raw_fd_ostream ostream (dumpLLVMFileName.c_str(),
                                     err,
-      #if LLVM_VERSION_MINOR == 3
-                                    0
-      #else
                                     llvm::sys::fs::F_None
-      #endif
                                     );
 
       if (err.empty()) {
@@ -807,11 +781,7 @@ namespace gbe {
       std::string err;
       llvm::raw_fd_ostream ostream (dumpSPIRBinaryName.c_str(),
                                     err,
-      #if LLVM_VERSION_MINOR == 3
-                                    0
-      #else
                                     llvm::sys::fs::F_None
-      #endif
                                     );
       if (err.empty())
         llvm::WriteBitcodeToFile(*out_module, ostream);
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 3fefa926..9baf934d 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -745,9 +745,6 @@ namespace gbe
     void visitVAArgInst(VAArgInst &I) {NOT_SUPPORTED;}
     void visitSwitchInst(SwitchInst &I) {NOT_SUPPORTED;}
     void visitInvokeInst(InvokeInst &I) {NOT_SUPPORTED;}
-#if LLVM_VERSION_MINOR == 0
-    void visitUnwindInst(UnwindInst &I) {NOT_SUPPORTED;}
-#endif /* __LLVM_30__ */
     void visitResumeInst(ResumeInst &I) {NOT_SUPPORTED;}
     void visitInlineAsm(CallInst &I) {NOT_SUPPORTED;}
     void visitIndirectBrInst(IndirectBrInst &I) {NOT_SUPPORTED;}
@@ -1749,7 +1746,6 @@ namespace gbe
   {
     GBE_ASSERT(dyn_cast<ConstantExpr>(CPV) == NULL);
 
-#if LLVM_VERSION_MINOR > 0
     ConstantDataSequential *seq = dyn_cast<ConstantDataSequential>(CPV);
 
     if (seq) {
@@ -1772,7 +1768,6 @@ namespace gbe
         GBE_ASSERTM(0, "Const data array never be half float\n");
       }
     } else
-#endif /* LLVM_VERSION_MINOR > 0 */
 
     if (dyn_cast<ConstantAggregateZero>(CPV)) {
       Type* Ty = CPV->getType();
@@ -2343,9 +2338,6 @@ namespace gbe
       Function::arg_iterator I = F.arg_begin(), E = F.arg_end();
 
       // Insert a new register for each function argument
-#if LLVM_VERSION_MINOR <= 1
-      const AttrListPtr &PAL = F.getAttributes();
-#endif /* LLVM_VERSION_MINOR <= 1 */
       for (; I != E; ++I, ++argID) {
         uint32_t opID = argID;
 #if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR < 9
@@ -2435,11 +2427,7 @@ namespace gbe
             continue;
           Type *pointed = pointerType->getElementType();
           // By value structure
-#if LLVM_VERSION_MINOR <= 1
-          if (PAL.paramHasAttr(argID+1, Attribute::ByVal)) {
-#else
           if (I->hasByValAttr()) {
-#endif /* LLVM_VERSION_MINOR <= 1 */
             const size_t structSize = getTypeByteSize(unit, pointed);
             ctx.input(argName, ir::FunctionArgument::STRUCTURE, reg, llvmInfo, structSize, getAlignmentByte(unit, type), 0);
           }
@@ -3163,15 +3151,9 @@ namespace gbe
   void GenWriter::emitFunction(Function &F)
   {
     switch (F.getCallingConv()) {
-#if LLVM_VERSION_MINOR <= 2
-      case CallingConv::PTX_Device: // we do not emit device function
-        return;
-      case CallingConv::PTX_Kernel:
-#else
       case CallingConv::C:
       case CallingConv::Fast:
       case CallingConv::SPIR_KERNEL:
-#endif
         break;
       default:
         GBE_ASSERTM(false, "Unsupported calling convention");
@@ -3788,14 +3770,12 @@ namespace gbe
           break;
           case Intrinsic::stackrestore:
           break;
-#if LLVM_VERSION_MINOR >= 2
           case Intrinsic::lifetime_start:
           case Intrinsic::lifetime_end:
           break;
           case Intrinsic::fmuladd:
             this->newRegister(&I);
           break;
-#endif /* LLVM_VERSION_MINOR >= 2 */
           case Intrinsic::debugtrap:
           case Intrinsic::trap:
           case Intrinsic::dbg_value:
@@ -4549,11 +4529,9 @@ namespace gbe
             ctx.MOV(ir::getType(family), dst, src);
           }
           break;
-#if LLVM_VERSION_MINOR >= 2
           case Intrinsic::lifetime_start:
           case Intrinsic::lifetime_end:
           break;
-#endif /* LLVM_VERSION_MINOR >= 2 */
           case Intrinsic::debugtrap:
           case Intrinsic::trap:
           case Intrinsic::dbg_value:
diff --git a/backend/src/llvm/llvm_printf_parser.cpp b/backend/src/llvm/llvm_printf_parser.cpp
index 800f343f..d64fc60c 100644
--- a/backend/src/llvm/llvm_printf_parser.cpp
+++ b/backend/src/llvm/llvm_printf_parser.cpp
@@ -389,15 +389,9 @@ error:
   {
     bool hasPrintf = false;
     switch (F.getCallingConv()) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 2
-      case CallingConv::PTX_Device:
-        return false;
-      case CallingConv::PTX_Kernel:
-#else
       case CallingConv::C:
       case CallingConv::Fast:
       case CallingConv::SPIR_KERNEL:
-#endif
         break;
       default:
         GBE_ASSERTM(false, "Unsupported calling convention");
diff --git a/backend/src/llvm/llvm_profiling.cpp b/backend/src/llvm/llvm_profiling.cpp
index 96c95eeb..734c69d9 100644
--- a/backend/src/llvm/llvm_profiling.cpp
+++ b/backend/src/llvm/llvm_profiling.cpp
@@ -26,27 +26,13 @@
 #include <stdlib.h>
 
 #include "llvm/Config/llvm-config.h"
-#if LLVM_VERSION_MINOR <= 2
-#include "llvm/Function.h"
-#include "llvm/InstrTypes.h"
-#include "llvm/Instructions.h"
-#include "llvm/IntrinsicInst.h"
-#include "llvm/Module.h"
-#else
 #include "llvm/IR/Function.h"
 #include "llvm/IR/InstrTypes.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Module.h"
-#endif  /* LLVM_VERSION_MINOR <= 2 */
 #include "llvm/Pass.h"
-#if LLVM_VERSION_MINOR <= 1
-#include "llvm/Support/IRBuilder.h"
-#elif LLVM_VERSION_MINOR == 2
-#include "llvm/IRBuilder.h"
-#else
 #include "llvm/IR/IRBuilder.h"
-#endif /* LLVM_VERSION_MINOR <= 1 */
 
 #if LLVM_VERSION_MINOR >= 5
 #include "llvm/IR/CallSite.h"
@@ -111,15 +97,9 @@ namespace gbe
     int pointNum = 0;
 
     switch (F.getCallingConv()) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 2
-      case CallingConv::PTX_Device:
-        return false;
-      case CallingConv::PTX_Kernel:
-#else
       case CallingConv::C:
       case CallingConv::Fast:
       case CallingConv::SPIR_KERNEL:
-#endif
         break;
       default:
         GBE_ASSERTM(false, "Unsupported calling convention");
diff --git a/backend/src/llvm/llvm_scalarize.cpp b/backend/src/llvm/llvm_scalarize.cpp
index 8850abba..044a7e59 100644
--- a/backend/src/llvm/llvm_scalarize.cpp
+++ b/backend/src/llvm/llvm_scalarize.cpp
@@ -873,15 +873,9 @@ namespace gbe {
   bool Scalarize::runOnFunction(Function& F)
   {
     switch (F.getCallingConv()) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 2
-    case CallingConv::PTX_Device:
-      return false;
-    case CallingConv::PTX_Kernel:
-#else
     case CallingConv::C:
     case CallingConv::Fast:
     case CallingConv::SPIR_KERNEL:
-#endif
       break;
     default:
       GBE_ASSERTM(false, "Unsupported calling convention");

From e751015f2cc00885575545dbc4194ada903dcc88 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 17 Mar 2017 14:15:59 +0800
Subject: [PATCH 10/52] Backend: Fix an include file error problem

We should not include any llvm header in ir unit, and we need add
missing headers for proliling after deleting llvm headers.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/ir/profiling.cpp            | 1 +
 backend/src/ir/unit.hpp                 | 4 +---
 backend/src/llvm/llvm_gen_backend.cpp   | 2 +-
 backend/src/llvm/llvm_printf_parser.cpp | 2 +-
 4 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/backend/src/ir/profiling.cpp b/backend/src/ir/profiling.cpp
index ac61e9b2..3289e769 100644
--- a/backend/src/ir/profiling.cpp
+++ b/backend/src/ir/profiling.cpp
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 #include "ir/profiling.hpp"
 #include "src/cl_device_data.h"
+#include <inttypes.h>
 
 namespace gbe
 {
diff --git a/backend/src/ir/unit.hpp b/backend/src/ir/unit.hpp
index 46d7be79..d7a2a672 100644
--- a/backend/src/ir/unit.hpp
+++ b/backend/src/ir/unit.hpp
@@ -32,8 +32,6 @@
 #include "sys/map.hpp"
 #include <string.h>
 
-#include "llvm/IR/Instructions.h"
-
 namespace gbe {
 namespace ir {
 
@@ -46,7 +44,7 @@ namespace ir {
   public:
     typedef map<std::string, Function*> FunctionSet;
     /*! Moved from printf pass */
-    map<llvm::CallInst*, PrintfSet::PrintfFmt*> printfs;
+    map<void *, PrintfSet::PrintfFmt*> printfs;
     vector<std::string> blockFuncs;
     /*! Create an empty unit */
     Unit(PointerSize pointerSize = POINTER_32_BITS);
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 9baf934d..71a3174e 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -763,7 +763,7 @@ namespace gbe
     void emitUnalignedDQLoadStore(ir::Register ptr, Value *llvmValues, ir::AddressSpace addrSpace, ir::Register bti, bool isLoad, bool dwAligned, bool fixedBTI);
     void visitInstruction(Instruction &I) {NOT_SUPPORTED;}
     ir::PrintfSet::PrintfFmt* getPrintfInfo(CallInst* inst) {
-      if (unit.printfs.find(inst) == unit.printfs.end())
+      if (unit.printfs.find((void *)inst) == unit.printfs.end())
         return NULL;
       return unit.printfs[inst];
     }
diff --git a/backend/src/llvm/llvm_printf_parser.cpp b/backend/src/llvm/llvm_printf_parser.cpp
index d64fc60c..a1b1c2c9 100644
--- a/backend/src/llvm/llvm_printf_parser.cpp
+++ b/backend/src/llvm/llvm_printf_parser.cpp
@@ -381,7 +381,7 @@ error:
     }
 
     GBE_ASSERT(unit.printfs.find(call) == unit.printfs.end());
-    unit.printfs.insert(std::pair<llvm::CallInst*, PrintfSet::PrintfFmt*>(call, printf_fmt));
+    unit.printfs.insert(std::pair<void *, PrintfSet::PrintfFmt*>((void *)call, printf_fmt));
     return true;
   }
 

From 44ed14338262e2773d61c669b7bdfcb785780c86 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 17 Mar 2017 14:16:00 +0800
Subject: [PATCH 11/52] Backend: Refine GEP lowering code

Pointer is not as like as array or vector, we should handle it in a
standalone path to fit furture change about PointerType inheritance.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/llvm/llvm_gen_backend.cpp |  6 +++---
 backend/src/llvm/llvm_gen_backend.hpp |  5 ++++-
 backend/src/llvm/llvm_passes.cpp      | 35 +++++++++++++++++++++++------------
 3 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 71a3174e..493abb0f 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -1502,15 +1502,15 @@ namespace gbe
       Value *pointer = expr->getOperand(0);
       if (expr->getOpcode() == Instruction::GetElementPtr) {
         uint32_t constantOffset = 0;
-        CompositeType* CompTy = cast<CompositeType>(pointer->getType());
+        Type* EltTy = pointer->getType();
         for(uint32_t op=1; op<expr->getNumOperands(); ++op) {
             int32_t TypeIndex;
             ConstantInt* ConstOP = dyn_cast<ConstantInt>(expr->getOperand(op));
             GBE_ASSERTM(ConstOP != NULL, "must be constant index");
             TypeIndex = ConstOP->getZExtValue();
             GBE_ASSERT(TypeIndex >= 0);
-            constantOffset += getGEPConstOffset(unit, CompTy, TypeIndex);
-            CompTy = dyn_cast<CompositeType>(CompTy->getTypeAtIndex(TypeIndex));
+            constantOffset += getGEPConstOffset(unit, pointer->getType(), TypeIndex);
+            EltTy = getEltType(EltTy, TypeIndex);
         }
 
         ir::Constant cc = unit.getConstantSet().getConstant(pointer->getName());
diff --git a/backend/src/llvm/llvm_gen_backend.hpp b/backend/src/llvm/llvm_gen_backend.hpp
index ae486c5e..f1c791ea 100644
--- a/backend/src/llvm/llvm_gen_backend.hpp
+++ b/backend/src/llvm/llvm_gen_backend.hpp
@@ -118,7 +118,10 @@ namespace gbe
   uint32_t getTypeByteSize(const ir::Unit &unit, llvm::Type* Ty);
 
   /*! Get GEP constant offset for the specified operand.*/
-  int32_t getGEPConstOffset(const ir::Unit &unit, llvm::CompositeType *CompTy, int32_t TypeIndex);
+  int32_t getGEPConstOffset(const ir::Unit &unit, llvm::Type *eltTy, int32_t TypeIndex);
+
+  /*! Get element type for a type.*/
+  llvm::Type* getEltType(llvm::Type *eltTy, uint32_t index = 0);
 
   /*! whether this is a kernel function */
   bool isKernelFunction(const llvm::Function &f);
diff --git a/backend/src/llvm/llvm_passes.cpp b/backend/src/llvm/llvm_passes.cpp
index c5f3ffe4..8f5bcc9f 100644
--- a/backend/src/llvm/llvm_passes.cpp
+++ b/backend/src/llvm/llvm_passes.cpp
@@ -180,12 +180,23 @@ namespace gbe
     return size_bit/8;
   }
 
-  int32_t getGEPConstOffset(const ir::Unit &unit, CompositeType *CompTy, int32_t TypeIndex) {
+  Type* getEltType(Type* eltTy, uint32_t index) {
+    Type *elementType = NULL;
+    if (PointerType* ptrType = dyn_cast<PointerType>(eltTy))
+      elementType = ptrType->getElementType();
+    else if(SequentialType * seqType = dyn_cast<SequentialType>(eltTy))
+      elementType = seqType->getElementType();
+    else if(CompositeType * compTy= dyn_cast<CompositeType>(eltTy))
+      elementType = compTy->getTypeAtIndex(index);
+    GBE_ASSERT(elementType);
+    return elementType;
+  }
+
+  int32_t getGEPConstOffset(const ir::Unit &unit, Type *eltTy, int32_t TypeIndex) {
     int32_t offset = 0;
-    SequentialType * seqType = dyn_cast<SequentialType>(CompTy);
-    if (seqType != NULL) {
+    if (!eltTy->isStructTy()) {
       if (TypeIndex != 0) {
-        Type *elementType = seqType->getElementType();
+        Type *elementType = getEltType(eltTy);
         uint32_t elementSize = getTypeByteSize(unit, elementType);
         uint32_t align = getAlignmentByte(unit, elementType);
         elementSize += getPadding(elementSize, align);
@@ -193,17 +204,16 @@ namespace gbe
       }
     } else {
       int32_t step = TypeIndex > 0 ? 1 : -1;
-      GBE_ASSERT(CompTy->isStructTy());
       for(int32_t ty_i=0; ty_i != TypeIndex; ty_i += step)
       {
-        Type* elementType = CompTy->getTypeAtIndex(ty_i);
+        Type* elementType = getEltType(eltTy, ty_i);
         uint32_t align = getAlignmentByte(unit, elementType);
         offset += getPadding(offset, align * step);
         offset += getTypeByteSize(unit, elementType) * step;
       }
 
       //add getPaddingding for accessed type
-      const uint32_t align = getAlignmentByte(unit, CompTy->getTypeAtIndex(TypeIndex));
+      const uint32_t align = getAlignmentByte(unit, getEltType(eltTy ,TypeIndex));
       offset += getPadding(offset, align * step);
     }
     return offset;
@@ -247,8 +257,8 @@ namespace gbe
   {
     const uint32_t ptrSize = unit.getPointerSize();
     Value* parentPointer = GEPInst->getOperand(0);
-    CompositeType* CompTy = parentPointer ? cast<CompositeType>(parentPointer->getType()) : NULL;
-    if(!CompTy)
+    Type* eltTy = parentPointer ? parentPointer->getType() : NULL;
+    if(!eltTy)
       return false;
 
     Value* currentAddrInst = 
@@ -262,14 +272,15 @@ namespace gbe
       ConstantInt* ConstOP = dyn_cast<ConstantInt>(GEPInst->getOperand(op));
       if (ConstOP != NULL) {
         TypeIndex = ConstOP->getZExtValue();
-        constantOffset += getGEPConstOffset(unit, CompTy, TypeIndex);
+        constantOffset += getGEPConstOffset(unit, eltTy, TypeIndex);
       }
       else {
         // we only have array/vectors here, 
         // therefore all elements have the same size
         TypeIndex = 0;
 
-        Type* elementType = CompTy->getTypeAtIndex(TypeIndex);
+        Type* elementType = getEltType(eltTy);
+
         uint32_t size = getTypeByteSize(unit, elementType);
 
         //add padding
@@ -326,7 +337,7 @@ namespace gbe
       }
 
       //step down in type hirachy
-      CompTy = dyn_cast<CompositeType>(CompTy->getTypeAtIndex(TypeIndex));
+      eltTy = getEltType(eltTy, TypeIndex);
     }
 
     //insert addition of new offset before GEPInst when it is not zero

From 582973147927907531ff76f967138d98600e11b5 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 17 Mar 2017 14:16:01 +0800
Subject: [PATCH 12/52] Backend: Refine LLVM version check macro

LLVM 4.0 is coming, we should refine our version check to fit the
LLVM_MAJOR_VERSION bump to 4.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_program.cpp              | 12 ++---
 backend/src/backend/program.cpp                  | 16 +++---
 backend/src/ir/function.hpp                      |  2 +-
 backend/src/llvm/ExpandLargeIntegers.cpp         |  6 +--
 backend/src/llvm/llvm_bitcode_link.cpp           | 14 +++---
 backend/src/llvm/llvm_device_enqueue.cpp         | 10 ++--
 backend/src/llvm/llvm_gen_backend.cpp            | 38 +++++++-------
 backend/src/llvm/llvm_gen_backend.hpp            |  2 +-
 backend/src/llvm/llvm_includes.hpp               |  8 +--
 backend/src/llvm/llvm_loadstore_optimization.cpp |  6 +--
 backend/src/llvm/llvm_passes.cpp                 |  6 +--
 backend/src/llvm/llvm_profiling.cpp              |  2 +-
 backend/src/llvm/llvm_sampler_fix.cpp            |  2 +-
 backend/src/llvm/llvm_scalarize.cpp              |  2 +-
 backend/src/llvm/llvm_to_gen.cpp                 | 64 ++++++++++++------------
 backend/src/llvm/llvm_to_gen.hpp                 |  4 +-
 backend/src/llvm/llvm_unroll.cpp                 | 14 +++---
 17 files changed, 104 insertions(+), 104 deletions(-)

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index 376342b8..998e340f 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -329,13 +329,13 @@ namespace gbe {
     //the first byte stands for binary_type.
     binary_content.assign(binary+1, size-1);
     llvm::StringRef llvm_bin_str(binary_content);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     llvm::LLVMContext& c = GBEGetLLVMContext();
 #else
     llvm::LLVMContext& c = llvm::getGlobalContext();
 #endif
     llvm::SMDiagnostic Err;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
     std::unique_ptr<llvm::MemoryBuffer> memory_buffer = llvm::MemoryBuffer::getMemBuffer(llvm_bin_str, "llvm_bin_str");
     acquireLLVMContextLock();
     llvm::Module* module = llvm::parseIR(memory_buffer->getMemBufferRef(), Err, c).release();
@@ -482,14 +482,14 @@ namespace gbe {
     using namespace gbe;
     char* errMsg;
     if(((GenProgram*)dst_program)->module == NULL){
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
 #else
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module);
 #endif
       errSize = 0;
     }else{
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
       // Src now will be removed automatically. So clone it.
       llvm::Module* src = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
 #else
@@ -497,9 +497,9 @@ namespace gbe {
 #endif
       llvm::Module* dst = (llvm::Module*)((GenProgram*)dst_program)->module;
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
       if (LLVMLinkModules2(wrap(dst), wrap(src))) {
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
       if (LLVMLinkModules(wrap(dst), wrap(src), LLVMLinkerPreserveSource_Removed, &errMsg)) {
 #else
       if (LLVMLinkModules(wrap(dst), wrap(src), LLVMLinkerPreserveSource, &errMsg)) {
diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 6b5fce06..6e8227a6 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -115,7 +115,7 @@ namespace gbe {
     llvm::Module * cloned_module = NULL;
     bool ret = false;
     if(module){
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       cloned_module = llvm::CloneModule((llvm::Module*)module).release();
 #else
       cloned_module = llvm::CloneModule((llvm::Module*)module);
@@ -124,7 +124,7 @@ namespace gbe {
     bool strictMath = true;
     if (fast_relaxed_math || !OCL_STRICT_CONFORMANCE)
       strictMath = false;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     llvm::Module * linked_module = module ? llvm::CloneModule((llvm::Module*)module).release() : NULL;
     // Src now will be removed automatically. So clone it.
     if (llvmToGen(*unit, fileName, linked_module, optLevel, strictMath, OCL_PROFILING_LOG, error) == false) {
@@ -651,7 +651,7 @@ namespace gbe {
     // The ParseCommandLineOptions used for mllvm args can not be used with multithread
     // and GVN now have a 100 inst limit on block scan. Now only pass a bigger limit
     // for each context only once, this can also fix multithread bug.
-#if LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
     static bool ifsetllvm = false;
     if(!ifsetllvm) {
       args.push_back("-mllvm");
@@ -702,7 +702,7 @@ namespace gbe {
                                               Diags);
     llvm::StringRef srcString(source);
     (*CI).getPreprocessorOpts().addRemappedFile("stringInput.cl",
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
                 llvm::MemoryBuffer::getMemBuffer(srcString)
 #else
                 llvm::MemoryBuffer::getMemBuffer(srcString).release()
@@ -755,7 +755,7 @@ namespace gbe {
     if (!retVal)
       return false;
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
     llvm::Module *module = Act->takeModule();
 #else
     llvm::Module *module = Act->takeModule().release();
@@ -764,7 +764,7 @@ namespace gbe {
     *out_module = module;
 
 // Dump the LLVM if requested.
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 6)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 36
     if (!dumpLLVMFileName.empty()) {
       std::string err;
       llvm::raw_fd_ostream ostream (dumpLLVMFileName.c_str(),
@@ -1123,7 +1123,7 @@ EXTEND_QUOTE:
     //FIXME: if use new allocated context to link two modules there would be context mismatch
     //for some functions, so we use global context now, need switch to new context later.
     llvm::Module * out_module;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     llvm::LLVMContext* llvm_ctx = &GBEGetLLVMContext();
 #else
     llvm::LLVMContext* llvm_ctx = &llvm::getGlobalContext();
@@ -1599,7 +1599,7 @@ namespace gbe
     }
 
     ~CallBackInitializer() {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR > 3)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 34
       llvm::llvm_shutdown();
 #endif
     }
diff --git a/backend/src/ir/function.hpp b/backend/src/ir/function.hpp
index 5fcb14ac..64d9727b 100644
--- a/backend/src/ir/function.hpp
+++ b/backend/src/ir/function.hpp
@@ -186,7 +186,7 @@ namespace ir {
 
 
       // only llvm-3.6 or later has kernel_arg_base_type in metadata.
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR <= 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
       bool isImage1dT() const {
         return typeName.compare("image1d_t") == 0;
       }
diff --git a/backend/src/llvm/ExpandLargeIntegers.cpp b/backend/src/llvm/ExpandLargeIntegers.cpp
index 60740f5d..8515dc13 100644
--- a/backend/src/llvm/ExpandLargeIntegers.cpp
+++ b/backend/src/llvm/ExpandLargeIntegers.cpp
@@ -93,7 +93,7 @@
 
 using namespace llvm;
 
-#if LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
 #define DEBUG_TYPE "nacl-expand-ints"
 #endif
 
@@ -766,7 +766,7 @@ static void convertInstruction(Instruction *Inst, ConversionState &State,
 bool ExpandLargeIntegers::runOnFunction(Function &F) {
   // Don't support changing the function arguments. Illegal function arguments
   // should not be generated by clang.
-#if LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
   for (const Argument &Arg : F.args())
 #else
   for (const Argument &Arg : F.getArgumentList())
@@ -789,7 +789,7 @@ bool ExpandLargeIntegers::runOnFunction(Function &F) {
       // Only attempt to convert an instruction if its result or any of its
       // operands are illegal.
       bool ShouldConvert = shouldConvert(&I);
-#if LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
       for (Value *Op : I.operands())
         ShouldConvert |= shouldConvert(Op);
 #else
diff --git a/backend/src/llvm/llvm_bitcode_link.cpp b/backend/src/llvm/llvm_bitcode_link.cpp
index 89d5e7ce..869db89c 100644
--- a/backend/src/llvm/llvm_bitcode_link.cpp
+++ b/backend/src/llvm/llvm_bitcode_link.cpp
@@ -60,7 +60,7 @@ namespace gbe
       return NULL;
     }
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
     oclLib = getLazyIRFileModule(FilePath, Err, ctx);
 #else
     oclLib = getLazyIRFileModule(FilePath, Err, ctx).release();
@@ -117,7 +117,7 @@ namespace gbe
 
         std::string ErrInfo;// = "Not Materializable";
         if (!fromSrc && newMF->isMaterializable()) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
           if (newMF->Materialize(&ErrInfo)) {
             printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
             return false;
@@ -250,7 +250,7 @@ namespace gbe
       }
       std::string ErrInfo;// = "Not Materializable";
       if (newMF->isMaterializable()) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         if (newMF->Materialize(&ErrInfo)) {
           printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
           delete clonedLib;
@@ -287,7 +287,7 @@ namespace gbe
    * pass to extract the functions and values in Gvs from the library module.
    * After extract what we need and remove what we do not need, we use 
    * materializeAll to mark the module as materialized. */
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
     /* Get all GlobalValue from module. */
     Module::GlobalListType &GVlist = clonedLib->getGlobalList();
     for(Module::global_iterator GVitr = GVlist.begin();GVitr != GVlist.end();++GVitr) {
@@ -310,7 +310,7 @@ namespace gbe
     /* We use beignet's bitcode as dst because it will have a lot of
        lazy functions which will not be loaded. */
     char* errorMsg;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     if(LLVMLinkModules2(wrap(clonedLib), wrap(mod))) {
 #else
     if(LLVMLinkModules(wrap(clonedLib), wrap(mod), LLVMLinkerDestroySource, &errorMsg)) {
@@ -319,13 +319,13 @@ namespace gbe
       printf("Fatal Error: link the bitcode error:\n%s\n", errorMsg);
       return NULL;
     }
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     llvm::legacy::PassManager passes;
 #else
     llvm::PassManager passes;
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     auto PreserveKernel = [=](const GlobalValue &GV) {
       for(size_t i = 0;i < kernels.size(); ++i)
         if(strcmp(GV.getName().data(), kernels[i]))
diff --git a/backend/src/llvm/llvm_device_enqueue.cpp b/backend/src/llvm/llvm_device_enqueue.cpp
index ee236def..9a0fb46f 100644
--- a/backend/src/llvm/llvm_device_enqueue.cpp
+++ b/backend/src/llvm/llvm_device_enqueue.cpp
@@ -62,7 +62,7 @@ namespace gbe {
       for (Value::use_iterator iter = v->use_begin(); iter != v->use_end(); ++iter) {
         // After LLVM 3.5, use_iterator points to 'Use' instead of 'User',
         // which is more straightforward.
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
         User *theUser = *iter;
 #else
         User *theUser = iter->getUser();
@@ -84,7 +84,7 @@ namespace gbe {
 
   Function* setFunctionAsKernel(Module *mod, Function *Fn)
   {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 9)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     LLVMContext &Context = mod->getContext();
     Type *intTy = IntegerType::get(mod->getContext(), 32);
     SmallVector<llvm::Metadata *, 5> kernelMDArgs;
@@ -210,7 +210,7 @@ namespace gbe {
           }
 
           for (Value::use_iterator iter = bt->use_begin(); iter != bt->use_end(); ++iter) {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
             User *theUser = *iter;
 #else
             User *theUser = iter->getUser();
@@ -298,7 +298,7 @@ namespace gbe {
             if(AllocaInst *ai = dyn_cast<AllocaInst>(ld->getPointerOperand())) {
               Value *v = NULL;
               for (Value::use_iterator iter = ai->use_begin(); iter != ai->use_end(); ++iter) {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
                 User *theUser = *iter;
 #else
                 User *theUser = iter->getUser();
@@ -347,7 +347,7 @@ namespace gbe {
             if(ld) {
               Value *block = ld->getPointerOperand();
               for (Value::use_iterator iter = block->use_begin(); iter != block->use_end(); ++iter) {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
                 User *theUser = *iter;
 #else
                 User *theUser = iter->getUser();
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 493abb0f..25bff1ba 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -95,9 +95,9 @@
 #define LLVM_VERSION_MINOR 0
 #endif /* !defined(LLVM_VERSION_MINOR) */
 
-#if (LLVM_VERSION_MAJOR != 3) || (LLVM_VERSION_MINOR < 3)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 33
 #error "Only LLVM 3.3 and newer are supported"
-#endif /* (LLVM_VERSION_MAJOR != 3) || (LLVM_VERSION_MINOR > 4) */
+#endif
 
 using namespace llvm;
 
@@ -565,7 +565,7 @@ namespace gbe
         has_errors(false),
         legacyMode(true)
     {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
       initializeLoopInfoWrapperPassPass(*PassRegistry::getPassRegistry());
 #else
       initializeLoopInfoPass(*PassRegistry::getPassRegistry());
@@ -576,7 +576,7 @@ namespace gbe
     virtual const char *getPassName() const { return "Gen Back-End"; }
 
     void getAnalysisUsage(AnalysisUsage &AU) const {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
       AU.addRequired<LoopInfoWrapperPass>();
 #else
       AU.addRequired<LoopInfo>();
@@ -611,7 +611,7 @@ namespace gbe
       if (legacyMode)
         analyzePointerOrigin(F);
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
       LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
 #else
       LI = &getAnalysis<LoopInfo>();
@@ -834,7 +834,7 @@ namespace gbe
       for (Value::use_iterator iter = work->use_begin(); iter != work->use_end(); ++iter) {
       // After LLVM 3.5, use_iterator points to 'Use' instead of 'User',
       // which is more straightforward.
-  #if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+  #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
         User *theUser = *iter;
   #else
         User *theUser = iter->getUser();
@@ -1088,7 +1088,7 @@ namespace gbe
             if (predBB->getTerminator())
               Builder2.SetInsertPoint(predBB->getTerminator());
 
-#if (LLVM_VERSION_MAJOR== 3 && LLVM_VERSION_MINOR < 6)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 36
   // llvm 3.5 and older version don't have CreateBitOrPointerCast() define
             Type *srcTy = base->getType();
             Type *dstTy = ptr->getType();
@@ -1247,7 +1247,7 @@ namespace gbe
      uint32_t ops = clKernels->getNumOperands();
       for(uint32_t x = 0; x < ops; x++) {
         MDNode* node = clKernels->getOperand(x);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         Value * op = node->getOperand(0);
 #else
         auto *V = cast<ValueAsMetadata>(node->getOperand(0));
@@ -1271,7 +1271,7 @@ namespace gbe
     MDNode *typeNameNode = NULL;
     MDNode *typeBaseNameNode = NULL;
     MDNode *typeQualNode = NULL;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     typeNameNode = F.getMetadata("kernel_arg_type");
     typeBaseNameNode = F.getMetadata("kernel_arg_base_type");
     typeQualNode = F.getMetadata("kernel_arg_type_qual");
@@ -1297,7 +1297,7 @@ namespace gbe
     ir::FunctionArgument::InfoFromLLVM llvmInfo;
     for (Function::arg_iterator I = F.arg_begin(), E = F.arg_end(); I != E; ++I, argID++) {
       unsigned opID = argID;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR < 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 39
       opID += 1;
 #endif
 
@@ -1339,7 +1339,7 @@ namespace gbe
       for (Value::use_iterator iter = work->use_begin(); iter != work->use_end(); ++iter) {
       // After LLVM 3.5, use_iterator points to 'Use' instead of 'User',
       // which is more straightforward.
-  #if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+  #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
         User *theUser = *iter;
   #else
         User *theUser = iter->getUser();
@@ -2119,7 +2119,7 @@ namespace gbe
 
     std::string functionAttributes;
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     /* LLVM 3.9 change kernel arg info as function metadata */
     addrSpaceNode = F.getMetadata("kernel_arg_addr_space");
     accessQualNode = F.getMetadata("kernel_arg_access_qual");
@@ -2221,7 +2221,7 @@ namespace gbe
 
       if (attrName->getString() == "reqd_work_group_size") {
         GBE_ASSERT(attrNode->getNumOperands() == 4);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         ConstantInt *x = dyn_cast<ConstantInt>(attrNode->getOperand(1));
         ConstantInt *y = dyn_cast<ConstantInt>(attrNode->getOperand(2));
         ConstantInt *z = dyn_cast<ConstantInt>(attrNode->getOperand(3));
@@ -2263,13 +2263,13 @@ namespace gbe
       } else if (attrName->getString() == "vec_type_hint") {
         GBE_ASSERT(attrNode->getNumOperands() == 3);
         functionAttributes += attrName->getString();
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         Value* V = attrNode->getOperand(1);
 #else
         auto *Op1 = cast<ValueAsMetadata>(attrNode->getOperand(1));
         Value *V = Op1 ? Op1->getValue() : NULL;
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         ConstantInt *sign = dyn_cast<ConstantInt>(attrNode->getOperand(2));
 #else
         ConstantInt *sign = mdconst::extract<ConstantInt>(attrNode->getOperand(2));
@@ -2298,7 +2298,7 @@ namespace gbe
         functionAttributes += " ";
       } else if (attrName->getString() == "work_group_size_hint") {
         GBE_ASSERT(attrNode->getNumOperands() == 4);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         ConstantInt *x = dyn_cast<ConstantInt>(attrNode->getOperand(1));
         ConstantInt *y = dyn_cast<ConstantInt>(attrNode->getOperand(2));
         ConstantInt *z = dyn_cast<ConstantInt>(attrNode->getOperand(3));
@@ -2340,13 +2340,13 @@ namespace gbe
       // Insert a new register for each function argument
       for (; I != E; ++I, ++argID) {
         uint32_t opID = argID;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR < 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 39
         opID += 1;
 #endif
         const std::string &argName = I->getName().str();
         Type *type = I->getType();
         if(addrSpaceNode) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
           llvmInfo.addrSpace = (cast<ConstantInt>(addrSpaceNode->getOperand(opID)))->getZExtValue();
 #else
           llvmInfo.addrSpace = (mdconst::extract<ConstantInt>(addrSpaceNode->getOperand(opID)))->getZExtValue();
@@ -2913,7 +2913,7 @@ namespace gbe
     const Instruction *insn = NULL;
     for(Value::const_use_iterator iter = v->use_begin(); iter != v->use_end(); ++iter) {
     // After LLVM 3.5, use_iterator points to 'Use' instead of 'User', which is more straightforward.
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR < 35
       const User *theUser = *iter;
 #else
       const User *theUser = iter->getUser();
diff --git a/backend/src/llvm/llvm_gen_backend.hpp b/backend/src/llvm/llvm_gen_backend.hpp
index f1c791ea..2a322ac1 100644
--- a/backend/src/llvm/llvm_gen_backend.hpp
+++ b/backend/src/llvm/llvm_gen_backend.hpp
@@ -149,7 +149,7 @@ namespace gbe
   /*! Insert the time stamp for profiling. */
   llvm::FunctionPass* createProfilingInserterPass(int profilingType, ir::Unit &unit);
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
   /* customized loop unrolling pass. */
   llvm::LoopPass *createCustomLoopUnrollPass();
 #endif
diff --git a/backend/src/llvm/llvm_includes.hpp b/backend/src/llvm/llvm_includes.hpp
index 0b809797..a242fd34 100644
--- a/backend/src/llvm/llvm_includes.hpp
+++ b/backend/src/llvm/llvm_includes.hpp
@@ -91,7 +91,7 @@
 #include "llvm/MC/MCSubtargetInfo.h"
 #include "llvm/MC/MCSymbol.h"
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
 #include "llvm/IR/Mangler.h"
 #include "llvm/IR/CallSite.h"
 #include "llvm/IR/CFG.h"
@@ -111,7 +111,7 @@
 #include "llvm/Target/Mangler.h"
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/IR/LegacyPassManager.h"
 #else
@@ -122,12 +122,12 @@
 
 #include <clang/CodeGen/CodeGenAction.h>
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
 #include "llvm/Analysis/BasicAliasAnalysis.h"
 #include "llvm/Analysis/TypeBasedAliasAnalysis.h"
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
 #include "llvm/Transforms/IPO/FunctionAttrs.h"
 #include "llvm/Transforms/Scalar/GVN.h"
 #endif
diff --git a/backend/src/llvm/llvm_loadstore_optimization.cpp b/backend/src/llvm/llvm_loadstore_optimization.cpp
index e797e989..4f4639c0 100644
--- a/backend/src/llvm/llvm_loadstore_optimization.cpp
+++ b/backend/src/llvm/llvm_loadstore_optimization.cpp
@@ -35,7 +35,7 @@ namespace gbe {
     GenLoadStoreOptimization() : BasicBlockPass(ID) {}
 
     void getAnalysisUsage(AnalysisUsage &AU) const {
-#if LLVM_VERSION_MAJOR == 3 &&  LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       AU.addRequired<ScalarEvolutionWrapperPass>();
       AU.addPreserved<ScalarEvolutionWrapperPass>();
 #else
@@ -46,12 +46,12 @@ namespace gbe {
     }
 
     virtual bool runOnBasicBlock(BasicBlock &BB) {
-#if LLVM_VERSION_MAJOR == 3 &&  LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();
 #else
       SE = &getAnalysis<ScalarEvolution>();
 #endif
-      #if LLVM_VERSION_MINOR >= 7
+      #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
         TD = &BB.getModule()->getDataLayout();
       #elif LLVM_VERSION_MINOR >= 5
         DataLayoutPass *DLP = getAnalysisIfAvailable<DataLayoutPass>();
diff --git a/backend/src/llvm/llvm_passes.cpp b/backend/src/llvm/llvm_passes.cpp
index 8f5bcc9f..f414fbbd 100644
--- a/backend/src/llvm/llvm_passes.cpp
+++ b/backend/src/llvm/llvm_passes.cpp
@@ -42,7 +42,7 @@ namespace gbe
 {
   bool isKernelFunction(const llvm::Function &F) {
     bool bKernel = false;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     bKernel = F.getMetadata("kernel_arg_name") != NULL;
 #else
     const Module *module = F.getParent();
@@ -53,7 +53,7 @@ namespace gbe
       uint32_t ops = md.getNumOperands();
       for(uint32_t x = 0; x < ops; x++) {
         MDNode* node = md.getOperand(x);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
         Value * op = node->getOperand(0);
 #else
         Value * op = cast<ValueAsMetadata>(node->getOperand(0))->getValue();
@@ -74,7 +74,7 @@ namespace gbe
     if(ops > 0) {
       uint32_t major = 0, minor = 0;
       MDNode* node = version->getOperand(0);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
       major = mdconst::extract<ConstantInt>(node->getOperand(0))->getZExtValue();
       minor = mdconst::extract<ConstantInt>(node->getOperand(1))->getZExtValue();
 #else
diff --git a/backend/src/llvm/llvm_profiling.cpp b/backend/src/llvm/llvm_profiling.cpp
index 734c69d9..bc169516 100644
--- a/backend/src/llvm/llvm_profiling.cpp
+++ b/backend/src/llvm/llvm_profiling.cpp
@@ -34,7 +34,7 @@
 #include "llvm/Pass.h"
 #include "llvm/IR/IRBuilder.h"
 
-#if LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
 #include "llvm/IR/CallSite.h"
 #include "llvm/IR/CFG.h"
 #else
diff --git a/backend/src/llvm/llvm_sampler_fix.cpp b/backend/src/llvm/llvm_sampler_fix.cpp
index de7ebdbc..2e8bcf93 100644
--- a/backend/src/llvm/llvm_sampler_fix.cpp
+++ b/backend/src/llvm/llvm_sampler_fix.cpp
@@ -33,7 +33,7 @@ namespace gbe {
   class SamplerFix : public FunctionPass {
   public:
     SamplerFix() : FunctionPass(ID) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
       initializeDominatorTreeWrapperPassPass(*PassRegistry::getPassRegistry());
 #else
       initializeDominatorTreePass(*PassRegistry::getPassRegistry());
diff --git a/backend/src/llvm/llvm_scalarize.cpp b/backend/src/llvm/llvm_scalarize.cpp
index 044a7e59..e9a2a66f 100644
--- a/backend/src/llvm/llvm_scalarize.cpp
+++ b/backend/src/llvm/llvm_scalarize.cpp
@@ -96,7 +96,7 @@ namespace gbe {
 
     Scalarize() : FunctionPass(ID)
     {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
       initializeDominatorTreeWrapperPassPass(*PassRegistry::getPassRegistry());
 #else
       initializeDominatorTreePass(*PassRegistry::getPassRegistry());
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index bef4df1b..9b3b1f4e 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -46,14 +46,14 @@ namespace gbe
   BVAR(OCL_OUTPUT_CFG_GEN_IR, false);
   using namespace llvm;
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
   llvm::LLVMContext& GBEGetLLVMContext() {
     static llvm::LLVMContext GBEContext;
     return GBEContext;
   }
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
   #define TARGETLIBRARY  TargetLibraryInfoImpl
 #else
   #define TARGETLIBRARY  TargetLibraryInfo
@@ -61,32 +61,32 @@ namespace gbe
 
   void runFuntionPass(Module &mod, TARGETLIBRARY *libraryInfo, const DataLayout &DL)
   {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     legacy::FunctionPassManager FPM(&mod);
 #else
     FunctionPassManager FPM(&mod);
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
     FPM.add(new DataLayoutPass());
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR == 5
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR == 35
     FPM.add(new DataLayoutPass(DL));
 #else
     FPM.add(new DataLayout(DL));
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >=5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
     FPM.add(createVerifierPass(true));
 #else
     FPM.add(createVerifierPass());
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     FPM.add(new TargetLibraryInfoWrapperPass(*libraryInfo));
 #else
     FPM.add(new TargetLibraryInfo(*libraryInfo));
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
     FPM.add(createTypeBasedAAWrapperPass());
     FPM.add(createBasicAAWrapperPass());
 #else
@@ -108,27 +108,27 @@ namespace gbe
 
   void runModulePass(Module &mod, TARGETLIBRARY *libraryInfo, const DataLayout &DL, int optLevel, bool strictMath)
   {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     legacy::PassManager MPM;
 #else
     PassManager MPM;
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
     MPM.add(new DataLayoutPass());
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR == 5
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR == 35
     MPM.add(new DataLayoutPass(DL));
 #else
     MPM.add(new DataLayout(DL));
 #endif
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     MPM.add(new TargetLibraryInfoWrapperPass(*libraryInfo));
 #else
     MPM.add(new TargetLibraryInfo(*libraryInfo));
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
     MPM.add(createTypeBasedAAWrapperPass());
     MPM.add(createBasicAAWrapperPass());
 #else
@@ -149,9 +149,9 @@ namespace gbe
     MPM.add(createInstructionCombiningPass());// Clean up after IPCP & DAE
     MPM.add(createCFGSimplificationPass());   // Clean up after IPCP & DAE
     MPM.add(createPruneEHPass());             // Remove dead EH info
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     MPM.add(createPostOrderFunctionAttrsLegacyPass());
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
     MPM.add(createPostOrderFunctionAttrsPass());       // Set readonly/readnone attrs
 #else
     MPM.add(createFunctionAttrsPass());       // Set readonly/readnone attrs
@@ -159,7 +159,7 @@ namespace gbe
 
     //MPM.add(createScalarReplAggregatesPass(64, true, -1, -1, 64))
     if(optLevel > 0)
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       MPM.add(createSROAPass());
 #else
       MPM.add(createSROAPass(/*RequiresDomTree*/ false));
@@ -182,14 +182,14 @@ namespace gbe
     MPM.add(createLoopDeletionPass());          // Delete dead loops
     MPM.add(createLoopUnrollPass(640)); //1024, 32, 1024, 512)); //Unroll loops
     if(optLevel > 0) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       MPM.add(createSROAPass());
 #else
       MPM.add(createSROAPass(/*RequiresDomTree*/ false));
 #endif
       MPM.add(createGVNPass());                 // Remove redundancies
     }
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
     // FIXME Workaround: we find that CustomLoopUnroll may increase register pressure greatly,
     // and it may even make som cl kernel cannot compile because of limited scratch memory for spill.
     // As we observe this under strict math. So we disable CustomLoopUnroll if strict math is enabled.
@@ -199,7 +199,7 @@ namespace gbe
 #endif
       MPM.add(createLoopUnrollPass()); //1024, 32, 1024, 512)); //Unroll loops
       if(optLevel > 0) {
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
         MPM.add(createSROAPass());
 #else
         MPM.add(createSROAPass(/*RequiresDomTree*/ false));
@@ -230,7 +230,7 @@ namespace gbe
   }
 
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
 #define OUTPUT_BITCODE(STAGE, MOD)  do {         \
   legacy::PassManager passes__;           \
    if (OCL_OUTPUT_LLVM_##STAGE) {                \
@@ -238,7 +238,7 @@ namespace gbe
      passes__.run(MOD);                          \
    }                                             \
  }while(0)
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
 #define OUTPUT_BITCODE(STAGE, MOD)  do {         \
    PassManager passes__;           \
    if (OCL_OUTPUT_LLVM_##STAGE) {                \
@@ -303,12 +303,12 @@ namespace gbe
     if (module) {
       cl_mod = reinterpret_cast<Module*>(const_cast<void*>(module));
     } else if (fileName){
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
       llvm::LLVMContext& c = GBEGetLLVMContext();
 #else
       llvm::LLVMContext& c = llvm::getGlobalContext();
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
       cl_mod = parseIRFile(fileName, Err, c).release();
 #else
       cl_mod = ParseIRFile(fileName, Err, c);
@@ -318,7 +318,7 @@ namespace gbe
     if (!cl_mod) return false;
 
     OUTPUT_BITCODE(BEFORE_LINK, (*cl_mod));
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     legacy::PassManager passes__;
 #else
     PassManager passes__;
@@ -346,7 +346,7 @@ namespace gbe
     gbeDiagnosticContext dc;
     mod.getContext().setDiagnosticHandler(&gbeDiagnosticHandler,&dc);
 
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     mod.setDataLayout(DL);
 #endif
     Triple TargetTriple(mod.getTargetTriple());
@@ -357,15 +357,15 @@ namespace gbe
 
     runFuntionPass(mod, libraryInfo, DL);
     runModulePass(mod, libraryInfo, DL, optLevel, strictMath);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     legacy::PassManager passes;
 #else
     PassManager passes;
 #endif
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
     passes.add(new DataLayoutPass());
-#elif LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR == 5
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR == 35
     passes.add(new DataLayoutPass(DL));
 #else
     passes.add(new DataLayout(DL));
@@ -374,7 +374,7 @@ namespace gbe
     passes.add(createIntrinsicLoweringPass());
     passes.add(createStripAttributesPass());     // Strip unsupported attributes and calling conventions.
     passes.add(createFunctionInliningPass(20000));
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 7
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     passes.add(createSROAPass());
 #else
     passes.add(createScalarReplAggregatesPass(64, true, -1, -1, 64));
diff --git a/backend/src/llvm/llvm_to_gen.hpp b/backend/src/llvm/llvm_to_gen.hpp
index d3928c6b..90258521 100644
--- a/backend/src/llvm/llvm_to_gen.hpp
+++ b/backend/src/llvm/llvm_to_gen.hpp
@@ -23,7 +23,7 @@
  */
 #ifndef __GBE_IR_LLVM_TO_GEN_HPP__
 #define __GBE_IR_LLVM_TO_GEN_HPP__
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
 #include "llvm/IR/LLVMContext.h"
 #endif
 
@@ -37,7 +37,7 @@ namespace gbe {
 		  optLevel 0 equal to clang -O1 and 1 equal to clang -O2*/
   bool llvmToGen(ir::Unit &unit, const char *fileName, const void* module,
                  int optLevel, bool strictMath, int profiling, std::string &errors);
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 9
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
   extern llvm::LLVMContext& GBEGetLLVMContext();
 #endif
 
diff --git a/backend/src/llvm/llvm_unroll.cpp b/backend/src/llvm/llvm_unroll.cpp
index e24dc4fa..bfd3bbe3 100644
--- a/backend/src/llvm/llvm_unroll.cpp
+++ b/backend/src/llvm/llvm_unroll.cpp
@@ -16,7 +16,7 @@
  */
 
 #include "llvm/Config/llvm-config.h"
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
 #include <set>
 
 #include "llvm_includes.hpp"
@@ -36,7 +36,7 @@ namespace gbe {
        LoopPass(ID) {}
 
       void getAnalysisUsage(AnalysisUsage &AU) const {
-#if (LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR >= 7)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
         AU.addRequired<LoopInfoWrapperPass>();
         AU.addPreserved<LoopInfoWrapperPass>();
 #else
@@ -47,7 +47,7 @@ namespace gbe {
         AU.addPreservedID(LoopSimplifyID);
         AU.addRequiredID(LCSSAID);
         AU.addPreservedID(LCSSAID);
-#if LLVM_VERSION_MAJOR == 3 &&  LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
         AU.addRequired<ScalarEvolutionWrapperPass>();
         AU.addPreserved<ScalarEvolutionWrapperPass>();
 #else
@@ -91,7 +91,7 @@ namespace gbe {
           assert(MD->getNumOperands() == 2 &&
                  "Unroll count hint metadata should have two operands.");
           unsigned Count;
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
           Count = mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();
 #else
           Count = cast<ConstantInt>(MD->getOperand(1))->getZExtValue();
@@ -105,7 +105,7 @@ namespace gbe {
       void setUnrollID(Loop *L, bool enable) {
         assert(enable);
         LLVMContext &Context = L->getHeader()->getContext();
-#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 6
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
         SmallVector<Metadata *, 2> forceUnroll;
         forceUnroll.push_back(MDString::get(Context, "llvm.loop.unroll.enable"));
         MDNode *forceUnrollNode = MDNode::get(Context, forceUnroll);
@@ -169,7 +169,7 @@ namespace gbe {
       // be unrolled.
       bool handleParentLoops(Loop *L, LPPassManager &LPM) {
         Loop *currL = L;
-#if LLVM_VERSION_MAJOR == 3 &&  LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
         ScalarEvolution *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();
         LoopInfo &loopInfo = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
 #else
@@ -205,7 +205,7 @@ namespace gbe {
           if (parentTripCount != 0 && currTripCount * parentTripCount > 32) {
             //Don't change the unrollID if doesn't force unroll.
             //setUnrollID(parentL, false);
-#if LLVM_VERSION_MAJOR == 3 &&  LLVM_VERSION_MINOR >= 8
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
             loopInfo.markAsRemoved(parentL);
 #else
             LPM.deleteLoopFromQueue(parentL);

From 3bf04bedd04ad67fb32fdb145bf885f6e933565a Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 17 Mar 2017 14:16:02 +0800
Subject: [PATCH 13/52] Backend: Refine FCmp one and une

llvm will merge:

%1 = fcmp olt %a, %b
%2 = fcmp ogt %a, %b
%dst = or %1, %2

into
%dst = fcmp one %a, %b
And own CMP.NE is actually une so refine Fcmp one into CMP.LT and CMP.GT
and OR

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/llvm/llvm_gen_backend.cpp | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 25bff1ba..42d9c7b0 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -3383,11 +3383,12 @@ namespace gbe
     const ir::Register src0 = this->getRegister(I.getOperand(0));
     const ir::Register src1 = this->getRegister(I.getOperand(1));
     const ir::Register tmp = ctx.reg(getFamily(ctx, I.getType()));
+    const ir::Register tmp1 = ctx.reg(getFamily(ctx, I.getType()));
     Value *cv = ConstantInt::get(I.getType(), 1);
 
     switch (I.getPredicate()) {
       case ICmpInst::FCMP_OEQ: ctx.EQ(type, dst, src0, src1); break;
-      case ICmpInst::FCMP_ONE: ctx.NE(type, dst, src0, src1); break;
+      case ICmpInst::FCMP_UNE: ctx.NE(type, dst, src0, src1); break;
       case ICmpInst::FCMP_OLE: ctx.LE(type, dst, src0, src1); break;
       case ICmpInst::FCMP_OGE: ctx.GE(type, dst, src0, src1); break;
       case ICmpInst::FCMP_OLT: ctx.LT(type, dst, src0, src1); break;
@@ -3433,9 +3434,10 @@ namespace gbe
         ctx.GT(type, tmp, src0, src1);
         ctx.XOR(insnType, dst, tmp, getRegister(cv));
         break;
-      case ICmpInst::FCMP_UNE:
-        ctx.EQ(type, tmp, src0, src1);
-        ctx.XOR(insnType, dst, tmp, getRegister(cv));
+      case ICmpInst::FCMP_ONE:
+        ctx.LT(type, tmp, src0, src1);
+        ctx.GT(type, tmp1, src0, src1);
+        ctx.OR(insnType, dst, tmp, tmp1);
         break;
       case ICmpInst::FCMP_TRUE:
         ctx.MOV(insnType, dst, getRegister(cv));

From 29a2def1e8ff6306bd510f5d4f98f85056cfc06c Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Thu, 13 Apr 2017 19:32:51 +0800
Subject: [PATCH 14/52] utest: fix image qualifier of compiler_fill_gl_image
 test.

After clang check the image qualifier, can't use default qualifier
to write_image.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 kernels/test_fill_gl_image.cl | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/kernels/test_fill_gl_image.cl b/kernels/test_fill_gl_image.cl
index 4250a571..7b5dce78 100644
--- a/kernels/test_fill_gl_image.cl
+++ b/kernels/test_fill_gl_image.cl
@@ -1,5 +1,5 @@
 __kernel void
-test_fill_gl_image(image2d_t img, int color)
+test_fill_gl_image(write_only image2d_t img, int color)
 {
 	int2 coord;
         float4 color_v4;

From ab9166cda203fc9f9244a6210186f37612b8c68f Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Tue, 11 Apr 2017 15:59:50 +0800
Subject: [PATCH 15/52] Backend: Add LLVM40 support

1.Refine APFloat fltSemantics.
2.Refine bitcode read/write header.
3.Refine clang invocation.
4.Refine return llvm::error handler.
5.Refine ilist_iterator usage.
6.Refine CFG Printer pass manager.
7.Refine GEP with pointer type changing.
8.Refine libocl 20 support
V2: Add missing ocl_sampler.ll and ocl_sampler_20.ll file
V3: Fix some build problem for llvm36

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_program.cpp              |  4 ++
 backend/src/backend/program.cpp                  | 25 ++++++++---
 backend/src/ir/half.cpp                          | 20 +++++++++
 backend/src/libocl/CMakeLists.txt                |  4 +-
 backend/src/libocl/include/ocl_enqueue.h         |  6 +--
 backend/src/libocl/src/ocl_image.cl              |  9 ++--
 backend/src/libocl/src/ocl_sampler.ll            | 10 +++++
 backend/src/libocl/src/ocl_sampler_20.ll         | 10 +++++
 backend/src/llvm/ExpandUtils.cpp                 |  4 ++
 backend/src/llvm/llvm_barrier_nodup.cpp          |  7 ++-
 backend/src/llvm/llvm_bitcode_link.cpp           | 54 ++++++++++++++++++------
 backend/src/llvm/llvm_gen_backend.cpp            | 36 +++++++++++++++-
 backend/src/llvm/llvm_gen_ocl_function.hxx       |  4 ++
 backend/src/llvm/llvm_includes.hpp               | 12 ++++++
 backend/src/llvm/llvm_intrinsic_lowering.cpp     |  7 ++-
 backend/src/llvm/llvm_loadstore_optimization.cpp |  8 +++-
 backend/src/llvm/llvm_passes.cpp                 |  4 ++
 backend/src/llvm/llvm_printf_parser.cpp          |  8 ++++
 backend/src/llvm/llvm_profiling.cpp              |  4 ++
 backend/src/llvm/llvm_to_gen.cpp                 |  8 ++++
 backend/src/llvm/llvm_unroll.cpp                 |  7 ++-
 21 files changed, 217 insertions(+), 34 deletions(-)
 create mode 100644 backend/src/libocl/src/ocl_sampler.ll
 create mode 100644 backend/src/libocl/src/ocl_sampler_20.ll

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index 998e340f..c1827b11 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -29,7 +29,11 @@
 #include "llvm/IR/DataLayout.h"
 #include "llvm-c/Linker.h"
 #include "llvm/Transforms/Utils/Cloning.h"
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+#include "llvm/Bitcode/BitcodeWriter.h"
+#else
 #include "llvm/Bitcode/ReaderWriter.h"
+#endif /* LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40 */
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/MemoryBuffer.h"
diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 6e8227a6..724058c6 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -62,7 +62,13 @@
 #include <clang/Basic/TargetOptions.h>
 #include <llvm/ADT/IntrusiveRefCntPtr.h>
 #include <llvm/IR/Module.h>
+
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+#include <llvm/Bitcode/BitcodeWriter.h>
+#include <clang/Lex/PreprocessorOptions.h>
+#else
 #include <llvm/Bitcode/ReaderWriter.h>
+#endif
 #include <llvm/Support/raw_ostream.h>
 #endif
 
@@ -694,14 +700,15 @@ namespace gbe {
     llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
     clang::DiagnosticsEngine Diags(DiagID, &*DiagOpts, DiagClient);
 
+    llvm::StringRef srcString(source);
     // Create the compiler invocation
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    auto CI = std::make_shared<clang::CompilerInvocation>();
+    CI->getPreprocessorOpts().addRemappedFile("stringInput.cl",
+#else
     std::unique_ptr<clang::CompilerInvocation> CI(new clang::CompilerInvocation);
-    clang::CompilerInvocation::CreateFromArgs(*CI,
-                                              &args[0],
-                                              &args[0] + args.size(),
-                                              Diags);
-    llvm::StringRef srcString(source);
     (*CI).getPreprocessorOpts().addRemappedFile("stringInput.cl",
+#endif
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
                 llvm::MemoryBuffer::getMemBuffer(srcString)
 #else
@@ -709,9 +716,17 @@ namespace gbe {
 #endif
                 );
 
+    clang::CompilerInvocation::CreateFromArgs(*CI,
+                                              &args[0],
+                                              &args[0] + args.size(),
+                                              Diags);
     // Create the compiler instance
     clang::CompilerInstance Clang;
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    Clang.setInvocation(std::move(CI));
+#else
     Clang.setInvocation(CI.release());
+#endif
     // Get ready to report problems
     Clang.createDiagnostics(DiagClient, false);
 
diff --git a/backend/src/ir/half.cpp b/backend/src/ir/half.cpp
index 1c0d7eb9..0abc6cb3 100644
--- a/backend/src/ir/half.cpp
+++ b/backend/src/ir/half.cpp
@@ -29,7 +29,11 @@ namespace ir {
   {
     uint64_t v64 = static_cast<uint64_t>(v);
     llvm::APInt apInt(16, v64, false);
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    return llvm::APFloat(llvm::APFloat::IEEEhalf(), apInt);
+#else
     return llvm::APFloat(llvm::APFloat::IEEEhalf, apInt);
+#endif
   }
 
   static uint16_t convAPFloatToU16(const llvm::APFloat& apf)
@@ -42,14 +46,22 @@ namespace ir {
   half::operator float(void) const {
     bool loseInfo;
     llvm::APFloat apf_self = convU16ToAPFloat(this->val);
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    apf_self.convert(llvm::APFloat::IEEEsingle(), llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+#else
     apf_self.convert(llvm::APFloat::IEEEsingle, llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+#endif
     return apf_self.convertToFloat();
   }
 
   half::operator double(void) const {
     bool loseInfo;
     llvm::APFloat apf_self = convU16ToAPFloat(this->val);
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    apf_self.convert(llvm::APFloat::IEEEdouble(), llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+#else
     apf_self.convert(llvm::APFloat::IEEEdouble, llvm::APFloat::rmNearestTiesToEven, &loseInfo);
+#endif
     return apf_self.convertToDouble();
   }
 
@@ -70,7 +82,11 @@ namespace ir {
   }
 
   half half::convToHalf(uint16_t u16) {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    llvm::APFloat res(llvm::APFloat::IEEEhalf(), llvm::APInt(16, 0, false));
+#else
     llvm::APFloat res(llvm::APFloat::IEEEhalf, llvm::APInt(16, 0, false));
+#endif
     uint64_t u64 = static_cast<uint64_t>(u16);
     llvm::APInt apInt(16, u64, false);
     res.convertFromAPInt(apInt, false, llvm::APFloat::rmNearestTiesToEven);
@@ -78,7 +94,11 @@ namespace ir {
   }
 
   half half::convToHalf(int16_t v16) {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    llvm::APFloat res(llvm::APFloat::IEEEhalf(), llvm::APInt(16, 0, true));
+#else
     llvm::APFloat res(llvm::APFloat::IEEEhalf, llvm::APInt(16, 0, true));
+#endif
     uint64_t u64 = static_cast<uint64_t>(v16);
     llvm::APInt apInt(16, u64, true);
     res.convertFromAPInt(apInt, true, llvm::APFloat::rmNearestTiesToEven);
diff --git a/backend/src/libocl/CMakeLists.txt b/backend/src/libocl/CMakeLists.txt
index c68ecb01..2917e6d2 100644
--- a/backend/src/libocl/CMakeLists.txt
+++ b/backend/src/libocl/CMakeLists.txt
@@ -211,7 +211,7 @@ MACRO(ADD_LL_TO_BC_TARGET M)
 	)
 ENDMACRO(ADD_LL_TO_BC_TARGET)
 
-SET (OCL_LL_MODULES_12 ocl_barrier ocl_clz ocl_ctz)
+SET (OCL_LL_MODULES_12 ocl_barrier ocl_clz ocl_ctz ocl_sampler)
 FOREACH(f ${OCL_LL_MODULES_12})
     COPY_THE_LL(${f})
     ADD_LL_TO_BC_TARGET(${f})
@@ -255,7 +255,7 @@ if (ENABLE_OPENCL_20)
     ADD_CL_TO_BC_TARGET(${f} ${bc_name} "${CLANG_OCL_FLAGS_20}")
   ENDFOREACH(f)
 
-  SET (OCL_LL_MODULES_20 ocl_barrier_20 ocl_clz_20 ocl_ctz_20 ocl_atomic_20)
+  SET (OCL_LL_MODULES_20 ocl_barrier_20 ocl_clz_20 ocl_ctz_20 ocl_atomic_20 ocl_sampler_20)
   FOREACH(f ${OCL_LL_MODULES_20})
     COPY_THE_LL(${f})
     ADD_LL_TO_BC_TARGET(${f})
diff --git a/backend/src/libocl/include/ocl_enqueue.h b/backend/src/libocl/include/ocl_enqueue.h
index 6479df71..7ccab59f 100644
--- a/backend/src/libocl/include/ocl_enqueue.h
+++ b/backend/src/libocl/include/ocl_enqueue.h
@@ -38,7 +38,7 @@ struct Block_literal {
   void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock
   int flags;
   int reserved;
-  __global void (*invoke)(void *, ...);
+  __global void* invoke;
   struct Block_descriptor_1 {
     unsigned long int reserved;         // NULL
     unsigned long int size;         // sizeof(struct Block_literal_1)
@@ -65,10 +65,6 @@ OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^b
 OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange,
                                 uint num_events_in_wait_list, const clk_event_t *event_wait_list,
                                 clk_event_t *event_ret, void (^block)(void));
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, __private void *block, uint size0, ...);
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange,
-                                uint num_events_in_wait_list, const clk_event_t *event_wait_list,
-                                clk_event_t *event_ret,  __private void *block, uint size0, ...);
 
 queue_t get_default_queue(void);
 int __gen_enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^block)(void), int size);
diff --git a/backend/src/libocl/src/ocl_image.cl b/backend/src/libocl/src/ocl_image.cl
index 2febfdac..e66aa155 100644
--- a/backend/src/libocl/src/ocl_image.cl
+++ b/backend/src/libocl/src/ocl_image.cl
@@ -295,17 +295,18 @@ GEN_VALIDATE_ARRAY_INDEX(int, read_write image1d_buffer_t)
 // The work around is to use a LD message instead of normal sample message.
 ///////////////////////////////////////////////////////////////////////////////
 
-bool __gen_ocl_sampler_need_fix(sampler_t);
-bool __gen_ocl_sampler_need_rounding_fix(sampler_t);
+bool __gen_ocl_sampler_need_fix(int);
+bool __gen_ocl_sampler_need_rounding_fix(int);
+int __gen_ocl_sampler_to_int(sampler_t);
 
 bool __gen_sampler_need_fix(const sampler_t sampler)
 {
-  return __gen_ocl_sampler_need_fix(sampler);
+  return __gen_ocl_sampler_need_fix(__gen_ocl_sampler_to_int(sampler));
 }
 
 bool __gen_sampler_need_rounding_fix(const sampler_t sampler)
 {
-  return __gen_ocl_sampler_need_rounding_fix(sampler);
+  return __gen_ocl_sampler_need_rounding_fix(__gen_ocl_sampler_to_int(sampler));
 }
 
 INLINE_OVERLOADABLE float __gen_fixup_float_coord(float tmpCoord)
diff --git a/backend/src/libocl/src/ocl_sampler.ll b/backend/src/libocl/src/ocl_sampler.ll
new file mode 100644
index 00000000..6d39fdb2
--- /dev/null
+++ b/backend/src/libocl/src/ocl_sampler.ll
@@ -0,0 +1,10 @@
+target datalayout = "e-p:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
+target triple = "spir"
+%opencl.sampler_t = type opaque
+
+declare %opencl.sampler_t addrspace(2)*@__gen_ocl_int_to_sampler(i32)
+
+define %opencl.sampler_t addrspace(2)*@__translate_sampler_initializer(i32 %s) {
+  %call = call %opencl.sampler_t addrspace(2)*@__gen_ocl_int_to_sampler(i32 %s)
+  ret %opencl.sampler_t addrspace(2)* %call
+}
diff --git a/backend/src/libocl/src/ocl_sampler_20.ll b/backend/src/libocl/src/ocl_sampler_20.ll
new file mode 100644
index 00000000..bea6d755
--- /dev/null
+++ b/backend/src/libocl/src/ocl_sampler_20.ll
@@ -0,0 +1,10 @@
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
+target triple = "spir64"
+%opencl.sampler_t = type opaque
+
+declare %opencl.sampler_t addrspace(2)*@__gen_ocl_int_to_sampler(i32)
+
+define %opencl.sampler_t addrspace(2)*@__translate_sampler_initializer(i32 %s) {
+  %call = call %opencl.sampler_t addrspace(2)*@__gen_ocl_int_to_sampler(i32 %s)
+  ret %opencl.sampler_t addrspace(2)* %call
+}
diff --git a/backend/src/llvm/ExpandUtils.cpp b/backend/src/llvm/ExpandUtils.cpp
index a09d9908..cb1736b7 100644
--- a/backend/src/llvm/ExpandUtils.cpp
+++ b/backend/src/llvm/ExpandUtils.cpp
@@ -101,7 +101,11 @@ namespace llvm {
   Function *RecreateFunction(Function *Func, FunctionType *NewType) {
     Function *NewFunc = Function::Create(NewType, Func->getLinkage());
     NewFunc->copyAttributesFrom(Func);
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    Func->getParent()->getFunctionList().insert(Func->getIterator(), NewFunc);
+#else
     Func->getParent()->getFunctionList().insert(ilist_iterator<Function>(Func), NewFunc);
+#endif
     NewFunc->takeName(Func);
     NewFunc->getBasicBlockList().splice(NewFunc->begin(),
                                         Func->getBasicBlockList());
diff --git a/backend/src/llvm/llvm_barrier_nodup.cpp b/backend/src/llvm/llvm_barrier_nodup.cpp
index 727e6bd2..a7d0d1ad 100644
--- a/backend/src/llvm/llvm_barrier_nodup.cpp
+++ b/backend/src/llvm/llvm_barrier_nodup.cpp
@@ -48,7 +48,12 @@ namespace gbe {
 
       }
 
-      virtual const char *getPassName() const {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      virtual StringRef getPassName() const
+#else
+      virtual const char *getPassName() const
+#endif
+      {
         return "SPIR backend: set barrier no duplicate attr";
       }
 
diff --git a/backend/src/llvm/llvm_bitcode_link.cpp b/backend/src/llvm/llvm_bitcode_link.cpp
index 869db89c..5c6585d0 100644
--- a/backend/src/llvm/llvm_bitcode_link.cpp
+++ b/backend/src/llvm/llvm_bitcode_link.cpp
@@ -117,17 +117,28 @@ namespace gbe
 
         std::string ErrInfo;// = "Not Materializable";
         if (!fromSrc && newMF->isMaterializable()) {
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
-          if (newMF->Materialize(&ErrInfo)) {
-            printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+          if (llvm::Error EC = newMF->materialize()) {
+            std::string Msg;
+            handleAllErrors(std::move(EC), [&](ErrorInfoBase &EIB) {
+              Msg = EIB.message();
+            });
+            printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), Msg.c_str());
             return false;
           }
-#else
+          Gvs.push_back((GlobalValue *)newMF);
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
           if (std::error_code EC = newMF->materialize()) {
             printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), EC.message().c_str());
             return false;
           }
           Gvs.push_back((GlobalValue *)newMF);
+#else
+         if (newMF->Materialize(&ErrInfo)) {
+            printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
+            return false;
+          }
+
 #endif
         }
         if (!materializedFuncCall(src, lib, *newMF, MFS, Gvs))
@@ -250,21 +261,30 @@ namespace gbe
       }
       std::string ErrInfo;// = "Not Materializable";
       if (newMF->isMaterializable()) {
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR <= 35
-        if (newMF->Materialize(&ErrInfo)) {
-          printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+        if (llvm::Error EC = newMF->materialize()) {
+          std::string Msg;
+          handleAllErrors(std::move(EC), [&](ErrorInfoBase &EIB) {
+            Msg = EIB.message();
+          });
+          printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), Msg.c_str());
           delete clonedLib;
           return NULL;
         }
-      }
-#else
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
         if (std::error_code EC = newMF->materialize()) {
           printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), EC.message().c_str());
           delete clonedLib;
           return NULL;
         }
-      }
+#else
+        if (newMF->Materialize(&ErrInfo)) {
+          printf("Can not materialize the function: %s, because %s\n", fnName.c_str(), ErrInfo.c_str());
+          delete clonedLib;
+          return NULL;
+        }
 #endif
+      }
 
       if (!materializedFuncCall(*mod, *clonedLib, *newMF, materializedFuncs, Gvs)) {
         delete clonedLib;
@@ -292,7 +312,12 @@ namespace gbe
     Module::GlobalListType &GVlist = clonedLib->getGlobalList();
     for(Module::global_iterator GVitr = GVlist.begin();GVitr != GVlist.end();++GVitr) {
       GlobalValue * GV = &*GVitr;
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      ExitOnError ExitOnErr("Can not materialize the clonedLib: ");
+      ExitOnErr(clonedLib->materialize(GV));
+#else
       clonedLib->materialize(GV);
+#endif
       Gvs.push_back(GV);
     }
     llvm::legacy::PassManager Extract;
@@ -300,7 +325,12 @@ namespace gbe
     Extract.add(createGVExtractionPass(Gvs, false));
     Extract.run(*clonedLib);
     /* Mark the library module as materialized for later use. */
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    ExitOnError ExitOnErr("Can not materialize the clonedLib: ");
+    ExitOnErr(clonedLib->materializeAll());
+#else
     clonedLib->materializeAll();
+#endif
 #endif
 
     /* the SPIR binary datalayout maybe different with beignet's bitcode */
@@ -309,14 +339,14 @@ namespace gbe
 
     /* We use beignet's bitcode as dst because it will have a lot of
        lazy functions which will not be loaded. */
-    char* errorMsg;
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
     if(LLVMLinkModules2(wrap(clonedLib), wrap(mod))) {
 #else
+    char* errorMsg;
     if(LLVMLinkModules(wrap(clonedLib), wrap(mod), LLVMLinkerDestroySource, &errorMsg)) {
+      printf("Fatal Error: link the bitcode error:\n%s\n", errorMsg);
 #endif
       delete clonedLib;
-      printf("Fatal Error: link the bitcode error:\n%s\n", errorMsg);
       return NULL;
     }
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 42d9c7b0..94f15627 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -357,6 +357,15 @@ namespace gbe
       GBE_ASSERT(! (isa<Constant>(value) && !isa<GlobalValue>(value)));
       Type *type = value->getType();
       auto typeID = type->getTypeID();
+      if (typeID == Type::PointerTyID)
+      {
+        Type *eltTy = dyn_cast<PointerType>(type)->getElementType();
+        if (eltTy->isStructTy()) {
+          StructType *strTy = dyn_cast<StructType>(eltTy);
+          if (strTy->getName().data() && strstr(strTy->getName().data(), "sampler"))
+            type = Type::getInt32Ty(value->getContext());
+        }
+      }
       switch (typeID) {
         case Type::IntegerTyID:
         case Type::FloatTyID:
@@ -573,7 +582,11 @@ namespace gbe
       pass = PASS_EMIT_REGISTERS;
     }
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    virtual llvm::StringRef getPassName() const { return "Gen Back-End"; }
+#else
     virtual const char *getPassName() const { return "Gen Back-End"; }
+#endif
 
     void getAnalysisUsage(AnalysisUsage &AU) const {
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
@@ -2409,10 +2422,11 @@ namespace gbe
         }
 
         if (llvmInfo.isSamplerType()) {
-          ctx.input(argName, ir::FunctionArgument::SAMPLER, reg, llvmInfo, getTypeByteSize(unit, type), getAlignmentByte(unit, type), 0);
+          ctx.input(argName, ir::FunctionArgument::SAMPLER, reg, llvmInfo, 4, 4, 0);
           (void)ctx.getFunction().getSamplerSet()->append(reg, &ctx);
           continue;
         }
+
         if(llvmInfo.isPipeType()) {
           llvmInfo.typeSize = getTypeSize(F.getParent(),unit,llvmInfo.typeName);
           ctx.input(argName, ir::FunctionArgument::PIPE, reg, llvmInfo, getTypeByteSize(unit, type), getAlignmentByte(unit, type), BtiMap.find(&*I)->second);
@@ -4063,6 +4077,15 @@ namespace gbe
         regTranslator.newValueProxy(srcValue, dst);
         break;
       }
+      case GEN_OCL_INT_TO_SAMPLER:
+      case GEN_OCL_SAMPLER_TO_INT:
+      {
+        Value *srcValue = I.getOperand(0);
+        //srcValue->dump();
+        //dst->dump();
+        regTranslator.newValueProxy(srcValue, dst);
+        break;
+      }
       case GEN_OCL_ENQUEUE_GET_ENQUEUE_INFO_ADDR:
         regTranslator.newScalarProxy(ir::ocl::enqueuebufptr, dst);
         break;
@@ -4481,10 +4504,19 @@ namespace gbe
   /* append a new sampler. should be called before any reference to
    * a sampler_t value. */
   uint8_t GenWriter::appendSampler(CallSite::arg_iterator AI) {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    CallInst *TC = dyn_cast<CallInst>(*AI);
+    Constant *CPV = TC ? dyn_cast<Constant>(TC->getOperand(0)) : NULL;
+#else
     Constant *CPV = dyn_cast<Constant>(*AI);
+#endif
     uint8_t index;
     if (CPV != NULL)
     {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      // Check if the Callee is sampler convert function
+      GBE_ASSERT(TC->getCalledFunction()->getName().str() == "__gen_ocl_int_to_sampler");
+#endif
       // This is not a kernel argument sampler, we need to append it to sampler set,
       // and allocate a sampler slot for it.
       const ir::Immediate &x = processConstantImm(CPV);
@@ -5464,6 +5496,8 @@ namespace gbe
           case GEN_OCL_GET_PIPE:
           case GEN_OCL_MAKE_RID:
           case GEN_OCL_GET_RID:
+          case GEN_OCL_INT_TO_SAMPLER:
+          case GEN_OCL_SAMPLER_TO_INT:
           {
             break;
           }
diff --git a/backend/src/llvm/llvm_gen_ocl_function.hxx b/backend/src/llvm/llvm_gen_ocl_function.hxx
index 86485da3..08087cb9 100644
--- a/backend/src/llvm/llvm_gen_ocl_function.hxx
+++ b/backend/src/llvm/llvm_gen_ocl_function.hxx
@@ -266,3 +266,7 @@ DECL_LLVM_GEN_FUNCTION(MAKE_RID, __gen_ocl_make_rid)
 DECL_LLVM_GEN_FUNCTION(ENQUEUE_SET_NDRANGE_INFO, __gen_ocl_set_ndrange_info)
 DECL_LLVM_GEN_FUNCTION(ENQUEUE_GET_NDRANGE_INFO, __gen_ocl_get_ndrange_info)
 DECL_LLVM_GEN_FUNCTION(ENQUEUE_GET_ENQUEUE_INFO_ADDR, __gen_ocl_get_enqueue_info_addr)
+
+// sampler helper functions
+DECL_LLVM_GEN_FUNCTION(SAMPLER_TO_INT, __gen_ocl_sampler_to_int)
+DECL_LLVM_GEN_FUNCTION(INT_TO_SAMPLER, __gen_ocl_int_to_sampler)
diff --git a/backend/src/llvm/llvm_includes.hpp b/backend/src/llvm/llvm_includes.hpp
index a242fd34..184553af 100644
--- a/backend/src/llvm/llvm_includes.hpp
+++ b/backend/src/llvm/llvm_includes.hpp
@@ -24,6 +24,7 @@
 #ifndef __GBE_IR_LLVM_INCLUDES_HPP__
 #define __GBE_IR_LLVM_INCLUDES_HPP__
 
+#ifdef GBE_COMPILER_AVAILABLE
 #include "llvm/Config/llvm-config.h"
 
 #include "llvm/IR/BasicBlock.h"
@@ -75,7 +76,12 @@
 
 #include "llvm-c/Linker.h"
 #include "llvm/IRReader/IRReader.h"
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+#include <llvm/Bitcode/BitcodeWriter.h>
+//#include <llvm/Bitcode/BitcodeReader.h>
+#else
 #include "llvm/Bitcode/ReaderWriter.h"
+#endif
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/Utils/Cloning.h"
 
@@ -132,4 +138,10 @@
 #include "llvm/Transforms/Scalar/GVN.h"
 #endif
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
+#include "llvm/Support/Error.h"
+#endif
+
+#endif /*GBE_COMPILER_AVAILABLE */
+
 #endif /* __GBE_IR_LLVM_INCLUDES_HPP__ */
diff --git a/backend/src/llvm/llvm_intrinsic_lowering.cpp b/backend/src/llvm/llvm_intrinsic_lowering.cpp
index f01bb516..57c933f5 100644
--- a/backend/src/llvm/llvm_intrinsic_lowering.cpp
+++ b/backend/src/llvm/llvm_intrinsic_lowering.cpp
@@ -40,7 +40,12 @@ namespace gbe {
 
       }
 
-      virtual const char *getPassName() const {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      virtual StringRef getPassName() const
+#else
+      virtual const char *getPassName() const
+#endif
+      {
         return "SPIR backend: lowering instrinsics";
       }
       static char convertSpaceToName(Value *val) {
diff --git a/backend/src/llvm/llvm_loadstore_optimization.cpp b/backend/src/llvm/llvm_loadstore_optimization.cpp
index 4f4639c0..5aa38bef 100644
--- a/backend/src/llvm/llvm_loadstore_optimization.cpp
+++ b/backend/src/llvm/llvm_loadstore_optimization.cpp
@@ -75,8 +75,12 @@ namespace gbe {
                                   const BasicBlock::iterator &start,
                                   unsigned maxVecSize,
                                   bool isLoad);
-
-    virtual const char *getPassName() const {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    virtual StringRef getPassName() const
+#else
+    virtual const char *getPassName() const
+#endif
+    {
       return "Merge compatible Load/stores for Gen";
     }
   };
diff --git a/backend/src/llvm/llvm_passes.cpp b/backend/src/llvm/llvm_passes.cpp
index f414fbbd..10752a35 100644
--- a/backend/src/llvm/llvm_passes.cpp
+++ b/backend/src/llvm/llvm_passes.cpp
@@ -232,7 +232,11 @@ namespace gbe
       AU.setPreservesCFG();
     }
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    virtual StringRef getPassName() const {
+#else
     virtual const char *getPassName() const {
+#endif
       return "SPIR backend: insert special spir instructions";
     }
 
diff --git a/backend/src/llvm/llvm_printf_parser.cpp b/backend/src/llvm/llvm_printf_parser.cpp
index a1b1c2c9..6bb7c52a 100644
--- a/backend/src/llvm/llvm_printf_parser.cpp
+++ b/backend/src/llvm/llvm_printf_parser.cpp
@@ -309,7 +309,11 @@ error:
     bool parseOnePrintfInstruction(CallInst * call);
     bool generateOneParameterInst(PrintfSlot& slot, Value* arg, Value*& new_arg);
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    virtual StringRef getPassName() const
+#else
     virtual const char *getPassName() const
+#endif
     {
       return "Printf Parser";
     }
@@ -515,7 +519,11 @@ error:
       case Type::FloatTyID: {
         /* llvm 3.6 will give a undef value for NAN. */
         if (dyn_cast<llvm::UndefValue>(arg)) {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+          APFloat nan = APFloat::getNaN(APFloat::IEEEsingle(), false);
+#else
           APFloat nan = APFloat::getNaN(APFloat::IEEEsingle, false);
+#endif
           new_arg = ConstantFP::get(module->getContext(), nan);
         }
 
diff --git a/backend/src/llvm/llvm_profiling.cpp b/backend/src/llvm/llvm_profiling.cpp
index bc169516..f7e4cc53 100644
--- a/backend/src/llvm/llvm_profiling.cpp
+++ b/backend/src/llvm/llvm_profiling.cpp
@@ -83,7 +83,11 @@ namespace gbe
     {
     }
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+    virtual StringRef getPassName() const
+#else
     virtual const char *getPassName() const
+#endif
     {
       return "Timestamp Parser";
     }
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index 9b3b1f4e..37919ec6 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -402,9 +402,17 @@ namespace gbe
     passes.add(createScalarizePass());             // Expand all vector ops
 
     if(OCL_OUTPUT_CFG)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      passes.add(createCFGPrinterLegacyPassPass());
+#else
       passes.add(createCFGPrinterPass());
+#endif
     if(OCL_OUTPUT_CFG_ONLY)
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      passes.add(createCFGOnlyPrinterLegacyPassPass());
+#else
       passes.add(createCFGOnlyPrinterPass());
+#endif
     passes.add(createGenPass(unit));
     passes.run(mod);
     errors = dc.str();
diff --git a/backend/src/llvm/llvm_unroll.cpp b/backend/src/llvm/llvm_unroll.cpp
index bfd3bbe3..107d7937 100644
--- a/backend/src/llvm/llvm_unroll.cpp
+++ b/backend/src/llvm/llvm_unroll.cpp
@@ -238,7 +238,12 @@ namespace gbe {
         return true;
       }
 
-      virtual const char *getPassName() const {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+      virtual StringRef getPassName() const
+#else
+      virtual const char *getPassName() const
+#endif
+      {
         return "SPIR backend: custom loop unrolling pass";
       }
 

From a7c527b496f4969030a3dd74920f1ae87cf356d6 Mon Sep 17 00:00:00 2001
From: Ruiling Song <ruiling.song@intel.com>
Date: Thu, 6 Apr 2017 19:46:35 +0800
Subject: [PATCH 16/52] utest: modify compiler_if_else to not rely on compiler
 behaviour.

the test case modify src as well as dst.
and it introduce cross workitem memory dependency in dst[id] = src[id+1];
The compiler may order 'then' and 'else' block not as written.
If compiler order the else block first. src[3+1] will be modified in else part.
And the utest will get wrong result. If user want to get the old behaviour,
It should use two if-then and order them as required.

Signed-off-by: Ruiling Song <ruiling.song@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 kernels/compiler_if_else.cl |  2 --
 utests/compiler_if_else.cpp | 15 +++++----------
 2 files changed, 5 insertions(+), 12 deletions(-)

diff --git a/kernels/compiler_if_else.cl b/kernels/compiler_if_else.cl
index 7ae8f995..c8b2cb82 100644
--- a/kernels/compiler_if_else.cl
+++ b/kernels/compiler_if_else.cl
@@ -5,10 +5,8 @@ compiler_if_else(__global int *src, __global int *dst)
   dst[id] = src[id];
   if (dst[id] >= 0) {
     dst[id] = src[id+1];
-    src[id] = 1;
   } else {
     dst[id]--;
-    src[id] = 2;
   }
 }
 
diff --git a/utests/compiler_if_else.cpp b/utests/compiler_if_else.cpp
index e38b23ff..d65ecd37 100644
--- a/utests/compiler_if_else.cpp
+++ b/utests/compiler_if_else.cpp
@@ -21,43 +21,38 @@ static void compiler_if_else(void)
   OCL_NDRANGE(1);
 
   // First control flow
-  OCL_MAP_BUFFER(0);
   OCL_MAP_BUFFER(1);
   for (uint32_t i = 0; i < 16; ++i) {
     OCL_ASSERT(((int32_t*)buf_data[1])[i] == 2);
-    OCL_ASSERT(((int32_t*)buf_data[0])[i] == 1);
   }
+  OCL_UNMAP_BUFFER(1);
 
   // Second control flow
+  OCL_MAP_BUFFER(0);
   for (uint32_t i = 0; i < n; ++i) ((int32_t*)buf_data[0])[i] = -1;
   OCL_UNMAP_BUFFER(0);
-  OCL_UNMAP_BUFFER(1);
   OCL_NDRANGE(1);
-  OCL_MAP_BUFFER(0);
   OCL_MAP_BUFFER(1);
   for (uint32_t i = 0; i < 16; ++i) {
     OCL_ASSERT(((int32_t*)buf_data[1])[i] == -2);
-    OCL_ASSERT(((int32_t*)buf_data[0])[i] == 2);
   }
+  OCL_UNMAP_BUFFER(1);
 
   // Third control flow
+  OCL_MAP_BUFFER(0);
   for (uint32_t i = 0; i < 4; ++i) ((int32_t*)buf_data[0])[i] = 2;
   for (uint32_t i = 4; i < n; ++i) ((int32_t*)buf_data[0])[i] = -1;
   OCL_UNMAP_BUFFER(0);
-  OCL_UNMAP_BUFFER(1);
   OCL_NDRANGE(1);
-  OCL_MAP_BUFFER(0);
   OCL_MAP_BUFFER(1);
   for (uint32_t i = 0; i < 3; ++i) {
     OCL_ASSERT(((int32_t*)buf_data[1])[i] == 2);
-    OCL_ASSERT(((int32_t*)buf_data[0])[i] == 1);
   }
   OCL_ASSERT(((int32_t*)buf_data[1])[3] == -1);
-  OCL_ASSERT(((int32_t*)buf_data[0])[3] == 1);
   for (uint32_t i = 4; i < 16; ++i) {
     OCL_ASSERT(((int32_t*)buf_data[1])[i] == -2);
-    OCL_ASSERT(((int32_t*)buf_data[0])[i] == 2);
   }
+  OCL_UNMAP_BUFFER(1);
 }
 
 MAKE_UTEST_FROM_FUNCTION(compiler_if_else);

From 007f3393d4ac35a7aa2369f88b23501a8bc64ed0 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Thu, 23 Mar 2017 18:00:26 +0800
Subject: [PATCH 17/52] GBE: set memcpy and memset functions's linkage to
 LinkOnceAnyLinkage at last call.

LLVM IR pass will produce memcpy and memset, if set LinkOnceAnyLinkage,
memcpy and memset will be delete before and cause fail.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/llvm/StripAttributes.cpp  | 15 +++++++++++----
 backend/src/llvm/llvm_gen_backend.hpp |  2 +-
 backend/src/llvm/llvm_to_gen.cpp      |  4 ++--
 3 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/backend/src/llvm/StripAttributes.cpp b/backend/src/llvm/StripAttributes.cpp
index 9d07c29d..99e5a71e 100644
--- a/backend/src/llvm/StripAttributes.cpp
+++ b/backend/src/llvm/StripAttributes.cpp
@@ -79,10 +79,13 @@ namespace {
   class StripAttributes : public FunctionPass {
   public:
     static char ID; // Pass identification, replacement for typeid
-    StripAttributes() : FunctionPass(ID) {
+    StripAttributes(bool lastTime) : FunctionPass(ID),
+                                     lastTime(lastTime) {
     }
 
     virtual bool runOnFunction(Function &Func);
+  private:
+    bool lastTime; //last time all StripAttributes
   };
 }
 
@@ -93,7 +96,11 @@ bool StripAttributes::runOnFunction(Function &Func) {
   Func.setLinkage(GlobalValue::ExternalLinkage);
   if (!gbe::isKernelFunction(Func)) {
     Func.addFnAttr(Attribute::AlwaysInline);
-    Func.setLinkage(GlobalValue::LinkOnceAnyLinkage);
+    if (lastTime ||
+        (Func.getName().find("__gen_mem") == std::string::npos))
+      // Memcpy and memset functions could be deleted at last inline.
+      // Delete memcpy and memset functions for output llvm ir friendly.
+      Func.setLinkage(GlobalValue::LinkOnceAnyLinkage);
   }
 
   for (Function::iterator BB = Func.begin(), E = Func.end();
@@ -109,6 +116,6 @@ bool StripAttributes::runOnFunction(Function &Func) {
   return true;
 }
 
-FunctionPass *llvm::createStripAttributesPass() {
-  return new StripAttributes();
+FunctionPass *llvm::createStripAttributesPass(bool lastTime) {
+  return new StripAttributes(lastTime);
 }
diff --git a/backend/src/llvm/llvm_gen_backend.hpp b/backend/src/llvm/llvm_gen_backend.hpp
index 2a322ac1..b4715b15 100644
--- a/backend/src/llvm/llvm_gen_backend.hpp
+++ b/backend/src/llvm/llvm_gen_backend.hpp
@@ -46,7 +46,7 @@ namespace llvm {
   FunctionPass *createExpandConstantExprPass();
   FunctionPass *createExpandLargeIntegersPass();
   FunctionPass *createPromoteIntegersPass();
-  FunctionPass *createStripAttributesPass();
+  FunctionPass *createStripAttributesPass(bool lastTime);
   // Copy debug information from Original to New, and return New.
   template <typename T> T *CopyDebug(T *New, llvm::Instruction *Original) {
     New->setDebugLoc(Original->getDebugLoc());
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index 37919ec6..ceefbbb0 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -139,7 +139,7 @@ namespace gbe
     MPM.add(createBarrierNodupPass(false));   // remove noduplicate fnAttr before inlining.
     MPM.add(createFunctionInliningPass(20000));
     MPM.add(createBarrierNodupPass(true));    // restore noduplicate fnAttr after inlining.
-    MPM.add(createStripAttributesPass());     // Strip unsupported attributes and calling conventions.
+    MPM.add(createStripAttributesPass(false));     // Strip unsupported attributes and calling conventions.
     MPM.add(createSamplerFixPass());
     MPM.add(createGlobalOptimizerPass());     // Optimize out global vars
 
@@ -372,7 +372,7 @@ namespace gbe
 #endif
     // Print the code before further optimizations
     passes.add(createIntrinsicLoweringPass());
-    passes.add(createStripAttributesPass());     // Strip unsupported attributes and calling conventions.
+    passes.add(createStripAttributesPass(true));     // Strip unsupported attributes and calling conventions.
     passes.add(createFunctionInliningPass(20000));
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
     passes.add(createSROAPass());

From 98aeed34e6b5af2ca95e302503f25e92f30cb875 Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Mon, 15 May 2017 13:36:15 +0800
Subject: [PATCH 18/52] GLK: add Geminilake pciids.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 src/cl_device_data.h | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/cl_device_data.h b/src/cl_device_data.h
index f3c52049..c3d6c45f 100644
--- a/src/cl_device_data.h
+++ b/src/cl_device_data.h
@@ -361,7 +361,14 @@
 
 #define IS_KABYLAKE(devid) (IS_KBL_GT1(devid) || IS_KBL_GT15(devid) || IS_KBL_GT2(devid) || IS_KBL_GT3(devid) || IS_KBL_GT4(devid))
 
-#define IS_GEN9(devid)     (IS_SKYLAKE(devid) || IS_BROXTON(devid) || IS_KABYLAKE(devid))
+#define PCI_CHIP_GLK_3x6     0x3184
+#define PCI_CHIP_GLK_2x6     0x3185
+
+#define IS_GEMINILAKE(devid)      \
+  (devid == PCI_CHIP_GLK_3x6 ||   \
+   devid == PCI_CHIP_GLK_2x6)
+
+#define IS_GEN9(devid)     (IS_SKYLAKE(devid) || IS_BROXTON(devid) || IS_KABYLAKE(devid) || IS_GEMINILAKE(devid))
 
 #define MAX_OCLVERSION(devid) (IS_GEN9(devid) ? 200 : 120)
 

From 6f9ea4677eb382b6be7de7d7c3a2b340dfdf38f4 Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Mon, 15 May 2017 14:07:46 +0800
Subject: [PATCH 19/52] GLK: add geminilake backend support.

Geminilake's backend is same as bxt.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/backend/gen9_context.cpp       |  4 ++++
 backend/src/backend/gen9_context.hpp       | 14 ++++++++++++++
 backend/src/backend/gen_insn_selection.cpp | 11 +++++++++++
 backend/src/backend/gen_insn_selection.hpp |  7 +++++++
 backend/src/backend/gen_program.cpp        | 13 +++++++++++--
 5 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/backend/src/backend/gen9_context.cpp b/backend/src/backend/gen9_context.cpp
index 483b2c33..2ce53b68 100644
--- a/backend/src/backend/gen9_context.cpp
+++ b/backend/src/backend/gen9_context.cpp
@@ -236,4 +236,8 @@ namespace gbe
     this->sel = GBE_NEW(SelectionKbl, *this);
   }
 
+  void GlkContext::newSelection(void) {
+    this->sel = GBE_NEW(SelectionGlk, *this);
+  }
+
 }
diff --git a/backend/src/backend/gen9_context.hpp b/backend/src/backend/gen9_context.hpp
index 9977e9a1..04766616 100644
--- a/backend/src/backend/gen9_context.hpp
+++ b/backend/src/backend/gen9_context.hpp
@@ -82,5 +82,19 @@ namespace gbe
     private:
       virtual void newSelection(void);
   };
+
+  /* This class is used to implement the geminilake
+     specific logic for context. */
+  class GlkContext : public BxtContext
+  {
+    public:
+      virtual ~GlkContext(void) { };
+      GlkContext(const ir::Unit &unit, const std::string &name, uint32_t deviceID, bool relaxMath = false)
+        : BxtContext(unit, name, deviceID, relaxMath) {
+        };
+
+    private:
+      virtual void newSelection(void);
+  };
 }
 #endif /* __GBE_GEN9_CONTEXT_HPP__ */
diff --git a/backend/src/backend/gen_insn_selection.cpp b/backend/src/backend/gen_insn_selection.cpp
index 22b0ddce..0c367e0d 100644
--- a/backend/src/backend/gen_insn_selection.cpp
+++ b/backend/src/backend/gen_insn_selection.cpp
@@ -2859,6 +2859,17 @@ extern bool OCL_DEBUGINFO; // first defined by calling BVAR in program.cpp
     opt_features = SIOF_LOGICAL_SRCMOD;
   }
 
+  SelectionGlk::SelectionGlk(GenContext &ctx) : Selection(ctx) {
+    this->opaque->setHas32X32Mul(true);
+    this->opaque->setHasLongType(true);
+    this->opaque->setLongRegRestrict(true);
+    this->opaque->setHasDoubleType(true);
+    this->opaque->setLdMsgOrder(LD_MSG_ORDER_SKL);
+    this->opaque->setSlowByteGather(false);
+    this->opaque->setHasHalfType(true);
+    opt_features = SIOF_LOGICAL_SRCMOD | SIOF_OP_MOV_LONG_REG_RESTRICT;
+  }
+
   void Selection::Opaque::TYPED_WRITE(GenRegister *msgs, uint32_t msgNum,
                                       uint32_t bti, bool is3D) {
     uint32_t elemID = 0;
diff --git a/backend/src/backend/gen_insn_selection.hpp b/backend/src/backend/gen_insn_selection.hpp
index a99b8a92..8f346786 100644
--- a/backend/src/backend/gen_insn_selection.hpp
+++ b/backend/src/backend/gen_insn_selection.hpp
@@ -374,6 +374,13 @@ namespace gbe
       SelectionKbl(GenContext &ctx);
   };
 
+  class SelectionGlk: public Selection
+  {
+    public:
+      /*! Initialize internal structures used for the selection */
+      SelectionGlk(GenContext &ctx);
+  };
+
 } /* namespace gbe */
 
 #endif /*  __GEN_INSN_SELECTION_HPP__ */
diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index c1827b11..383f2f27 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -186,6 +186,8 @@ namespace gbe {
       ctx = GBE_NEW(BxtContext, unit, name, deviceID, relaxMath);
     } else if (IS_KABYLAKE(deviceID)) {
       ctx = GBE_NEW(KblContext, unit, name, deviceID, relaxMath);
+    } else if (IS_GEMINILAKE(deviceID)) {
+      ctx = GBE_NEW(GlkContext, unit, name, deviceID, relaxMath);
     }
     GBE_ASSERTM(ctx != NULL, "Fail to create the gen context\n");
 
@@ -241,6 +243,7 @@ namespace gbe {
     GBHI_SKL = 5,
     GBHI_BXT = 6,
     GBHI_KBL = 7,
+    GBHI_GLK = 8,
     GBHI_MAX,
   };
 #define GEN_BINARY_VERSION  1
@@ -252,7 +255,8 @@ namespace gbe {
                                               {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'B', 'D', 'W'},
                                               {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'S', 'K', 'L'},
                                               {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'B', 'X', 'T'},
-                                              {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'K', 'B', 'T'}
+                                              {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'K', 'B', 'T'},
+                                              {GEN_BINARY_VERSION, 'G','E', 'N', 'C', 'G', 'L', 'K'}
                                               };
 
 #define FILL_GEN_HEADER(binary, index)  do {int i = 0; do {*(binary+i) = gen_binary_header[index][i]; i++; }while(i < GEN_BINARY_HEADER_LENGTH);}while(0)
@@ -264,6 +268,7 @@ namespace gbe {
 #define FILL_SKL_HEADER(binary) FILL_GEN_HEADER(binary, GBHI_SKL)
 #define FILL_BXT_HEADER(binary) FILL_GEN_HEADER(binary, GBHI_BXT)
 #define FILL_KBL_HEADER(binary) FILL_GEN_HEADER(binary, GBHI_KBL)
+#define FILL_GLK_HEADER(binary) FILL_GEN_HEADER(binary, GBHI_GLK)
 
   static bool genHeaderCompare(const unsigned char *BufPtr, GEN_BINARY_HEADER_INDEX index)
   {
@@ -289,6 +294,7 @@ namespace gbe {
 #define MATCH_SKL_HEADER(binary) genHeaderCompare(binary, GBHI_SKL)
 #define MATCH_BXT_HEADER(binary) genHeaderCompare(binary, GBHI_BXT)
 #define MATCH_KBL_HEADER(binary) genHeaderCompare(binary, GBHI_KBL)
+#define MATCH_GLK_HEADER(binary) genHeaderCompare(binary, GBHI_GLK)
 
 #define MATCH_DEVICE(deviceID, binary) ((IS_IVYBRIDGE(deviceID) && MATCH_IVB_HEADER(binary)) ||  \
                                       (IS_IVYBRIDGE(deviceID) && MATCH_IVB_HEADER(binary)) ||  \
@@ -298,7 +304,8 @@ namespace gbe {
                                       (IS_CHERRYVIEW(deviceID) && MATCH_CHV_HEADER(binary)) ||  \
                                       (IS_SKYLAKE(deviceID) && MATCH_SKL_HEADER(binary)) || \
                                       (IS_BROXTON(deviceID) && MATCH_BXT_HEADER(binary)) || \
-                                      (IS_KABYLAKE(deviceID) && MATCH_KBL_HEADER(binary)) \
+                                      (IS_KABYLAKE(deviceID) && MATCH_KBL_HEADER(binary)) || \
+                                      (IS_GEMINILAKE(deviceID) && MATCH_GLK_HEADER(binary)) \
                                       )
 
   static gbe_program genProgramNewFromBinary(uint32_t deviceID, const char *binary, size_t size) {
@@ -406,6 +413,8 @@ namespace gbe {
         FILL_BXT_HEADER(*binary);
       }else if(IS_KABYLAKE(prog->deviceID)){
         FILL_KBL_HEADER(*binary);
+      }else if(IS_GEMINILAKE(prog->deviceID)){
+        FILL_GLK_HEADER(*binary);
       }else {
         free(*binary);
         *binary = NULL;

From 05445e26ce6ffdd70a03254d9edfdbbf901a06ed Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Mon, 15 May 2017 16:22:32 +0800
Subject: [PATCH 20/52] GLK: add geminilake runtime support.

Geminilake is almost same as bxt, except intel_gpgpu_read_ts_reg
function.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 src/cl_device_id.c      | 47 +++++++++++++++++++++++++++++++++++++++++++++--
 src/intel/intel_gpgpu.c |  2 ++
 2 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/src/cl_device_id.c b/src/cl_device_id.c
index d4f4208e..1ed99625 100644
--- a/src/cl_device_id.c
+++ b/src/cl_device_id.c
@@ -254,6 +254,26 @@ static struct _cl_device_id intel_kbl_gt4_device = {
 #include "cl_gen9_device.h"
 };
 
+static struct _cl_device_id intel_glk18eu_device = {
+  .max_compute_unit = 18,
+  .max_thread_per_unit = 6,
+  .sub_slice_count = 3,
+  .max_work_item_sizes = {512, 512, 512},
+  .max_work_group_size = 512,
+  .max_clock_frequency = 1000,
+#include "cl_gen9_device.h"
+};
+
+static struct _cl_device_id intel_glk12eu_device = {
+  .max_compute_unit = 12,
+  .max_thread_per_unit = 6,
+  .sub_slice_count = 2,
+  .max_work_item_sizes = {512, 512, 512},
+  .max_work_group_size = 512,
+  .max_clock_frequency = 1000,
+#include "cl_gen9_device.h"
+};
+
 LOCAL cl_device_id
 cl_get_gt_device(cl_device_type device_type)
 {
@@ -737,6 +757,26 @@ kbl_gt4_break:
       cl_intel_platform_enable_extension(ret, cl_khr_fp16_ext_id);
       break;
 
+    case PCI_CHIP_GLK_3x6:
+      DECL_INFO_STRING(glk18eu_break, intel_bxt18eu_device, name, "Intel(R) HD Graphics Geminilake(3x6)");
+glk18eu_break:
+      intel_glk18eu_device.device_id = device_id;
+      intel_glk18eu_device.platform = cl_get_platform_default();
+      ret = &intel_glk18eu_device;
+      cl_intel_platform_get_default_extension(ret);
+      cl_intel_platform_enable_extension(ret, cl_khr_fp16_ext_id);
+      break;
+
+    case PCI_CHIP_GLK_2x6:
+      DECL_INFO_STRING(glk12eu_break, intel_bxt12eu_device, name, "Intel(R) HD Graphics Geminilake(2x6)");
+glk12eu_break:
+      intel_glk12eu_device.device_id = device_id;
+      intel_glk12eu_device.platform = cl_get_platform_default();
+      ret = &intel_glk12eu_device;
+      cl_intel_platform_get_default_extension(ret);
+      cl_intel_platform_enable_extension(ret, cl_khr_fp16_ext_id);
+      break;
+
     case PCI_CHIP_SANDYBRIDGE_BRIDGE:
     case PCI_CHIP_SANDYBRIDGE_GT1:
     case PCI_CHIP_SANDYBRIDGE_GT2:
@@ -942,7 +982,9 @@ LOCAL cl_bool is_gen_device(cl_device_id device) {
          device == &intel_kbl_gt15_device ||
          device == &intel_kbl_gt2_device ||
          device == &intel_kbl_gt3_device ||
-         device == &intel_kbl_gt4_device;
+         device == &intel_kbl_gt4_device ||
+         device == &intel_glk18eu_device ||
+         device == &intel_glk12eu_device;
 }
 
 LOCAL cl_int
@@ -1363,7 +1405,8 @@ cl_device_get_version(cl_device_id device, cl_int *ver)
         || device == &intel_skl_gt3_device || device == &intel_skl_gt4_device
         || device == &intel_bxt18eu_device || device == &intel_bxt12eu_device || device == &intel_kbl_gt1_device
         || device == &intel_kbl_gt2_device || device == &intel_kbl_gt3_device
-        || device == &intel_kbl_gt4_device || device == &intel_kbl_gt15_device) {
+        || device == &intel_kbl_gt4_device || device == &intel_kbl_gt15_device
+        || device == &intel_glk18eu_device || device == &intel_glk12eu_device) {
     *ver = 9;
   } else
     return CL_INVALID_VALUE;
diff --git a/src/intel/intel_gpgpu.c b/src/intel/intel_gpgpu.c
index 283b07a4..4f6989d5 100644
--- a/src/intel/intel_gpgpu.c
+++ b/src/intel/intel_gpgpu.c
@@ -2529,6 +2529,8 @@ intel_set_gpgpu_callbacks(int device_id)
     intel_gpgpu_get_scratch_index = intel_gpgpu_get_scratch_index_gen8;
     intel_gpgpu_post_action = intel_gpgpu_post_action_gen7; //SKL need not restore SLM, same as gen7
     intel_gpgpu_read_ts_reg = intel_gpgpu_read_ts_reg_gen7;
+    if(IS_GEMINILAKE(device_id))
+      intel_gpgpu_read_ts_reg = intel_gpgpu_read_ts_reg_baytrail;
     intel_gpgpu_set_base_address = intel_gpgpu_set_base_address_gen9;
     intel_gpgpu_setup_bti = intel_gpgpu_setup_bti_gen9;
     intel_gpgpu_load_vfe_state = intel_gpgpu_load_vfe_state_gen8;

From ea56b400d8634bd4cc2a16144cdbc4e906bd51c1 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Tue, 25 Apr 2017 13:26:33 +0800
Subject: [PATCH 21/52] Backend: Fix llvm40 assert about literal structs

In llvm literal structs have no name, so check it first.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Guo, Yejun <yejun.guo@intel.com>
---
 backend/src/llvm/llvm_gen_backend.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 94f15627..150911cc 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -362,7 +362,8 @@ namespace gbe
         Type *eltTy = dyn_cast<PointerType>(type)->getElementType();
         if (eltTy->isStructTy()) {
           StructType *strTy = dyn_cast<StructType>(eltTy);
-          if (strTy->getName().data() && strstr(strTy->getName().data(), "sampler"))
+          if (!strTy->isLiteral() && strTy->getName().data() &&
+              strstr(strTy->getName().data(), "sampler"))
             type = Type::getInt32Ty(value->getContext());
         }
       }

From eeed297dcee4428f126c61f6a0c98df49a1bd33c Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Wed, 17 May 2017 17:01:57 +0800
Subject: [PATCH 22/52] Backend: Fix performance regression with sampler refine
 fro LLVM40

After the refine we can not know if a sampler is a constant initialized
or not. Then the compiler optimization for constant sampler will break
and we will runtime decide which SAMPLE instruction will use.
Now fix the sampler refine for LLVM40 to enable the constant check.
V2: Fix a typo of function __gen_ocl_sampler_to_int type.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/libocl/src/ocl_image.cl   |  9 ++++----
 backend/src/llvm/llvm_sampler_fix.cpp | 41 +++++++++++++++++++++++++++++++----
 2 files changed, 41 insertions(+), 9 deletions(-)

diff --git a/backend/src/libocl/src/ocl_image.cl b/backend/src/libocl/src/ocl_image.cl
index e66aa155..2febfdac 100644
--- a/backend/src/libocl/src/ocl_image.cl
+++ b/backend/src/libocl/src/ocl_image.cl
@@ -295,18 +295,17 @@ GEN_VALIDATE_ARRAY_INDEX(int, read_write image1d_buffer_t)
 // The work around is to use a LD message instead of normal sample message.
 ///////////////////////////////////////////////////////////////////////////////
 
-bool __gen_ocl_sampler_need_fix(int);
-bool __gen_ocl_sampler_need_rounding_fix(int);
-int __gen_ocl_sampler_to_int(sampler_t);
+bool __gen_ocl_sampler_need_fix(sampler_t);
+bool __gen_ocl_sampler_need_rounding_fix(sampler_t);
 
 bool __gen_sampler_need_fix(const sampler_t sampler)
 {
-  return __gen_ocl_sampler_need_fix(__gen_ocl_sampler_to_int(sampler));
+  return __gen_ocl_sampler_need_fix(sampler);
 }
 
 bool __gen_sampler_need_rounding_fix(const sampler_t sampler)
 {
-  return __gen_ocl_sampler_need_rounding_fix(__gen_ocl_sampler_to_int(sampler));
+  return __gen_ocl_sampler_need_rounding_fix(sampler);
 }
 
 INLINE_OVERLOADABLE float __gen_fixup_float_coord(float tmpCoord)
diff --git a/backend/src/llvm/llvm_sampler_fix.cpp b/backend/src/llvm/llvm_sampler_fix.cpp
index 2e8bcf93..c2497558 100644
--- a/backend/src/llvm/llvm_sampler_fix.cpp
+++ b/backend/src/llvm/llvm_sampler_fix.cpp
@@ -55,9 +55,17 @@ namespace gbe {
         //          ((sampler & __CLK_FILTER_MASK) == CLK_FILTER_NEAREST));
         bool needFix = true;
         Value *needFixVal;
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+        CallInst *init = dyn_cast<CallInst>(I->getOperand(0));
+        if (init && init->getCalledValue()->getName().compare("__translate_sampler_initializer"))
+        {
+          const ConstantInt *ci = dyn_cast<ConstantInt>(init->getOperand(0));
+          uint32_t samplerInt = ci->getZExtValue();
+#else
         if (dyn_cast<ConstantInt>(I->getOperand(0))) {
           const ConstantInt *ci = dyn_cast<ConstantInt>(I->getOperand(0));
           uint32_t samplerInt = ci->getZExtValue();
+#endif
           needFix = ((samplerInt & __CLK_ADDRESS_MASK) == CLK_ADDRESS_CLAMP &&
                      (samplerInt & __CLK_FILTER_MASK) == CLK_FILTER_NEAREST);
           needFixVal = ConstantInt::get(boolTy, needFix);
@@ -65,14 +73,24 @@ namespace gbe {
           IRBuilder<> Builder(I->getParent());
 
           Builder.SetInsertPoint(I);
+
           Value *addressMask = ConstantInt::get(i32Ty, __CLK_ADDRESS_MASK);
-          Value *addressMode = Builder.CreateAnd(I->getOperand(0), addressMask);
           Value *clampInt =  ConstantInt::get(i32Ty, CLK_ADDRESS_CLAMP);
-          Value *isClampMode = Builder.CreateICmpEQ(addressMode, clampInt);
           Value *filterMask = ConstantInt::get(i32Ty, __CLK_FILTER_MASK);
-          Value *filterMode = Builder.CreateAnd(I->getOperand(0), filterMask);
           Value *nearestInt = ConstantInt::get(i32Ty, CLK_FILTER_NEAREST);
+
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+          Module *M = I->getParent()->getParent()->getParent();
+          Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType(), nullptr);
+          Value *samplerVal = Builder.CreateCall(samplerCvt, {I->getOperand(0)});
+#else
+          Value *samplerVal = I->getOperand(0);
+#endif
+          Value *addressMode = Builder.CreateAnd(samplerVal, addressMask);
+          Value *isClampMode = Builder.CreateICmpEQ(addressMode, clampInt);
+          Value *filterMode = Builder.CreateAnd(samplerVal, filterMask);
           Value *isNearestMode = Builder.CreateICmpEQ(filterMode, nearestInt);
+
           needFixVal = Builder.CreateAnd(isClampMode, isNearestMode);
         }
 
@@ -83,16 +101,31 @@ namespace gbe {
         //  return ((sampler & CLK_NORMALIZED_COORDS_TRUE) == 0);
         bool needFix = true;
         Value *needFixVal;
+ #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+        CallInst *init = dyn_cast<CallInst>(I->getOperand(0));
+        if (init && init->getCalledValue()->getName().compare("__translate_sampler_initializer"))
+        {
+          const ConstantInt *ci = dyn_cast<ConstantInt>(init->getOperand(0));
+          uint32_t samplerInt = ci->getZExtValue();
+#else
         if (dyn_cast<ConstantInt>(I->getOperand(0))) {
           const ConstantInt *ci = dyn_cast<ConstantInt>(I->getOperand(0));
           uint32_t samplerInt = ci->getZExtValue();
+#endif
           needFix = samplerInt & CLK_NORMALIZED_COORDS_TRUE;
           needFixVal = ConstantInt::get(boolTy, needFix);
         } else {
           IRBuilder<> Builder(I->getParent());
           Builder.SetInsertPoint(I);
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
+          Module *M = I->getParent()->getParent()->getParent();
+          Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType(), nullptr);
+          Value *samplerVal = Builder.CreateCall(samplerCvt, {I->getOperand(0)});
+#else
+          Value *samplerVal = I->getOperand(0);
+#endif
           Value *normalizeMask = ConstantInt::get(i32Ty, CLK_NORMALIZED_COORDS_TRUE);
-          Value *normalizeMode = Builder.CreateAnd(I->getOperand(0), normalizeMask);
+          Value *normalizeMode = Builder.CreateAnd(samplerVal, normalizeMask);
           needFixVal = Builder.CreateICmpEQ(normalizeMode, ConstantInt::get(i32Ty, 0));
         }
         I->replaceAllUsesWith(needFixVal);

From 2dd18f016bb6d411ad921d1a2e2a14384bdb8a8f Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Mon, 22 May 2017 13:07:30 +0800
Subject: [PATCH 23/52] Backend: Add sel ir output for MATH function

We only output MATH function before, now we can know which math
function is it.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_insn_selection_output.cpp | 42 +++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/backend/src/backend/gen_insn_selection_output.cpp b/backend/src/backend/gen_insn_selection_output.cpp
index f23e8c8d..33f0d15d 100644
--- a/backend/src/backend/gen_insn_selection_output.cpp
+++ b/backend/src/backend/gen_insn_selection_output.cpp
@@ -142,6 +142,48 @@ namespace gbe
       }
     }
 
+    if (insn.opcode == SEL_OP_MATH) {
+      switch (insn.extra.function) {
+        case GEN_MATH_FUNCTION_INV:
+          strcat(opname, ".inv");
+          break;
+        case GEN_MATH_FUNCTION_LOG:
+          strcat(opname, ".log");
+          break;
+        case GEN_MATH_FUNCTION_EXP:
+          strcat(opname, ".exp");
+          break;
+        case GEN_MATH_FUNCTION_SQRT:
+          strcat(opname, ".sqrt");
+          break;
+        case GEN_MATH_FUNCTION_RSQ:
+          strcat(opname, ".rsq");
+          break;
+        case GEN_MATH_FUNCTION_SIN:
+          strcat(opname, ".sin");
+          break;
+        case GEN_MATH_FUNCTION_COS:
+          strcat(opname, ".cos");
+          break;
+        case GEN_MATH_FUNCTION_FDIV:
+          strcat(opname, ".fdiv");
+          break;
+        case GEN_MATH_FUNCTION_POW:
+          strcat(opname, ".pow");
+          break;
+        case GEN_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER:
+          strcat(opname, ".intdivmod");
+          break;
+        case GEN_MATH_FUNCTION_INT_DIV_QUOTIENT:
+          strcat(opname, ".intdiv");
+          break;
+        case GEN_MATH_FUNCTION_INT_DIV_REMAINDER:
+          strcat(opname, ".intmod");
+          break;
+      }
+    }
+
+
     int n = strlen(opname);
     if(n >= OP_NAME_LENGTH - 20) {
       cout << "opname too long: " << opname << endl;

From fb619980d37e89a9aa799cb88de317ffaeadeff0 Mon Sep 17 00:00:00 2001
From: Guo Yejun <yejun.guo@intel.com>
Date: Wed, 17 May 2017 14:52:18 +0800
Subject: [PATCH 24/52] refresh DAG when an arg has both direct and indirect
 read

when the return value is ARG_INDIRECT_READ, there is still possible
that some IRs read it directly, and will be handled in buildConstantPush()
so we need to refresh the dag afer function buildConstantPush

another method is to update DAG accordingly, but i don't think it
is easy compared with the refresh method, so i do not choose it.

Signed-off-by: Guo Yejun <yejun.guo@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/ir/lowering.cpp | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/backend/src/ir/lowering.cpp b/backend/src/ir/lowering.cpp
index 93bd96ad..bcf59400 100644
--- a/backend/src/ir/lowering.cpp
+++ b/backend/src/ir/lowering.cpp
@@ -199,6 +199,7 @@ namespace ir {
     GBE_SAFE_DELETE(liveness);
     this->liveness = GBE_NEW(ir::Liveness, *fn);
     this->dag = GBE_NEW(ir::FunctionDAG, *this->liveness);
+    bool needRefreshDag = false;
 
     // Process all structure arguments and find all the direct loads we can
     // replace
@@ -207,13 +208,27 @@ namespace ir {
     for (uint32_t argID = 0; argID < argNum; ++argID) {
       FunctionArgument &arg = fn->getArg(argID);
       if (arg.type != FunctionArgument::STRUCTURE) continue;
-      if(this->lower(argID) == ARG_INDIRECT_READ)
+      if(this->lower(argID) == ARG_INDIRECT_READ) {
         indirctReadArgs.push_back(argID);
+        //when the return value is ARG_INDIRECT_READ, there is still possible
+        //that some IRs read it directly, and will be handled in buildConstantPush()
+        //so we need to refresh the dag afer function buildConstantPush
+        for (const auto &loadAddImm : seq) {
+          if (loadAddImm.argID == argID)
+            needRefreshDag = true;
+        }
+      }
     }
 
     // Build the constant push description and remove the instruction that
     // therefore become useless
     this->buildConstantPush();
+    if (needRefreshDag) {
+      GBE_SAFE_DELETE(dag);
+      GBE_SAFE_DELETE(liveness);
+      this->liveness = GBE_NEW(ir::Liveness, *fn);
+      this->dag = GBE_NEW(ir::FunctionDAG, *this->liveness);
+    }
     for (uint32_t i = 0; i < indirctReadArgs.size(); ++i){
       lowerIndirectRead(indirctReadArgs[i]);
     }

From 423ac0a313b53f8909b69ef985558da308dc7016 Mon Sep 17 00:00:00 2001
From: Ismo Puustinen <ismo.puustinen@intel.com>
Date: Tue, 23 May 2017 11:27:23 +0300
Subject: [PATCH 25/52] build: fix cmake code generation dependencies.

There is a race condition between building .bc and header files and
generating code from .cl targets. Fix the race by adding the
dependency to generated files.

Signed-off-by: Ismo Puustinen <ismo.puustinen@intel.com>
---
 src/CMakeLists.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index f3c46328..0cd41fc5 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -18,13 +18,13 @@ foreach (KF ${KERNEL_FILES})
       OUTPUT ${output_file}
       COMMAND rm -rf ${output_file}
       COMMAND ${GBE_BIN_GENERATER} -s -o${output_file} -t${GEN_PCI_ID} ${input_file}
-      DEPENDS ${input_file} ${GBE_BIN_FILE})
+      DEPENDS ${input_file} ${GBE_BIN_FILE} beignet_bitcode)
   else(GEN_PCI_ID)
     add_custom_command(
       OUTPUT ${output_file}
       COMMAND rm -rf ${output_file}
       COMMAND ${GBE_BIN_GENERATER} -s -o${output_file} ${input_file}
-      DEPENDS ${input_file} ${GBE_BIN_FILE})
+      DEPENDS ${input_file} ${GBE_BIN_FILE} beignet_bitcode)
   endif(GEN_PCI_ID)
 endforeach (KF)
 endmacro (MakeKernelBinStr)

From f0d4888d439e40c563d145de6b589409e04275e4 Mon Sep 17 00:00:00 2001
From: Guo Yejun <yejun.guo@intel.com>
Date: Wed, 7 Jun 2017 15:44:03 +0800
Subject: [PATCH 26/52] keep GEN IR as SSA style

Signed-off-by: Guo Yejun <yejun.guo@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/llvm/llvm_gen_backend.cpp | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 150911cc..2ce37f4a 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -2983,10 +2983,12 @@ namespace gbe
           this->newRegister(const_cast<GlobalVariable*>(&v));
           ir::Register reg = regTranslator.getScalar(const_cast<GlobalVariable*>(&v), 0);
           ir::Constant &con = unit.getConstantSet().getConstant(v.getName());
-          ctx.LOADI(getType(ctx, v.getType()), reg, ctx.newIntegerImmediate(con.getOffset(), getType(ctx, v.getType())));
           if (!legacyMode) {
-            ctx.ADD(getType(ctx, v.getType()), reg, ir::ocl::constant_addrspace, reg);
-          }
+            ir::Register regload = ctx.reg(getFamily(getType(ctx, v.getType())));
+            ctx.LOADI(getType(ctx, v.getType()), regload, ctx.newIntegerImmediate(con.getOffset(), getType(ctx, v.getType())));
+            ctx.ADD(getType(ctx, v.getType()), reg, ir::ocl::constant_addrspace, regload);
+          } else
+            ctx.LOADI(getType(ctx, v.getType()), reg, ctx.newIntegerImmediate(con.getOffset(), getType(ctx, v.getType())));
         }
       } else if(addrSpace == ir::MEM_PRIVATE) {
           this->newRegister(const_cast<GlobalVariable*>(&v));

From 228161698e2b8157b39063b4a9c689288a09e38d Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Fri, 5 May 2017 14:32:18 +0800
Subject: [PATCH 27/52] Runtime: Fix a mssing llvm version marco for LLVM40+

Found a missing macro that need change to support LLVM40+.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 src/cl_extensions.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/cl_extensions.c b/src/cl_extensions.c
index a3c71ca4..d49d202f 100644
--- a/src/cl_extensions.c
+++ b/src/cl_extensions.c
@@ -42,7 +42,7 @@ void check_opt1_extension(cl_extensions_t *extensions)
   {
     if (id == EXT_ID(khr_icd))
       extensions->extensions[id].base.ext_enabled = 1;
-#if  LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR >= 5
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
     if (id == EXT_ID(khr_spir))
       extensions->extensions[id].base.ext_enabled = 1;
 #endif

From 88a2891b96a7c72ce1686a3553b3d986175e67ab Mon Sep 17 00:00:00 2001
From: rander <rander.wang@intel.com>
Date: Fri, 19 May 2017 16:19:13 +0800
Subject: [PATCH 28/52] backend: add sqrt-div pattern to instruction select

there some patterns like:
  sqrt r1, r2;
  load r4, 1.0;       ===> rqrt r3, r2
  div r3, r4, r1;

Signed-off-by: rander.wang <rander.wang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/backend/gen_insn_selection.cpp | 69 ++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/backend/src/backend/gen_insn_selection.cpp b/backend/src/backend/gen_insn_selection.cpp
index 0c367e0d..e91a14bc 100644
--- a/backend/src/backend/gen_insn_selection.cpp
+++ b/backend/src/backend/gen_insn_selection.cpp
@@ -3752,6 +3752,74 @@ extern bool OCL_DEBUGINFO; // first defined by calling BVAR in program.cpp
     }
   };
 
+  /*! there some patterns like:
+    sqrt r1, r2;
+    load r4, 1.0;       ===> rqrt r3, r2
+    div r3, r4, r1; */
+  class SqrtDivInstructionPattern : public SelectionPattern {
+  public:
+    /*! Register the pattern for all opcodes of the family */
+    SqrtDivInstructionPattern(void) : SelectionPattern(1, 1) { this->opcodes.push_back(ir::OP_DIV); }
+
+    /*! Implements base class */
+    virtual bool emit(Selection::Opaque &sel, SelectionDAG &dag) const {
+      using namespace ir;
+
+      // We are good to try. We need a MUL for one of the two sources
+      const ir::BinaryInstruction &insn = cast<ir::BinaryInstruction>(dag.insn);
+      if (insn.getType() != TYPE_FLOAT)
+        return false;
+      SelectionDAG *child0 = dag.child[0];
+      SelectionDAG *child1 = dag.child[1];
+      const GenRegister dst = sel.selReg(insn.getDst(0), TYPE_FLOAT);
+
+      if (child1 && child1->insn.getOpcode() == OP_SQR) {
+        GBE_ASSERT(cast<ir::UnaryInstruction>(child1->insn).getType() == TYPE_FLOAT);
+        GenRegister srcSQR = sel.selReg(child1->insn.getSrc(0), TYPE_FLOAT);
+        const GenRegister tmp = sel.selReg(sel.reg(ir::FAMILY_DWORD), ir::TYPE_FLOAT);
+        const GenRegister src0 = sel.selReg(insn.getSrc(0), TYPE_FLOAT);
+        float immVal = 0.0f;
+
+        if (child0 && child0->insn.getOpcode() == OP_LOADI) {
+          const auto &loadimm = cast<LoadImmInstruction>(child0->insn);
+          const Immediate imm = loadimm.getImmediate();
+          const Type type = imm.getType();
+          if (type == TYPE_FLOAT)
+            immVal = imm.getFloatValue();
+          else if (type == TYPE_S32 || type == TYPE_U32)
+            immVal = imm.getIntegerValue();
+        }
+
+        sel.push();
+        if (sel.isScalarReg(insn.getDst(0)))
+          sel.curr.execWidth = 1;
+
+        if (immVal == 1.0f) {
+          sel.MATH(dst, GEN_MATH_FUNCTION_RSQ, srcSQR);
+          if (child1->child[0])
+            child1->child[0]->isRoot = 1;
+        } else {
+          sel.MATH(tmp, GEN_MATH_FUNCTION_RSQ, srcSQR);
+          if (immVal != 0.0f) {
+            GenRegister isrc = GenRegister::immf(immVal);
+            sel.MUL(dst, tmp, isrc);
+          } else {
+            sel.MUL(dst, src0, tmp);
+            if (child0)
+              child0->isRoot = 1;
+          }
+
+          if (child1->child[0])
+            child1->child[0]->isRoot = 1;
+        }
+        sel.pop();
+
+        return true;
+      }
+      return false;
+    }
+  };
+
   /*! sel.{le,l,ge...} like patterns */
   class SelectModifierInstructionPattern : public SelectionPattern
   {
@@ -8089,6 +8157,7 @@ extern bool OCL_DEBUGINFO; // first defined by calling BVAR in program.cpp
 
   SelectionLibrary::SelectionLibrary(void) {
     this->insert<UnaryInstructionPattern>();
+    this->insert<SqrtDivInstructionPattern>();
     this->insert<BinaryInstructionPattern>();
     this->insert<TypedWriteInstructionPattern>();
     this->insert<SyncInstructionPattern>();

From f5ee60f836cfc20e3f6e222bf95898569a565edf Mon Sep 17 00:00:00 2001
From: rander <rander.wang@intel.com>
Date: Fri, 19 May 2017 16:14:40 +0800
Subject: [PATCH 29/52] utests: add utest for sqrt-div optimization

Signed-off-by: rander.wang <rander.wang@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 kernels/compiler_sqrt_div.cl |  8 ++++++
 utests/CMakeLists.txt        |  3 ++-
 utests/compiler_sqrt_div.cpp | 61 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 71 insertions(+), 1 deletion(-)
 create mode 100644 kernels/compiler_sqrt_div.cl
 create mode 100644 utests/compiler_sqrt_div.cpp

diff --git a/kernels/compiler_sqrt_div.cl b/kernels/compiler_sqrt_div.cl
new file mode 100644
index 00000000..7d5a2f08
--- /dev/null
+++ b/kernels/compiler_sqrt_div.cl
@@ -0,0 +1,8 @@
+kernel void compiler_sqrt_div(global float *src, global float *dst) {
+  int i = get_global_id(0);
+  float tmp = sqrt(src[i]);
+  dst[i*4] = 1.0f/tmp;
+  dst[i*4+1] = (float)i/tmp;
+  dst[i*4+2] = 2.0f/tmp;
+  dst[i*4+3] = 1.0f/tmp  + tmp;
+};
diff --git a/utests/CMakeLists.txt b/utests/CMakeLists.txt
index 43cf7f35..91c2d656 100644
--- a/utests/CMakeLists.txt
+++ b/utests/CMakeLists.txt
@@ -297,7 +297,8 @@ set (utests_sources
   compiler_generic_pointer.cpp
   runtime_pipe_query.cpp
   compiler_pipe_builtin.cpp
-  compiler_device_enqueue.cpp)
+  compiler_device_enqueue.cpp
+  compiler_sqrt_div.cpp)
 
 if (LLVM_VERSION_NODOT VERSION_GREATER 34)
   SET(utests_sources
diff --git a/utests/compiler_sqrt_div.cpp b/utests/compiler_sqrt_div.cpp
new file mode 100644
index 00000000..c22c5a39
--- /dev/null
+++ b/utests/compiler_sqrt_div.cpp
@@ -0,0 +1,61 @@
+#include "utest_helper.hpp"
+#include <cmath>
+
+void compiler_sqrt_div(void) {
+  const int n = 1024;
+  float src[n];
+
+  // Setup kernel and buffers
+  OCL_CREATE_KERNEL("compiler_sqrt_div");
+  OCL_CREATE_BUFFER(buf[0], 0, n * sizeof(float), NULL);
+  OCL_CREATE_BUFFER(buf[1], 0, n * 4 * sizeof(float), NULL);
+  OCL_SET_ARG(0, sizeof(cl_mem), &buf[0]);
+  OCL_SET_ARG(1, sizeof(cl_mem), &buf[1]);
+  globals[0] = n;
+  locals[0] = 16;
+
+  for (int j = 0; j < 1024; j++) {
+    OCL_MAP_BUFFER(0);
+    for (int i = 0; i < n; ++i) {
+      src[i] = ((float *)buf_data[0])[i] = (j * n + i + 1) * 0.001f;
+    }
+    OCL_UNMAP_BUFFER(0);
+
+    OCL_NDRANGE(1);
+
+    OCL_MAP_BUFFER(1);
+    float *dst = (float *)buf_data[1];
+    for (int i = 0; i < n; ++i) {
+      float cpu = 1.0f / sqrt(src[i]);
+      float gpu = dst[4 * i];
+      if (fabsf(cpu - gpu) >= 1e-3) {
+        printf("%f %f %f", src[i], cpu, gpu);
+        OCL_ASSERT(0);
+      }
+
+      cpu = i / sqrt(src[i]);
+      gpu = dst[4 * i + 1];
+      if (fabsf(cpu - gpu) >= 1e-3) {
+        printf("%f %f %f", src[i], cpu, gpu);
+        OCL_ASSERT(0);
+      }
+
+      cpu = 2.0f / sqrt(src[i]);
+      gpu = dst[4 * i + 2];
+      if (fabsf(cpu - gpu) >= 1e-3) {
+        printf("%f %f %f", src[i], cpu, gpu);
+        OCL_ASSERT(0);
+      }
+
+      cpu = 1.0f / sqrt(src[i]) + sqrt(src[i]);
+      gpu = dst[4 * i + 3];
+      if (fabsf(cpu - gpu) >= 1e-3) {
+        printf("%f %f %f", src[i], cpu, gpu);
+        OCL_ASSERT(0);
+      }
+    }
+    OCL_UNMAP_BUFFER(1);
+  }
+}
+
+MAKE_UTEST_FROM_FUNCTION(compiler_sqrt_div);

From 81755054c4c19d821e58456a1a7d601806e60e92 Mon Sep 17 00:00:00 2001
From: rander <rander.wang@intel.com>
Date: Wed, 17 May 2017 16:20:39 +0800
Subject: [PATCH 30/52] Backend: Add optimization for negative modifier

LLVM transform Mad(a, -b, c) to
Add b, -b, 0
Mad val, a, b, c

pow(a,-b) and other buildin math function to the same instruction sequence like above

for Gen support negtive modifier, mad(a, -b, c) is native suppoted.
Do it just like a:  mov b, -b, so it is a Mov operation like LocalCopyPropagation

Signed-off-by: rander.wang <rander.wang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 .../src/backend/gen_insn_selection_optimize.cpp    | 32 +++++++++++++++++++---
 1 file changed, 28 insertions(+), 4 deletions(-)

diff --git a/backend/src/backend/gen_insn_selection_optimize.cpp b/backend/src/backend/gen_insn_selection_optimize.cpp
index d2e0fb9b..07547ec4 100644
--- a/backend/src/backend/gen_insn_selection_optimize.cpp
+++ b/backend/src/backend/gen_insn_selection_optimize.cpp
@@ -74,8 +74,7 @@ namespace gbe
                   const GenRegister& replacement) :
                   insn(insn), intermedia(intermedia), replacement(replacement)
       {
-        assert(insn.opcode == SEL_OP_MOV);
-        assert(&(insn.src(0)) == &replacement);
+        assert(insn.opcode == SEL_OP_MOV || insn.opcode == SEL_OP_ADD);
         assert(&(insn.dst(0)) == &intermedia);
         this->elements = CalculateElements(intermedia, insn.state.execWidth);
         replacementOverwritten = false;
@@ -102,6 +101,7 @@ namespace gbe
     void doReplacement(ReplaceInfo* info);
     bool CanBeReplaced(const ReplaceInfo* info, const SelectionInstruction& insn, const GenRegister& var);
     void cleanReplaceInfoMap();
+    void doNegAddOptimization(SelectionInstruction &insn);
 
     SelectionBlock &bb;
     const ir::Liveness::LiveOut& liveout;
@@ -159,8 +159,13 @@ namespace gbe
 
   void SelBasicBlockOptimizer::addToReplaceInfoMap(SelectionInstruction& insn)
   {
-    assert(insn.opcode == SEL_OP_MOV);
-    const GenRegister& src = insn.src(0);
+    assert(insn.opcode == SEL_OP_MOV || insn.opcode == SEL_OP_ADD);
+    GenRegister &src = insn.src(0);
+    if (insn.opcode == SEL_OP_ADD) {
+      if (src.file == GEN_IMMEDIATE_VALUE)
+        src = insn.src(1);
+    }
+
     const GenRegister& dst = insn.dst(0);
     if (src.type != dst.type || src.file != dst.file)
       return;
@@ -249,10 +254,29 @@ namespace gbe
 
       if (insn.opcode == SEL_OP_MOV)
         addToReplaceInfoMap(insn);
+
+      doNegAddOptimization(insn);
     }
     cleanReplaceInfoMap();
   }
 
+  /* LLVM transform Mad(a, -b, c) to
+     Add b, -b, 0
+     Mad val, a, b, c
+     for Gen support negtive modifier, mad(a, -b, c) is native suppoted.
+     Also it can be used for the same like instruction sequence.
+     Do it just like a:  mov b, -b, so it is a Mov operation like LocalCopyPropagation
+  */
+  void SelBasicBlockOptimizer::doNegAddOptimization(SelectionInstruction &insn) {
+    if (insn.opcode == SEL_OP_ADD) {
+      GenRegister src0 = insn.src(0);
+      GenRegister src1 = insn.src(1);
+      if ((src0.negation && src1.file == GEN_IMMEDIATE_VALUE && src1.value.f == 0.0f) ||
+          (src1.negation && src0.file == GEN_IMMEDIATE_VALUE && src0.value.f == 0.0f))
+        addToReplaceInfoMap(insn);
+    }
+  }
+
   void SelBasicBlockOptimizer::run()
   {
     for (size_t i = 0; i < MaxTries; ++i) {

From 4dc211b2daaec200e6c78e757bb8d3b15ecd285d Mon Sep 17 00:00:00 2001
From: rander <rander.wang@intel.com>
Date: Tue, 23 May 2017 10:03:27 +0800
Subject: [PATCH 31/52] utests: added for optimization negativeAdd

the negative Add is like:
exp -a

llvm transfer it to:
add x -a, 0
exp x

Signed-off-by: rander.wang <rander.wang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 kernels/compiler_remove_negative_add.cl |  4 ++++
 utests/CMakeLists.txt                   |  3 ++-
 utests/compiler_remove_negative_add.cpp | 40 +++++++++++++++++++++++++++++++++
 3 files changed, 46 insertions(+), 1 deletion(-)
 create mode 100644 kernels/compiler_remove_negative_add.cl
 create mode 100644 utests/compiler_remove_negative_add.cpp

diff --git a/kernels/compiler_remove_negative_add.cl b/kernels/compiler_remove_negative_add.cl
new file mode 100644
index 00000000..d6f72706
--- /dev/null
+++ b/kernels/compiler_remove_negative_add.cl
@@ -0,0 +1,4 @@
+kernel void compiler_remove_negative_add(global float *src, global float *dst) {
+  int i = get_global_id(0);
+  dst[i] = exp2(-src[i]);
+};
diff --git a/utests/CMakeLists.txt b/utests/CMakeLists.txt
index 91c2d656..6b556788 100644
--- a/utests/CMakeLists.txt
+++ b/utests/CMakeLists.txt
@@ -298,7 +298,8 @@ set (utests_sources
   runtime_pipe_query.cpp
   compiler_pipe_builtin.cpp
   compiler_device_enqueue.cpp
-  compiler_sqrt_div.cpp)
+  compiler_sqrt_div.cpp
+  compiler_remove_negative_add.cpp)
 
 if (LLVM_VERSION_NODOT VERSION_GREATER 34)
   SET(utests_sources
diff --git a/utests/compiler_remove_negative_add.cpp b/utests/compiler_remove_negative_add.cpp
new file mode 100644
index 00000000..2b5df731
--- /dev/null
+++ b/utests/compiler_remove_negative_add.cpp
@@ -0,0 +1,40 @@
+#include "utest_helper.hpp"
+#include <cmath>
+
+void compiler_remove_negative_add(void) {
+  const int n = 1024;
+  float src[n];
+
+  // Setup kernel and buffers
+  OCL_CREATE_KERNEL("compiler_remove_negative_add");
+  OCL_CREATE_BUFFER(buf[0], 0, n * sizeof(float), NULL);
+  OCL_CREATE_BUFFER(buf[1], 0, n * sizeof(float), NULL);
+  OCL_SET_ARG(0, sizeof(cl_mem), &buf[0]);
+  OCL_SET_ARG(1, sizeof(cl_mem), &buf[1]);
+  globals[0] = n;
+  locals[0] = 16;
+
+  for (int j = 0; j < 1024; j++) {
+    OCL_MAP_BUFFER(0);
+    for (int i = 0; i < n; ++i) {
+      src[i] = ((float *)buf_data[0])[i] = (j * n + i + 1) * 0.001f;
+    }
+    OCL_UNMAP_BUFFER(0);
+
+    OCL_NDRANGE(1);
+
+    OCL_MAP_BUFFER(1);
+    float *dst = (float *)buf_data[1];
+    for (int i = 0; i < n; ++i) {
+      float cpu = exp2(-src[i]);
+      float gpu = dst[i];
+      if (fabsf(cpu - gpu) >= 1e-3) {
+        printf("%f %f %f", src[i], cpu, gpu);
+        OCL_ASSERT(0);
+      }
+    }
+    OCL_UNMAP_BUFFER(1);
+  }
+}
+
+MAKE_UTEST_FROM_FUNCTION(compiler_remove_negative_add);

From b0a6a8a541839d55c8a15b972caa85f0706949e6 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Thu, 15 Jun 2017 16:44:23 +0800
Subject: [PATCH 32/52] Backend: Add intel_reqd_sub_group_size support

If we get intel_reqd_sub_group_size attribute from frontend then set it
to backend.
V2: Refine the codeGenNum with runtime caclculate and fail the build if
the size from frontend is illegal.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/context.cpp       |  6 +-----
 backend/src/backend/gen_program.cpp   | 28 ++++++++++++++++++++--------
 backend/src/llvm/llvm_gen_backend.cpp | 24 ++++++++++++++++++++++++
 3 files changed, 45 insertions(+), 13 deletions(-)

diff --git a/backend/src/backend/context.cpp b/backend/src/backend/context.cpp
index e9ddd172..c9500c87 100644
--- a/backend/src/backend/context.cpp
+++ b/backend/src/backend/context.cpp
@@ -340,7 +340,6 @@ namespace gbe
   ///////////////////////////////////////////////////////////////////////////
   // Generic Context (shared by the simulator and the HW context)
   ///////////////////////////////////////////////////////////////////////////
-  IVAR(OCL_SIMD_WIDTH, 8, 15, 16);
 
   Context::Context(const ir::Unit &unit, const std::string &name) :
     unit(unit), fn(*unit.getFunction(name)), name(name), liveness(NULL), dag(NULL), useDWLabel(false)
@@ -361,10 +360,7 @@ namespace gbe
   }
 
   void Context::startNewCG(uint32_t simdWidth) {
-    if (simdWidth == 0 || OCL_SIMD_WIDTH != 15)
-      this->simdWidth = nextHighestPowerOf2(OCL_SIMD_WIDTH);
-    else
-      this->simdWidth = simdWidth;
+    this->simdWidth = simdWidth;
     GBE_SAFE_DELETE(this->registerAllocator);
     GBE_SAFE_DELETE(this->scratchAllocator);
     GBE_ASSERT(dag != NULL && liveness != NULL);
diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index 383f2f27..cfb23fed 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -59,6 +59,7 @@
 #include <clang/CodeGen/CodeGenAction.h>
 #endif
 
+#include "sys/cvar.hpp"
 #include <cstring>
 #include <sstream>
 #include <memory>
@@ -138,17 +139,24 @@ namespace gbe {
   }
 
   /*! We must avoid spilling at all cost with Gen */
-  static const struct CodeGenStrategy {
+  struct CodeGenStrategy {
     uint32_t simdWidth;
     uint32_t reservedSpillRegs;
     bool limitRegisterPressure;
-  } codeGenStrategy[] = {
+  };
+  static const struct CodeGenStrategy codeGenStrategyDefault[] = {
     {16, 0, false},
     {8, 0, false},
     {8, 8, false},
     {8, 16, false},
   };
+  static const struct CodeGenStrategy codeGenStrategySimd16[] = {
+    {16, 0, false},
+    {16, 8, false},
+    {16, 16, false},
+  };
 
+  IVAR(OCL_SIMD_WIDTH, 8, 15, 16);
   Kernel *GenProgram::compileKernel(const ir::Unit &unit, const std::string &name,
                                     bool relaxMath, int profiling) {
 #ifdef GBE_COMPILER_AVAILABLE
@@ -156,19 +164,23 @@ namespace gbe {
     // when the function already provides the simd width we need to use (i.e.
     // non zero)
     const ir::Function *fn = unit.getFunction(name);
+    const struct CodeGenStrategy* codeGenStrategy = codeGenStrategyDefault;
     if(fn == NULL)
       GBE_ASSERT(0);
-    uint32_t codeGenNum = sizeof(codeGenStrategy) / sizeof(codeGenStrategy[0]);
+    uint32_t codeGenNum = sizeof(codeGenStrategyDefault) / sizeof(codeGenStrategyDefault[0]);
     uint32_t codeGen = 0;
     GenContext *ctx = NULL;
-    if (fn->getSimdWidth() == 8) {
+    if ( fn->getSimdWidth() != 0 && OCL_SIMD_WIDTH != 15) {
+      GBE_ASSERTM(0, "unsupported SIMD width!");
+    }else if (fn->getSimdWidth() == 8 || OCL_SIMD_WIDTH == 8) {
       codeGen = 1;
-    } else if (fn->getSimdWidth() == 16) {
-      codeGenNum = 1;
-    } else if (fn->getSimdWidth() == 0) {
+    } else if (fn->getSimdWidth() == 16 || OCL_SIMD_WIDTH == 16){
+      codeGenStrategy = codeGenStrategySimd16;
+      codeGenNum = sizeof(codeGenStrategySimd16) / sizeof(codeGenStrategySimd16[0]);
+    } else if (fn->getSimdWidth() == 0 && OCL_SIMD_WIDTH == 15) {
       codeGen = 0;
     } else
-      GBE_ASSERT(0);
+      GBE_ASSERTM(0, "unsupported SIMD width!");
     Kernel *kernel = NULL;
 
     // Stop when compilation is successful
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 2ce37f4a..55b0abbd 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -2123,6 +2123,7 @@ namespace gbe
     // Loop over the kernel metadatas to set the required work group size.
     size_t reqd_wg_sz[3] = {0, 0, 0};
     size_t hint_wg_sz[3] = {0, 0, 0};
+    size_t reqd_sg_sz = 0;
     ir::FunctionArgument::InfoFromLLVM llvmInfo;
     MDNode *addrSpaceNode = NULL;
     MDNode *typeNameNode = NULL;
@@ -2218,6 +2219,27 @@ namespace gbe
       functionAttributes += buffer;
       functionAttributes += " ";
     }
+    if ((attrNode = F.getMetadata("intel_reqd_sub_group_size"))) {
+      GBE_ASSERT(attrNode->getNumOperands() == 1);
+      ConstantInt *sz = mdconst::extract<ConstantInt>(attrNode->getOperand(0));
+      GBE_ASSERT(sz);
+      reqd_sg_sz = sz->getZExtValue();
+      if(!(reqd_sg_sz == 8 || reqd_sg_sz == 16)){
+        F.getContext().emitError("Required sub group size is illegal!");
+        ctx.getUnit().setValid(false);
+        return;
+      }
+      functionAttributes += "intel_reqd_sub_group_size";
+      std::stringstream param;
+      char buffer[100] = {0};
+      param << "(";
+      param << reqd_sg_sz;
+      param << ")";
+      param >> buffer;
+      functionAttributes += buffer;
+      functionAttributes += " ";
+    }
+
 #else
     /* First find the meta data belong to this function. */
     MDNode *node = getKernelFunctionMetadata(&F);
@@ -2343,6 +2365,8 @@ namespace gbe
 #endif /* LLVM 3.9 Function metadata */
 
     ctx.getFunction().setCompileWorkGroupSize(reqd_wg_sz[0], reqd_wg_sz[1], reqd_wg_sz[2]);
+    if (reqd_sg_sz)
+      ctx.setSimdWidth(reqd_sg_sz);
 
     ctx.getFunction().setFunctionAttributes(functionAttributes);
     // Loop over the arguments and output registers for them

From 209b3b86f6f8ea405896e85d6e22a16c76d57403 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Thu, 15 Jun 2017 16:44:49 +0800
Subject: [PATCH 33/52] Runtime: Add new API enums for
 cl_intel_required_subgroup_size extension

Add CL_DEVICE_SUB_GROUP_SIZES_INTEL for clGetDeviceInfo, add
CL_KERNEL_SPILL_MEM_SIZE_INTEL for clGetKernelWorkGroupInfo and add
CL_KERNEL_COMPILE_SUB_GROUP_SIZE_INTEL for clGetKernelSubGroupInfo.
We only have this extension for LLVM 40+ for frontend support.
V2: Add opencl-c define

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/libocl/include/ocl.h |  4 ++++
 include/CL/cl_intel.h            |  6 ++++++
 src/cl_device_id.c               | 27 +++++++++++++++++++++++++++
 src/cl_device_id.h               |  2 ++
 src/cl_extensions.c              |  8 ++++++++
 src/cl_extensions.h              |  3 ++-
 src/cl_gt_device.h               |  2 ++
 7 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/backend/src/libocl/include/ocl.h b/backend/src/libocl/include/ocl.h
index 2548cb79..5408048d 100644
--- a/backend/src/libocl/include/ocl.h
+++ b/backend/src/libocl/include/ocl.h
@@ -124,6 +124,10 @@
 #define cl_intel_subgroups
 #define cl_intel_subgroups_short
 
+#if __clang_major__*10 + __clang_minor__ > 40
+#define cl_intel_required_subgroup_size
+#endif
+
 #pragma OPENCL EXTENSION cl_khr_fp64 : disable
 #pragma OPENCL EXTENSION cl_khr_fp16 : disable
 #endif
diff --git a/include/CL/cl_intel.h b/include/CL/cl_intel.h
index 47bae46f..3cb85151 100644
--- a/include/CL/cl_intel.h
+++ b/include/CL/cl_intel.h
@@ -197,6 +197,12 @@ typedef CL_API_ENTRY cl_int
 						      void* /*param_value*/,
 						      size_t* /*param_value_size_ret*/ );
 #endif
+
+/* cl_intel_required_subgroup_size extension*/
+#define CL_DEVICE_SUB_GROUP_SIZES_INTEL                 0x4108
+#define CL_KERNEL_SPILL_MEM_SIZE_INTEL                  0x4109
+#define CL_KERNEL_COMPILE_SUB_GROUP_SIZE_INTEL          0x410A
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/cl_device_id.c b/src/cl_device_id.c
index 1ed99625..3c7bb48e 100644
--- a/src/cl_device_id.c
+++ b/src/cl_device_id.c
@@ -1375,6 +1375,10 @@ cl_get_device_info(cl_device_id     device,
       src_ptr = device->driver_version;
       src_size = device->driver_version_sz;
       break;
+    case CL_DEVICE_SUB_GROUP_SIZES_INTEL:
+      src_ptr = device->sub_group_sizes;
+      src_size = device->sub_group_sizes_sz;
+      break;
 
     default:
       return CL_INVALID_VALUE;
@@ -1518,6 +1522,7 @@ cl_get_kernel_workgroup_info(cl_kernel kernel,
     DECL_FIELD(COMPILE_WORK_GROUP_SIZE, kernel->compile_wg_sz)
     DECL_FIELD(PRIVATE_MEM_SIZE, kernel->stack_size)
     case CL_KERNEL_GLOBAL_WORK_SIZE:
+    {
       dimension = cl_check_builtin_kernel_dimension(kernel, device);
       if ( !dimension ) return CL_INVALID_VALUE;
       if (param_value_size_ret != NULL)
@@ -1535,6 +1540,18 @@ cl_get_kernel_workgroup_info(cl_kernel kernel,
         return CL_SUCCESS;
       }
       return CL_SUCCESS;
+    }
+    case CL_KERNEL_SPILL_MEM_SIZE_INTEL:
+    {
+      if (param_value && param_value_size < sizeof(cl_ulong))
+        return CL_INVALID_VALUE;
+      if (param_value_size_ret != NULL)
+        *param_value_size_ret = sizeof(cl_ulong);
+      if (param_value)
+        *(cl_ulong*)param_value = (cl_ulong)interp_kernel_get_scratch_size(kernel->opaque);
+      return CL_SUCCESS;
+    }
+
     default:
       return CL_INVALID_VALUE;
   };
@@ -1618,6 +1635,16 @@ cl_get_kernel_subgroup_info(cl_kernel kernel,
       }
       break;
     }
+    case CL_KERNEL_COMPILE_SUB_GROUP_SIZE_INTEL:
+    {
+      if (param_value && param_value_size < sizeof(size_t))
+        return CL_INVALID_VALUE;
+      if (param_value_size_ret != NULL)
+        *param_value_size_ret = sizeof(size_t);
+      if (param_value)
+        *(size_t*)param_value = interp_kernel_get_simd_width(kernel->opaque);
+      return CL_SUCCESS;
+    }
     default:
       return CL_INVALID_VALUE;
   };
diff --git a/src/cl_device_id.h b/src/cl_device_id.h
index 6b8f2ebe..93bd2f1f 100644
--- a/src/cl_device_id.h
+++ b/src/cl_device_id.h
@@ -136,6 +136,8 @@ struct _cl_device_id {
   uint32_t atomic_test_result;
   cl_uint image_pitch_alignment;
   cl_uint image_base_address_alignment;
+  size_t sub_group_sizes[2];
+  size_t sub_group_sizes_sz;
 
   //inited as NULL, created only when cmrt kernel is used
   void* cmrt_device;  //realtype: CmDevice*
diff --git a/src/cl_extensions.c b/src/cl_extensions.c
index d49d202f..56099ad0 100644
--- a/src/cl_extensions.c
+++ b/src/cl_extensions.c
@@ -69,8 +69,16 @@ check_intel_extension(cl_extensions_t *extensions)
 {
   int id;
   for(id = INTEL_EXT_START_ID; id <= INTEL_EXT_END_ID; id++)
+  {
     if(id != EXT_ID(intel_motion_estimation))
       extensions->extensions[id].base.ext_enabled = 1;
+    if(id == EXT_ID(intel_required_subgroup_size))
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR > 40
+      extensions->extensions[id].base.ext_enabled = 1;
+#else
+      extensions->extensions[id].base.ext_enabled = 0;
+#endif
+  }
 }
 
 void
diff --git a/src/cl_extensions.h b/src/cl_extensions.h
index 52a49531..e6c64ba0 100644
--- a/src/cl_extensions.h
+++ b/src/cl_extensions.h
@@ -29,7 +29,8 @@
   DECL_EXT(intel_accelerator) \
   DECL_EXT(intel_motion_estimation) \
   DECL_EXT(intel_subgroups) \
-  DECL_EXT(intel_subgroups_short)
+  DECL_EXT(intel_subgroups_short) \
+  DECL_EXT(intel_required_subgroup_size)
 
 #define DECL_GL_EXTENSIONS \
   DECL_EXT(khr_gl_sharing)\
diff --git a/src/cl_gt_device.h b/src/cl_gt_device.h
index ca4f3c57..f6cb5f82 100644
--- a/src/cl_gt_device.h
+++ b/src/cl_gt_device.h
@@ -153,4 +153,6 @@ DECL_INFO_STRING(spir_versions, "1.2")
 .partition_type = {0},
 .image_pitch_alignment = 1,
 .image_base_address_alignment = 4096,
+.sub_group_sizes = {8, 16},
+.sub_group_sizes_sz = sizeof(size_t) * 2,
 .cmrt_device = NULL

From 134e1cbe90f39aa93dfe9a8e7095a40e30c92339 Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Thu, 15 Jun 2017 16:44:50 +0800
Subject: [PATCH 34/52] Utset: Add test case for
 cl_intel_required_subgroup_size extension

Check the device supported subgroup sizes, and use
intel_reqd_sub_group_size to build kernels in these size. Then check if
there is spill for each kernel.
V2: Fix memory leak

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 kernels/compiler_reqd_sub_group_size.cl |  5 ++++
 utests/CMakeLists.txt                   |  1 +
 utests/compiler_reqd_sub_group_size.cpp | 46 +++++++++++++++++++++++++++++++++
 utests/utest_helper.cpp                 | 20 ++++++++++++++
 utests/utest_helper.hpp                 |  3 +++
 5 files changed, 75 insertions(+)
 create mode 100644 kernels/compiler_reqd_sub_group_size.cl
 create mode 100644 utests/compiler_reqd_sub_group_size.cpp

diff --git a/kernels/compiler_reqd_sub_group_size.cl b/kernels/compiler_reqd_sub_group_size.cl
new file mode 100644
index 00000000..0ce70e9c
--- /dev/null
+++ b/kernels/compiler_reqd_sub_group_size.cl
@@ -0,0 +1,5 @@
+__attribute__((intel_reqd_sub_group_size(SIMD_SIZE)))
+__kernel void compiler_reqd_sub_group_size(global int* src)
+{
+
+}
diff --git a/utests/CMakeLists.txt b/utests/CMakeLists.txt
index 6b556788..300d87a4 100644
--- a/utests/CMakeLists.txt
+++ b/utests/CMakeLists.txt
@@ -283,6 +283,7 @@ set (utests_sources
   compiler_sub_group_shuffle_down.cpp
   compiler_sub_group_shuffle_up.cpp
   compiler_sub_group_shuffle_xor.cpp
+  compiler_reqd_sub_group_size.cpp
   builtin_global_linear_id.cpp
   builtin_local_linear_id.cpp
   multi_queue_events.cpp
diff --git a/utests/compiler_reqd_sub_group_size.cpp b/utests/compiler_reqd_sub_group_size.cpp
new file mode 100644
index 00000000..37d96fe5
--- /dev/null
+++ b/utests/compiler_reqd_sub_group_size.cpp
@@ -0,0 +1,46 @@
+#include "utest_helper.hpp"
+#include<string>
+#include<sstream>
+#include<iostream>
+
+using namespace std;
+
+void compiler_reqd_sub_group_size(void)
+{
+  if (!cl_check_reqd_subgroup())
+    return;
+
+  size_t param_value_size;
+  OCL_CALL(clGetDeviceInfo, device, CL_DEVICE_SUB_GROUP_SIZES_INTEL,
+           0, NULL, &param_value_size);
+
+  size_t* param_value = new size_t[param_value_size];
+  OCL_CALL(clGetDeviceInfo, device, CL_DEVICE_SUB_GROUP_SIZES_INTEL,
+           param_value_size, param_value, NULL);
+
+  const char* opt = "-D SIMD_SIZE=";
+  for( uint32_t i = 0; i < param_value_size / sizeof(size_t) ; ++i)
+  {
+    ostringstream ss;
+    uint32_t simd_size = param_value[i];
+    ss << opt << simd_size;
+    //cout << "options: " << ss.str() << endl;
+    OCL_CALL(cl_kernel_init, "compiler_reqd_sub_group_size.cl", "compiler_reqd_sub_group_size",
+                             SOURCE, ss.str().c_str());
+    size_t SIMD_SIZE = 0;
+    OCL_CALL(utestclGetKernelSubGroupInfoKHR,kernel,device, CL_KERNEL_COMPILE_SUB_GROUP_SIZE_INTEL,0, NULL,sizeof(size_t),&SIMD_SIZE,NULL);
+    //cout << SIMD_SIZE << " with " << simd_size << endl;
+    OCL_ASSERT(SIMD_SIZE == simd_size);
+
+    cl_ulong SPILL_SIZE = 0xFFFFFFFF;
+    OCL_CALL(clGetKernelWorkGroupInfo, kernel, device, CL_KERNEL_SPILL_MEM_SIZE_INTEL, sizeof(cl_ulong), &SPILL_SIZE, NULL);
+    //cout << "spill size: " << SPILL_SIZE << endl;
+    OCL_ASSERT(SPILL_SIZE == 0);
+
+    clReleaseProgram(program);
+    program = NULL;
+  }
+  delete[] param_value;
+}
+
+MAKE_UTEST_FROM_FUNCTION(compiler_reqd_sub_group_size);
diff --git a/utests/utest_helper.cpp b/utests/utest_helper.cpp
index 7052a149..4dae20dc 100644
--- a/utests/utest_helper.cpp
+++ b/utests/utest_helper.cpp
@@ -1119,3 +1119,23 @@ float as_float(uint32_t i)
   _tmp._uint = i;
   return _tmp._float;
 }
+
+int cl_check_reqd_subgroup(void)
+{
+  if (!cl_check_subgroups())
+    return 0;
+  std::string extStr;
+  size_t param_value_size;
+  OCL_CALL(clGetDeviceInfo, device, CL_DEVICE_EXTENSIONS, 0, 0, &param_value_size);
+  std::vector<char> param_value(param_value_size);
+  OCL_CALL(clGetDeviceInfo, device, CL_DEVICE_EXTENSIONS, param_value_size,
+           param_value.empty() ? NULL : &param_value.front(), &param_value_size);
+  if (!param_value.empty())
+    extStr = std::string(&param_value.front(), param_value_size-1);
+
+  if (std::strstr(extStr.c_str(), "cl_intel_required_subgroup_size") == NULL) {
+    printf("No cl_intel_required_subgroup_size, Skip!");
+    return 0;
+  }
+  return 1;
+}
diff --git a/utests/utest_helper.hpp b/utests/utest_helper.hpp
index e2a6a884..19ec69d6 100644
--- a/utests/utest_helper.hpp
+++ b/utests/utest_helper.hpp
@@ -325,4 +325,7 @@ extern float as_float(uint32_t i);
 extern uint32_t as_uint(float f);
 /* Check is intel subgroups short enabled. */
 extern int cl_check_subgroups_short(void);
+
+/* Check is intel_required_subgroup_size enabled. */
+extern int cl_check_reqd_subgroup(void);
 #endif /* __UTEST_HELPER_HPP__ */

From 35cd19b92bbff658d47639bbc0dc34a85d88a3f6 Mon Sep 17 00:00:00 2001
From: "rander.wang" <rander.wang@intel.com>
Date: Thu, 15 Jun 2017 09:47:35 +0800
Subject: [PATCH 35/52] backend: refine the local copy propagation.

src modifier is not supported by some instructions.
so return false when it exists. This fix piglit %
scalar-arithmetic-int failed

V2: (1)add hadd rhadd
    (2)confirmed math functions support midifer except IDIV/Mod

Signed-off-by: rander.wang <rander.wang@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 .../src/backend/gen_insn_selection_optimize.cpp    | 34 ++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/backend/src/backend/gen_insn_selection_optimize.cpp b/backend/src/backend/gen_insn_selection_optimize.cpp
index 07547ec4..af5ecc2b 100644
--- a/backend/src/backend/gen_insn_selection_optimize.cpp
+++ b/backend/src/backend/gen_insn_selection_optimize.cpp
@@ -189,6 +189,40 @@ namespace gbe
     if (insn.opcode == SEL_OP_BSWAP) //should remove once bswap issue is fixed
       return false;
 
+    //the src modifier is not supported by the following instructions
+    if(info->replacement.negation || info->replacement.absolute)
+    {
+      switch(insn.opcode)
+      {
+        case SEL_OP_MATH:
+        {
+          switch(insn.extra.function)
+          {
+            case GEN_MATH_FUNCTION_INT_DIV_QUOTIENT:
+            case GEN_MATH_FUNCTION_INT_DIV_REMAINDER:
+            case GEN_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER:
+              return false;
+            default:
+              break;
+          }
+
+          break;
+        }
+        case SEL_OP_CBIT:
+        case SEL_OP_FBH:
+        case SEL_OP_FBL:
+        case SEL_OP_BRC:
+        case SEL_OP_BRD:
+        case SEL_OP_BFREV:
+        case SEL_OP_LZD:
+        case SEL_OP_HADD:
+        case SEL_OP_RHADD:
+          return false;
+        default:
+          break;
+      }
+    }
+
     if (insn.isWrite() || insn.isRead()) //register in selection vector
       return false;
 

From cacd3942aad96b6f3524414750e2b4fc6224c5c7 Mon Sep 17 00:00:00 2001
From: Patrick Beaulieu <patrick.beaulieu@avigilon.com>
Date: Thu, 15 Jun 2017 23:15:15 +0000
Subject: [PATCH 36/52] Fix context leak with internal kernels

Account for internal program ctx references in cl_context_delete

Signed-off-by: Patrick Beaulieu <patrick.beaulieu@avigilon.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 src/cl_context.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/src/cl_context.c b/src/cl_context.c
index 1ba23024..72f8b64a 100644
--- a/src/cl_context.c
+++ b/src/cl_context.c
@@ -358,10 +358,25 @@ cl_context_delete(cl_context ctx)
   if (UNLIKELY(ctx == NULL))
     return;
 
+  int internal_ctx_refs = 1;
+  // determine how many ctx refs are held by internal_prgs and built_in_prgs
+  for (i = CL_INTERNAL_KERNEL_MIN; i < CL_INTERNAL_KERNEL_MAX; i++) {
+    if (ctx->internal_kernels[i] && ctx->internal_prgs[i])
+      ++internal_ctx_refs;
+  }
+
+  if (ctx->built_in_prgs)
+    ++internal_ctx_refs;
+
   /* We are not done yet */
-  if (CL_OBJECT_DEC_REF(ctx) > 1)
+  if (CL_OBJECT_DEC_REF(ctx) > internal_ctx_refs)
     return;
 
+  // create a temporary extra ref here so cl_program_delete doesn't
+  // attempt a recursive full cl_context_delete when cleaning up
+  // our internal programs
+  CL_OBJECT_INC_REF(ctx);
+
   /* delete the internal programs. */
   for (i = CL_INTERNAL_KERNEL_MIN; i < CL_INTERNAL_KERNEL_MAX; i++) {
     if (ctx->internal_kernels[i]) {
@@ -382,6 +397,8 @@ cl_context_delete(cl_context ctx)
   cl_program_delete(ctx->built_in_prgs);
   ctx->built_in_prgs = NULL;
 
+  CL_OBJECT_DEC_REF(ctx);
+
   cl_free(ctx->prop_user);
   cl_free(ctx->devices);
   cl_driver_delete(ctx->drv);

From 3f7206904b8e93c70f1b8c142888b1fc61f8d0b1 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Tue, 20 Jun 2017 19:07:45 +0800
Subject: [PATCH 37/52] Runtime: fix a recurrent release context error.

Before release internal resources, must set them to null, otherwize,
when delete these resources, will call release context again.
The ctx->built_in_prgs should be release by application.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/cl_context.c | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)

diff --git a/src/cl_context.c b/src/cl_context.c
index 72f8b64a..6cd9d66e 100644
--- a/src/cl_context.c
+++ b/src/cl_context.c
@@ -365,9 +365,6 @@ cl_context_delete(cl_context ctx)
       ++internal_ctx_refs;
   }
 
-  if (ctx->built_in_prgs)
-    ++internal_ctx_refs;
-
   /* We are not done yet */
   if (CL_OBJECT_DEC_REF(ctx) > internal_ctx_refs)
     return;
@@ -380,23 +377,23 @@ cl_context_delete(cl_context ctx)
   /* delete the internal programs. */
   for (i = CL_INTERNAL_KERNEL_MIN; i < CL_INTERNAL_KERNEL_MAX; i++) {
     if (ctx->internal_kernels[i]) {
-      cl_kernel_delete(ctx->internal_kernels[i]);
+      cl_kernel k = ctx->internal_kernels[i];
       ctx->internal_kernels[i] = NULL;
+      cl_kernel_delete(k);
 
       assert(ctx->internal_prgs[i]);
-      cl_program_delete(ctx->internal_prgs[i]);
+      cl_program p = ctx->internal_prgs[i];
       ctx->internal_prgs[i] = NULL;
+      cl_program_delete(p);
     }
 
     if (ctx->built_in_kernels[i]) {
-      cl_kernel_delete(ctx->built_in_kernels[i]);
+      cl_kernel k = ctx->built_in_kernels[i];
       ctx->built_in_kernels[i] = NULL;
+      cl_kernel_delete(k);
     }
   }
 
-  cl_program_delete(ctx->built_in_prgs);
-  ctx->built_in_prgs = NULL;
-
   CL_OBJECT_DEC_REF(ctx);
 
   cl_free(ctx->prop_user);

From a2b44838ef04092f544ade71654321a76be39eb4 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Tue, 20 Jun 2017 19:07:46 +0800
Subject: [PATCH 38/52] Utest: fix a build-in program leak.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 utests/enqueue_built_in_kernels.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/utests/enqueue_built_in_kernels.cpp b/utests/enqueue_built_in_kernels.cpp
index 52b8848b..2afbabd5 100644
--- a/utests/enqueue_built_in_kernels.cpp
+++ b/utests/enqueue_built_in_kernels.cpp
@@ -14,6 +14,7 @@ void enqueue_built_in_kernels(void)
   OCL_ASSERT(ret_sz == built_in_kernels_size);
   cl_program built_in_prog = clCreateProgramWithBuiltInKernels(ctx, 1, &device, built_in_kernel_names, &err);
   OCL_ASSERT(built_in_prog != NULL);
+  clReleaseProgram(built_in_prog);
 }
 
 MAKE_UTEST_FROM_FUNCTION(enqueue_built_in_kernels);

From 9b1149d6ed7ace2cf7cf37d3658d4e65efa85d04 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Tue, 20 Jun 2017 19:07:47 +0800
Subject: [PATCH 39/52] Runtime: remove ctx's useless fileds.

built_in_prgs and built_in_kernels seems useless, remove them.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/cl_context.c |  6 ------
 src/cl_context.h |  2 --
 src/cl_program.c | 40 +++++-----------------------------------
 3 files changed, 5 insertions(+), 43 deletions(-)

diff --git a/src/cl_context.c b/src/cl_context.c
index 6cd9d66e..0fe78a9d 100644
--- a/src/cl_context.c
+++ b/src/cl_context.c
@@ -386,12 +386,6 @@ cl_context_delete(cl_context ctx)
       ctx->internal_prgs[i] = NULL;
       cl_program_delete(p);
     }
-
-    if (ctx->built_in_kernels[i]) {
-      cl_kernel k = ctx->built_in_kernels[i];
-      ctx->built_in_kernels[i] = NULL;
-      cl_kernel_delete(k);
-    }
   }
 
   CL_OBJECT_DEC_REF(ctx);
diff --git a/src/cl_context.h b/src/cl_context.h
index 4812afd1..a46f2f59 100644
--- a/src/cl_context.h
+++ b/src/cl_context.h
@@ -120,8 +120,6 @@ struct _cl_context {
                                     /* All programs internal used, for example clEnqueuexxx api use */
   cl_kernel  internal_kernels[CL_INTERNAL_KERNEL_MAX];
                                     /* All kernels  for clenqueuexxx api, for example clEnqueuexxx api use */
-  cl_program built_in_prgs;  /*all built-in kernels belongs to this program only*/
-  cl_kernel  built_in_kernels[CL_INTERNAL_KERNEL_MAX];
   uint32_t ver;                     /* Gen version */
   struct _cl_context_prop props;
   cl_context_properties * prop_user; /* a copy of user passed context properties when create context */
diff --git a/src/cl_program.c b/src/cl_program.c
index bb96d98f..3ae0486d 100644
--- a/src/cl_program.c
+++ b/src/cl_program.c
@@ -382,54 +382,24 @@ cl_program_create_with_built_in_kernles(cl_context     ctx,
   extern size_t cl_internal_built_in_kernel_str_size;
   char* p_built_in_kernel_str =cl_internal_built_in_kernel_str;
 
-  ctx->built_in_prgs = cl_program_create_from_binary(ctx, 1,
+  cl_program built_in_prgs = cl_program_create_from_binary(ctx, 1,
                                                           &ctx->devices[0],
                                                           (size_t*)&cl_internal_built_in_kernel_str_size,
                                                           (const unsigned char **)&p_built_in_kernel_str,
                                                           &binary_status, &err);
-  if (!ctx->built_in_prgs)
+  if (!built_in_prgs)
     return NULL;
 
-  err = cl_program_build(ctx->built_in_prgs, NULL);
+  err = cl_program_build(built_in_prgs, NULL);
   if (err != CL_SUCCESS)
     return NULL;
 
-  ctx->built_in_prgs->is_built = 1;
-
-  char delims[] = ";";
-  char* saveptr = NULL;
-  char* local_kernel_names;
-  char* kernel = NULL;
-  char* matched_kernel;
-  int i = 0;
-
-  //copy the content to local_kernel_names to protect the kernel_names.
-  TRY_ALLOC(local_kernel_names, cl_calloc(strlen(kernel_names)+1, sizeof(char) ) );
-  memcpy(local_kernel_names, kernel_names, strlen(kernel_names)+1);
-
-  kernel = strtok_r( local_kernel_names, delims , &saveptr);
-  while( kernel != NULL ) {
-    matched_kernel = strstr(ctx->devices[0]->built_in_kernels, kernel);
-    if(matched_kernel){
-      for (i = 0; i < ctx->built_in_prgs->ker_n; ++i) {
-        assert(ctx->built_in_prgs->ker[i]);
-        const char *ker_name = cl_kernel_get_name(ctx->built_in_prgs->ker[i]);
-        if (ker_name != NULL && strcmp(ker_name, kernel) == 0) {
-          break;
-        }
-      }
-
-      ctx->built_in_kernels[i] = cl_program_create_kernel(ctx->built_in_prgs, kernel, NULL);
-    }
-    kernel = strtok_r((char*)saveptr , delims, &saveptr );
-  }
-
-  cl_free(local_kernel_names);
+  built_in_prgs->is_built = 1;
 
 exit:
   if (errcode_ret)
     *errcode_ret = err;
-  return ctx->built_in_prgs;
+  return built_in_prgs;
 error:
   goto exit;
 

From c64a7f7c19c27e65180acb1008d9c3fb3412fecf Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Wed, 14 Jun 2017 11:40:34 +0800
Subject: [PATCH 40/52] Runtime: Add missing SKL deivce ID

It seems we missed some newly added device ID for SKL.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 src/cl_device_data.h | 6 +++++-
 src/cl_device_id.c   | 4 ++++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/cl_device_data.h b/src/cl_device_data.h
index c3d6c45f..123b6192 100644
--- a/src/cl_device_data.h
+++ b/src/cl_device_data.h
@@ -247,7 +247,9 @@
 /* SKL */
 #define PCI_CHIP_SKYLAKE_ULT_GT1	0x1906   /* Intel(R) Skylake ULT - GT1 */
 #define PCI_CHIP_SKYLAKE_ULT_GT2	0x1916   /* Intel(R) Skylake ULT - GT2 */
-#define PCI_CHIP_SKYLAKE_ULT_GT3	0x1926   /* Intel(R) Skylake ULT - GT3 */
+#define PCI_CHIP_SKYLAKE_ULT_GT3	0x1923   /* Intel(R) Skylake ULT - GT3 */
+#define PCI_CHIP_SKYLAKE_ULT_GT3E1	0x1926   /* Intel(R) Skylake ULT - GT3E */
+#define PCI_CHIP_SKYLAKE_ULT_GT3E2	0x1927   /* Intel(R) Skylake ULT - GT3E */
 #define PCI_CHIP_SKYLAKE_ULT_GT2F	0x1921   /* Intel(R) Skylake ULT - GT2F */
 #define PCI_CHIP_SKYLAKE_ULX_GT1	0x190E   /* Intel(R) Skylake ULX - GT1 */
 #define PCI_CHIP_SKYLAKE_ULX_GT2	0x191E   /* Intel(R) Skylake ULX - GT2 */
@@ -284,6 +286,8 @@
 
 #define IS_SKL_GT3(devid)               \
   (devid == PCI_CHIP_SKYLAKE_ULT_GT3 ||   \
+   devid == PCI_CHIP_SKYLAKE_ULT_GT3E1 ||   \
+   devid == PCI_CHIP_SKYLAKE_ULT_GT3E2 ||   \
    devid == PCI_CHIP_SKYLAKE_HALO_GT3 || \
    devid == PCI_CHIP_SKYLAKE_SRV_GT3 || \
    devid == PCI_CHIP_SKYLAKE_MEDIA_SRV_GT3)
diff --git a/src/cl_device_id.c b/src/cl_device_id.c
index 3c7bb48e..76e77d72 100644
--- a/src/cl_device_id.c
+++ b/src/cl_device_id.c
@@ -605,6 +605,10 @@ skl_gt2_break:
 
     case PCI_CHIP_SKYLAKE_ULT_GT3:
       DECL_INFO_STRING(skl_gt3_break, intel_skl_gt3_device, name, "Intel(R) HD Graphics Skylake ULT GT3");
+    case PCI_CHIP_SKYLAKE_ULT_GT3E1:
+      DECL_INFO_STRING(skl_gt3_break, intel_skl_gt3_device, name, "Intel(R) HD Graphics Skylake ULT GT3E");
+    case PCI_CHIP_SKYLAKE_ULT_GT3E2:
+      DECL_INFO_STRING(skl_gt3_break, intel_skl_gt3_device, name, "Intel(R) HD Graphics Skylake ULT GT3E");
     case PCI_CHIP_SKYLAKE_HALO_GT3:
       DECL_INFO_STRING(skl_gt3_break, intel_skl_gt3_device, name, "Intel(R) HD Graphics Skylake Halo GT3");
     case PCI_CHIP_SKYLAKE_SRV_GT3:

From 5682ef0fe85366980d31b38e9d065793c1cf2e5a Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Thu, 22 Jun 2017 17:38:55 +0800
Subject: [PATCH 41/52] GBE: clean llvm module's clone and release.

There are some changes:
1. Clone the module before call LLVMLinkModules2, remove other
clones for it.
2. Don't delete module in function llvmToGen.
3. Add a function programNewFromLLVMFile so genProgramNewFromLLVM
and buildFromLLVMModule only handle llvm module. Actually,
programNewFromLLVMFile is only used by clCreateProgramWithLLVMIntel,
and I think it is useless, maybe we could delete it at all.

V2: define errDiag beside #if/#endif.
Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Pan Xiuli <xiuli.pan@intel.com>
---
 backend/src/backend/gen_program.cpp    |  5 +-
 backend/src/backend/program.cpp        | 83 +++++++++++++++++++++-------------
 backend/src/backend/program.h          | 10 +++-
 backend/src/backend/program.hpp        |  4 +-
 backend/src/llvm/llvm_bitcode_link.cpp |  3 +-
 backend/src/llvm/llvm_to_gen.cpp       | 19 +-------
 backend/src/llvm/llvm_to_gen.hpp       |  2 +-
 src/cl_gbe_loader.cpp                  |  5 ++
 src/cl_gbe_loader.h                    |  1 +
 src/cl_program.c                       |  2 +-
 10 files changed, 76 insertions(+), 58 deletions(-)

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index cfb23fed..bb1d22fa 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -455,7 +455,6 @@ namespace gbe {
   }
 
   static gbe_program genProgramNewFromLLVM(uint32_t deviceID,
-                                           const char *fileName,
                                            const void* module,
                                            const void* llvm_ctx,
                                            const char* asm_file_name,
@@ -475,7 +474,7 @@ namespace gbe {
 #ifdef GBE_COMPILER_AVAILABLE
     std::string error;
     // Try to compile the program
-    if (program->buildFromLLVMFile(fileName, module, error, optLevel) == false) {
+    if (program->buildFromLLVMModule(module, error, optLevel) == false) {
       if (err != NULL && errSize != NULL && stringSize > 0u) {
         const size_t msgSize = std::min(error.size(), stringSize-1u);
         std::memcpy(err, error.c_str(), msgSize);
@@ -598,7 +597,7 @@ namespace gbe {
     acquireLLVMContextLock();
     llvm::Module* module = (llvm::Module*)p->module;
 
-    if (p->buildFromLLVMFile(NULL, module, error, optLevel) == false) {
+    if (p->buildFromLLVMModule(module, error, optLevel) == false) {
       if (err != NULL && errSize != NULL && stringSize > 0u) {
         const size_t msgSize = std::min(error.size(), stringSize-1u);
         std::memcpy(err, error.c_str(), msgSize);
diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index 724058c6..c06ae5a1 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -40,6 +40,7 @@
 #include "llvm/Support/ManagedStatic.h"
 #include "llvm/Transforms/Utils/Cloning.h"
 #include "llvm/IR/LLVMContext.h"
+#include "llvm/IRReader/IRReader.h"
 #endif
 
 #include <cstring>
@@ -113,32 +114,17 @@ namespace gbe {
   IVAR(OCL_PROFILING_LOG, 0, 0, 1); // Int for different profiling types.
   BVAR(OCL_OUTPUT_BUILD_LOG, false);
 
-  bool Program::buildFromLLVMFile(const char *fileName,
-                                         const void* module,
-                                         std::string &error,
-                                         int optLevel) {
+  bool Program::buildFromLLVMModule(const void* module,
+                                              std::string &error,
+                                              int optLevel) {
     ir::Unit *unit = new ir::Unit();
-    llvm::Module * cloned_module = NULL;
     bool ret = false;
-    if(module){
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
-      cloned_module = llvm::CloneModule((llvm::Module*)module).release();
-#else
-      cloned_module = llvm::CloneModule((llvm::Module*)module);
-#endif
-    }
+
     bool strictMath = true;
     if (fast_relaxed_math || !OCL_STRICT_CONFORMANCE)
       strictMath = false;
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-    llvm::Module * linked_module = module ? llvm::CloneModule((llvm::Module*)module).release() : NULL;
-    // Src now will be removed automatically. So clone it.
-    if (llvmToGen(*unit, fileName, linked_module, optLevel, strictMath, OCL_PROFILING_LOG, error) == false) {
-#else
-    if (llvmToGen(*unit, fileName, module, optLevel, strictMath, OCL_PROFILING_LOG, error) == false) {
-#endif
-      if (fileName)
-        error = std::string(fileName) + " not found";
+
+    if (llvmToGen(*unit, module, optLevel, strictMath, OCL_PROFILING_LOG, error) == false) {
       delete unit;
       return false;
     }
@@ -147,13 +133,8 @@ namespace gbe {
     if(!unit->getValid()) {
       delete unit;   //clear unit
       unit = new ir::Unit();
-      if(cloned_module){
-        //suppose file exists and llvmToGen will not return false.
-        llvmToGen(*unit, fileName, cloned_module, 0, strictMath, OCL_PROFILING_LOG, error);
-      }else{
-        //suppose file exists and llvmToGen will not return false.
-        llvmToGen(*unit, fileName, module, 0, strictMath, OCL_PROFILING_LOG, error);
-      }
+      //suppose file exists and llvmToGen will not return false.
+      llvmToGen(*unit, module, 0, strictMath, OCL_PROFILING_LOG, error);
     }
     if(unit->getValid()){
       std::string error2;
@@ -163,9 +144,6 @@ namespace gbe {
       error = error + error2;
     }
     delete unit;
-    if(cloned_module){
-      delete (llvm::Module*) cloned_module;
-    }
     return ret;
   }
 
@@ -1094,7 +1072,7 @@ EXTEND_QUOTE:
           fclose(asmDumpStream);
       }
 
-      p = gbe_program_new_from_llvm(deviceID, NULL, out_module, llvm_ctx,
+      p = gbe_program_new_from_llvm(deviceID, out_module, llvm_ctx,
                                     dumpASMFileName.empty() ? NULL : dumpASMFileName.c_str(),
                                     stringSize, err, errSize, optLevel, options);
       if (err != NULL)
@@ -1113,6 +1091,45 @@ EXTEND_QUOTE:
   }
 #endif
 
+#ifdef GBE_COMPILER_AVAILABLE
+
+  static gbe_program programNewFromLLVMFile(uint32_t deviceID,
+                                            const char *fileName,
+                                            size_t string_size,
+                                            char *err,
+                                            size_t *err_size)
+  {
+    gbe_program p = NULL;
+    if (fileName == NULL)
+      return NULL;
+
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
+    llvm::LLVMContext& c = GBEGetLLVMContext();
+#else
+    llvm::LLVMContext& c = llvm::getGlobalContext();
+#endif
+    // Get the module from its file
+    llvm::SMDiagnostic errDiag;
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
+    llvm::Module *module = parseIRFile(fileName, errDiag, c).release();
+#else
+    llvm::Module *module = ParseIRFile(fileName, errDiag, c);
+#endif
+
+    int optLevel = 1;
+
+    //module will be delete in programCleanLlvmResource
+    p = gbe_program_new_from_llvm(deviceID, module, &c, NULL,
+                                  string_size, err, err_size, optLevel, NULL);
+    if (OCL_OUTPUT_BUILD_LOG && err && *err_size)
+      llvm::errs() << err << "\n";
+
+    return p;
+  }
+#endif
+
+
+
 #ifdef GBE_COMPILER_AVAILABLE
 
   static gbe_program programCompileFromSource(uint32_t deviceID,
@@ -1502,6 +1519,7 @@ void releaseLLVMContextLock()
 }
 
 GBE_EXPORT_SYMBOL gbe_program_new_from_source_cb *gbe_program_new_from_source = NULL;
+GBE_EXPORT_SYMBOL gbe_program_new_from_llvm_file_cb *gbe_program_new_from_llvm_file = NULL;
 GBE_EXPORT_SYMBOL gbe_program_compile_from_source_cb *gbe_program_compile_from_source = NULL;
 GBE_EXPORT_SYMBOL gbe_program_link_program_cb *gbe_program_link_program = NULL;
 GBE_EXPORT_SYMBOL gbe_program_check_opt_cb *gbe_program_check_opt = NULL;
@@ -1564,6 +1582,7 @@ namespace gbe
   {
     CallBackInitializer(void) {
       gbe_program_new_from_source = gbe::programNewFromSource;
+      gbe_program_new_from_llvm_file = gbe::programNewFromLLVMFile;
       gbe_program_compile_from_source = gbe::programCompileFromSource;
       gbe_program_link_program = gbe::programLinkProgram;
       gbe_program_check_opt = gbe::programCheckOption;
diff --git a/backend/src/backend/program.h b/backend/src/backend/program.h
index e601c97a..2017845c 100644
--- a/backend/src/backend/program.h
+++ b/backend/src/backend/program.h
@@ -180,6 +180,15 @@ extern gbe_dup_printfset_cb *gbe_dup_printfset;
 typedef void (gbe_output_printf_cb) (void* printf_info, void* buf_addr);
 extern gbe_output_printf_cb* gbe_output_printf;
 
+
+/*! Create a new program from the llvm file (zero terminated string) */
+typedef gbe_program (gbe_program_new_from_llvm_file_cb)(uint32_t deviceID,
+                                                        const char *fileName,
+                                                        size_t stringSize,
+                                                        char *err,
+                                                        size_t *err_size);
+extern gbe_program_new_from_llvm_file_cb *gbe_program_new_from_llvm_file;
+
 /*! Create a new program from the given source code (zero terminated string) */
 typedef gbe_program (gbe_program_new_from_source_cb)(uint32_t deviceID,
                                                      const char *source,
@@ -231,7 +240,6 @@ extern gbe_program_serialize_to_binary_cb *gbe_program_serialize_to_binary;
 
 /*! Create a new program from the given LLVM file */
 typedef gbe_program (gbe_program_new_from_llvm_cb)(uint32_t deviceID,
-                                                   const char *fileName,
                                                    const void *module,
                                                    const void *llvm_ctx,
                                                    const char *asm_file_name,
diff --git a/backend/src/backend/program.hpp b/backend/src/backend/program.hpp
index 1aff8b99..4a68e338 100644
--- a/backend/src/backend/program.hpp
+++ b/backend/src/backend/program.hpp
@@ -305,8 +305,8 @@ namespace gbe {
     }
     /*! Build a program from a ir::Unit */
     bool buildFromUnit(const ir::Unit &unit, std::string &error);
-    /*! Buils a program from a LLVM source code */
-    bool buildFromLLVMFile(const char *fileName, const void* module, std::string &error, int optLevel);
+    /*! Buils a program from a LLVM Module */
+    bool buildFromLLVMModule(const void* module, std::string &error, int optLevel);
     /*! Buils a program from a OCL string */
     bool buildFromSource(const char *source, std::string &error);
     /*! Get size of the global constant arrays */
diff --git a/backend/src/llvm/llvm_bitcode_link.cpp b/backend/src/llvm/llvm_bitcode_link.cpp
index 5c6585d0..ef56e4c2 100644
--- a/backend/src/llvm/llvm_bitcode_link.cpp
+++ b/backend/src/llvm/llvm_bitcode_link.cpp
@@ -340,7 +340,8 @@ namespace gbe
     /* We use beignet's bitcode as dst because it will have a lot of
        lazy functions which will not be loaded. */
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-    if(LLVMLinkModules2(wrap(clonedLib), wrap(mod))) {
+    llvm::Module * linked_module = llvm::CloneModule((llvm::Module*)mod).release();
+    if(LLVMLinkModules2(wrap(clonedLib), wrap(linked_module))) {
 #else
     char* errorMsg;
     if(LLVMLinkModules(wrap(clonedLib), wrap(mod), LLVMLinkerDestroySource, &errorMsg)) {
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index ceefbbb0..8546f730 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -288,7 +288,7 @@ namespace gbe
     dc->process(diagnostic);
   }
 
-  bool llvmToGen(ir::Unit &unit, const char *fileName,const void* module,
+  bool llvmToGen(ir::Unit &unit, const void* module,
                  int optLevel, bool strictMath, int profiling, std::string &errors)
   {
     std::string errInfo;
@@ -296,23 +296,9 @@ namespace gbe
     if (OCL_OUTPUT_LLVM_BEFORE_LINK || OCL_OUTPUT_LLVM_AFTER_LINK || OCL_OUTPUT_LLVM_AFTER_GEN)
       o = std::unique_ptr<llvm::raw_fd_ostream>(new llvm::raw_fd_ostream(fileno(stdout), false));
 
-    // Get the module from its file
-    llvm::SMDiagnostic Err;
-
     Module* cl_mod = NULL;
     if (module) {
       cl_mod = reinterpret_cast<Module*>(const_cast<void*>(module));
-    } else if (fileName){
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-      llvm::LLVMContext& c = GBEGetLLVMContext();
-#else
-      llvm::LLVMContext& c = llvm::getGlobalContext();
-#endif
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
-      cl_mod = parseIRFile(fileName, Err, c).release();
-#else
-      cl_mod = ParseIRFile(fileName, Err, c);
-#endif
     }
 
     if (!cl_mod) return false;
@@ -335,8 +321,7 @@ namespace gbe
     /* Before do any thing, we first filter in all CL functions in bitcode. */
     /* Also set unit's pointer size in runBitCodeLinker */
     M.reset(runBitCodeLinker(cl_mod, strictMath, unit));
-    if (!module)
-      delete cl_mod;
+
     if (M.get() == 0)
       return true;
 
diff --git a/backend/src/llvm/llvm_to_gen.hpp b/backend/src/llvm/llvm_to_gen.hpp
index 90258521..73e88194 100644
--- a/backend/src/llvm/llvm_to_gen.hpp
+++ b/backend/src/llvm/llvm_to_gen.hpp
@@ -35,7 +35,7 @@ namespace gbe {
 
   /*! Convert the LLVM IR code to a GEN IR code,
 		  optLevel 0 equal to clang -O1 and 1 equal to clang -O2*/
-  bool llvmToGen(ir::Unit &unit, const char *fileName, const void* module,
+  bool llvmToGen(ir::Unit &unit, const void* module,
                  int optLevel, bool strictMath, int profiling, std::string &errors);
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
   extern llvm::LLVMContext& GBEGetLLVMContext();
diff --git a/src/cl_gbe_loader.cpp b/src/cl_gbe_loader.cpp
index f190b0d8..0379b3ec 100644
--- a/src/cl_gbe_loader.cpp
+++ b/src/cl_gbe_loader.cpp
@@ -24,6 +24,7 @@
 
 //function pointer from libgbe.so
 gbe_program_new_from_source_cb *compiler_program_new_from_source = NULL;
+gbe_program_new_from_llvm_file_cb *compiler_program_new_from_llvm_file = NULL;
 gbe_program_compile_from_source_cb *compiler_program_compile_from_source = NULL;
 gbe_program_new_gen_program_cb *compiler_program_new_gen_program = NULL;
 gbe_program_link_program_cb *compiler_program_link_program = NULL;
@@ -298,6 +299,10 @@ struct GbeLoaderInitializer
       if (compiler_program_new_from_source == NULL)
         return;
 
+      compiler_program_new_from_llvm_file = *(gbe_program_new_from_llvm_file_cb **)dlsym(dlhCompiler, "gbe_program_new_from_llvm_file");
+      if (compiler_program_new_from_llvm_file == NULL)
+        return;
+
       compiler_program_compile_from_source = *(gbe_program_compile_from_source_cb **)dlsym(dlhCompiler, "gbe_program_compile_from_source");
       if (compiler_program_compile_from_source == NULL)
         return;
diff --git a/src/cl_gbe_loader.h b/src/cl_gbe_loader.h
index df885d21..df85f1e0 100644
--- a/src/cl_gbe_loader.h
+++ b/src/cl_gbe_loader.h
@@ -25,6 +25,7 @@
 extern "C" {
 #endif
 extern gbe_program_new_from_source_cb *compiler_program_new_from_source;
+extern gbe_program_new_from_llvm_file_cb *compiler_program_new_from_llvm_file;
 extern gbe_program_compile_from_source_cb *compiler_program_compile_from_source;
 extern gbe_program_new_gen_program_cb *compiler_program_new_gen_program;
 extern gbe_program_link_program_cb *compiler_program_link_program;
diff --git a/src/cl_program.c b/src/cl_program.c
index 3ae0486d..556b041f 100644
--- a/src/cl_program.c
+++ b/src/cl_program.c
@@ -428,7 +428,7 @@ cl_program_create_from_llvm(cl_context ctx,
       goto error;
   }
 
-  program->opaque = compiler_program_new_from_llvm(ctx->devices[0]->device_id, file_name, NULL, NULL, NULL, program->build_log_max_sz, program->build_log, &program->build_log_sz, 1, NULL);
+  program->opaque = compiler_program_new_from_llvm_file(ctx->devices[0]->device_id, file_name, program->build_log_max_sz, program->build_log, &program->build_log_sz);
   if (UNLIKELY(program->opaque == NULL)) {
     err = CL_INVALID_PROGRAM;
     goto error;

From cecda8663777480ffbbe1404c0ce8910410ff1ed Mon Sep 17 00:00:00 2001
From: Pan Xiuli <xiuli.pan@intel.com>
Date: Tue, 11 Jul 2017 10:02:09 +0800
Subject: [PATCH 42/52] Fix GCC6 build bug

GCC6 refine the c headers and need to add the needed function header,
like the abs in math.h.

Signed-off-by: Pan Xiuli <xiuli.pan@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_insn_selection_optimize.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/backend/src/backend/gen_insn_selection_optimize.cpp b/backend/src/backend/gen_insn_selection_optimize.cpp
index af5ecc2b..2b2f8bc0 100644
--- a/backend/src/backend/gen_insn_selection_optimize.cpp
+++ b/backend/src/backend/gen_insn_selection_optimize.cpp
@@ -9,6 +9,7 @@
 #include <algorithm>
 #include <climits>
 #include <map>
+#include <math.h>
 
 namespace gbe
 {

From 1d627984308e388be7f7b9b18219738ff0d7e403 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Thu, 20 Jul 2017 13:40:13 +0800
Subject: [PATCH 43/52] Runtime: fix the context ref is not 0 assert when
 delete.

The CL_ENQUEUE_FILL_BUFFER_ALIGN8_* internal program is the same
program, only add the program's ref once, but when delete context,
caculate the internal program count, will add them individually.
This mismatch will cause the context be free by mistake.
New different CL_ENQUEUE_FILL_BUFFER_ALIGN8_* program for clearly.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/cl_context.c | 30 ++++++++----------------------
 1 file changed, 8 insertions(+), 22 deletions(-)

diff --git a/src/cl_context.c b/src/cl_context.c
index 0fe78a9d..fef36f87 100644
--- a/src/cl_context.c
+++ b/src/cl_context.c
@@ -435,32 +435,18 @@ cl_context_get_static_kernel_from_bin(cl_context ctx, cl_int index,
 
     ctx->internal_prgs[index]->is_built = 1;
 
-    /* All CL_ENQUEUE_FILL_BUFFER_ALIGN16_xxx use the same program, different kernel. */
-    if (index >= CL_ENQUEUE_FILL_BUFFER_ALIGN8_8 && index <= CL_ENQUEUE_FILL_BUFFER_ALIGN8_64) {
-      int i = CL_ENQUEUE_FILL_BUFFER_ALIGN8_8;
-      for (; i <= CL_ENQUEUE_FILL_BUFFER_ALIGN8_64; i++) {
-        if (index != i) {
-          assert(ctx->internal_prgs[i] == NULL);
-          assert(ctx->internal_kernels[i] == NULL);
-          cl_program_add_ref(ctx->internal_prgs[index]);
-          ctx->internal_prgs[i] = ctx->internal_prgs[index];
-        }
-
-        if (i == CL_ENQUEUE_FILL_BUFFER_ALIGN8_8) {
-          ctx->internal_kernels[i] = cl_program_create_kernel(ctx->internal_prgs[index],
+    if (index == CL_ENQUEUE_FILL_BUFFER_ALIGN8_8) {
+      ctx->internal_kernels[index] = cl_program_create_kernel(ctx->internal_prgs[index],
                                                               "__cl_fill_region_align8_2", NULL);
-        } else if (i == CL_ENQUEUE_FILL_BUFFER_ALIGN8_16) {
-          ctx->internal_kernels[i] = cl_program_create_kernel(ctx->internal_prgs[index],
+    } else if (index == CL_ENQUEUE_FILL_BUFFER_ALIGN8_16) {
+      ctx->internal_kernels[index] = cl_program_create_kernel(ctx->internal_prgs[index],
                                                               "__cl_fill_region_align8_4", NULL);
-        } else if (i == CL_ENQUEUE_FILL_BUFFER_ALIGN8_32) {
-          ctx->internal_kernels[i] = cl_program_create_kernel(ctx->internal_prgs[index],
+    } else if (index == CL_ENQUEUE_FILL_BUFFER_ALIGN8_32) {
+      ctx->internal_kernels[index] = cl_program_create_kernel(ctx->internal_prgs[index],
                                                               "__cl_fill_region_align8_8", NULL);
-        } else if (i == CL_ENQUEUE_FILL_BUFFER_ALIGN8_64) {
-          ctx->internal_kernels[i] = cl_program_create_kernel(ctx->internal_prgs[index],
+    } else if (index == CL_ENQUEUE_FILL_BUFFER_ALIGN8_64) {
+      ctx->internal_kernels[index] = cl_program_create_kernel(ctx->internal_prgs[index],
                                                               "__cl_fill_region_align8_16", NULL);
-        } else
-          assert(0);
-      }
     } else {
       ctx->internal_kernels[index] = cl_kernel_dup(ctx->internal_prgs[index]->ker[0]);
     }

From 7fc5ac173de4721759124cb3b04800c951245828 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Thu, 27 Jul 2017 13:46:11 +0800
Subject: [PATCH 44/52] GBE: fix a errMsg uninitialized build warning.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/backend/gen_program.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index bb1d22fa..6ba2e549 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -504,7 +504,7 @@ namespace gbe {
   {
 #ifdef GBE_COMPILER_AVAILABLE
     using namespace gbe;
-    char* errMsg;
+    char* errMsg = NULL;
     if(((GenProgram*)dst_program)->module == NULL){
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
@@ -512,7 +512,7 @@ namespace gbe {
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module);
 #endif
       errSize = 0;
-    }else{
+    } else {
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
       // Src now will be removed automatically. So clone it.
       llvm::Module* src = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
@@ -528,7 +528,7 @@ namespace gbe {
 #else
       if (LLVMLinkModules(wrap(dst), wrap(src), LLVMLinkerPreserveSource, &errMsg)) {
 #endif
-        if (err != NULL && errSize != NULL && stringSize > 0u) {
+        if (err != NULL && errSize != NULL && stringSize > 0u && errMsg) {
           strncpy(err, errMsg, stringSize-1);
           err[stringSize-1] = '\0';
           *errSize = strlen(err);

From 86677e660959ca6f907e88c64b19cf640c619856 Mon Sep 17 00:00:00 2001
From: "Yang, Rong R" <rong.r.yang@intel.com>
Date: Wed, 12 Jul 2017 18:33:12 +0800
Subject: [PATCH 45/52] Runtime: fix a build warning.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/cl_program.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/src/cl_program.c b/src/cl_program.c
index 556b041f..3cb59068 100644
--- a/src/cl_program.c
+++ b/src/cl_program.c
@@ -371,6 +371,7 @@ cl_program_create_with_built_in_kernles(cl_context     ctx,
                                   cl_int *             errcode_ret)
 {
   cl_int err = CL_SUCCESS;
+  cl_program built_in_prgs = NULL;
 
   assert(ctx);
   INVALID_DEVICE_IF (num_devices != 1);
@@ -382,11 +383,11 @@ cl_program_create_with_built_in_kernles(cl_context     ctx,
   extern size_t cl_internal_built_in_kernel_str_size;
   char* p_built_in_kernel_str =cl_internal_built_in_kernel_str;
 
-  cl_program built_in_prgs = cl_program_create_from_binary(ctx, 1,
-                                                          &ctx->devices[0],
-                                                          (size_t*)&cl_internal_built_in_kernel_str_size,
-                                                          (const unsigned char **)&p_built_in_kernel_str,
-                                                          &binary_status, &err);
+  built_in_prgs = cl_program_create_from_binary(ctx, 1,
+                                                &ctx->devices[0],
+                                                (size_t*)&cl_internal_built_in_kernel_str_size,
+                                                (const unsigned char **)&p_built_in_kernel_str,
+                                                &binary_status, &err);
   if (!built_in_prgs)
     return NULL;
 

From 3ebe9067d1fb3e569339e7bbc57b03615950f820 Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Tue, 8 Aug 2017 17:32:14 +0800
Subject: [PATCH 46/52] Runtime: implement clEnqueueAcquireGLObjects and
 clEnqueueReleaseGLObjects.

As the application is responsible for synchronizing access to shared
objects, before call clEnqueueAcquireGLObjects, GL's use has been
finished, so just set the event status. clEnqueueReleaseGLObjects is
same.

V2: V1 is wrong version, correct it.
Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 src/cl_gl_api.c | 150 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 150 insertions(+)

diff --git a/src/cl_gl_api.c b/src/cl_gl_api.c
index 897edb4e..61b3ab80 100644
--- a/src/cl_gl_api.c
+++ b/src/cl_gl_api.c
@@ -35,6 +35,8 @@
 #include "cl_sampler.h"
 #include "cl_alloc.h"
 #include "cl_utils.h"
+#include "cl_enqueue.h"
+#include "cl_event.h"
 
 #include "CL/cl.h"
 #include "CL/cl_gl.h"
@@ -134,6 +136,80 @@ cl_int clEnqueueAcquireGLObjects (cl_command_queue command_queue,
                                   cl_event *event)
 {
   cl_int err = CL_SUCCESS;
+  cl_int e_status, i;
+  cl_event e = NULL;
+  enqueue_data *data = NULL;
+
+  do {
+    if (!CL_OBJECT_IS_COMMAND_QUEUE(command_queue)) {
+      err = CL_INVALID_COMMAND_QUEUE;
+      break;
+    }
+
+    if (UNLIKELY(command_queue->ctx->props.gl_type == CL_GL_NOSHARE)) {
+      err = CL_INVALID_CONTEXT;
+      break;
+    }
+
+    if ((num_objects == 0 && mem_objects != NULL) ||
+        (num_objects > 0 && mem_objects == NULL)) {
+      err = CL_INVALID_VALUE;
+      break;
+    }
+
+    for (i = 0; i < num_objects; i++) {
+      if (!cl_mem_image(mem_objects[i])) {
+        err = CL_INVALID_MEM_OBJECT;
+        break;
+      }
+      if (!IS_GL_IMAGE(mem_objects[i])) {
+        err = CL_INVALID_GL_OBJECT;
+        break;
+      }
+    }
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    err = cl_event_check_waitlist(num_events_in_wait_list, event_wait_list,
+                                  event, command_queue->ctx);
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    e = cl_event_create(command_queue->ctx, command_queue, num_events_in_wait_list,
+                        event_wait_list, CL_COMMAND_ACQUIRE_GL_OBJECTS, &err);
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    e_status = cl_event_is_ready(e);
+
+    data = &e->exec_data;
+    data->type = EnqueueReturnSuccesss;
+
+    if (e_status == CL_COMPLETE) {
+      // Sync mode, no need to queue event.
+      err = cl_event_exec(e, CL_COMPLETE, CL_FALSE);
+      if (err != CL_SUCCESS) {
+        break;
+      }
+    } else {
+      err = cl_event_exec(e, CL_SUBMITTED, CL_TRUE); // Submit to get the address.
+      if (err != CL_SUCCESS) {
+        break;
+      }
+
+      cl_command_queue_enqueue_event(command_queue, e);
+    }
+  } while (0);
+
+  if (err == CL_SUCCESS && event) {
+    *event = e;
+  } else {
+    cl_event_delete(e);
+  }
+
   return err;
 }
 
@@ -146,5 +222,79 @@ cl_int clEnqueueReleaseGLObjects (cl_command_queue command_queue,
                                   cl_event *event)
 {
   cl_int err = CL_SUCCESS;
+  cl_int e_status, i;
+  cl_event e = NULL;
+  enqueue_data *data = NULL;
+
+  do {
+    if (!CL_OBJECT_IS_COMMAND_QUEUE(command_queue)) {
+      err = CL_INVALID_COMMAND_QUEUE;
+      break;
+    }
+
+    if (UNLIKELY(command_queue->ctx->props.gl_type == CL_GL_NOSHARE)) {
+      err = CL_INVALID_CONTEXT;
+      break;
+    }
+
+    if ((num_objects == 0 && mem_objects != NULL) ||
+        (num_objects > 0 && mem_objects == NULL)) {
+      err = CL_INVALID_VALUE;
+      break;
+    }
+
+    for (i = 0; i < num_objects; i++) {
+      if (!cl_mem_image(mem_objects[i])) {
+        err = CL_INVALID_MEM_OBJECT;
+        break;
+      }
+      if (!IS_GL_IMAGE(mem_objects[i])) {
+        err = CL_INVALID_GL_OBJECT;
+        break;
+      }
+    }
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    err = cl_event_check_waitlist(num_events_in_wait_list, event_wait_list,
+                                  event, command_queue->ctx);
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    e = cl_event_create(command_queue->ctx, command_queue, num_events_in_wait_list,
+                        event_wait_list, CL_COMMAND_ACQUIRE_GL_OBJECTS, &err);
+    if (err != CL_SUCCESS) {
+      break;
+    }
+
+    e_status = cl_event_is_ready(e);
+
+    data = &e->exec_data;
+    data->type = EnqueueReturnSuccesss;
+
+    if (e_status == CL_COMPLETE) {
+      // Sync mode, no need to queue event.
+      err = cl_event_exec(e, CL_COMPLETE, CL_FALSE);
+      if (err != CL_SUCCESS) {
+        break;
+      }
+    } else {
+      err = cl_event_exec(e, CL_SUBMITTED, CL_TRUE); // Submit to get the address.
+      if (err != CL_SUCCESS) {
+        break;
+      }
+
+      cl_command_queue_enqueue_event(command_queue, e);
+    }
+  } while (0);
+
+  if (err == CL_SUCCESS && event) {
+    *event = e;
+  } else {
+    cl_event_delete(e);
+  }
+
   return err;
 }

From 1d3085d5a0db76da786441189c26e6a399577111 Mon Sep 17 00:00:00 2001
From: Jan Vesely <jano.vesely@gmail.com>
Date: Tue, 19 Sep 2017 00:16:34 -0400
Subject: [PATCH 47/52] libocl: Add shuffle and shuffle2 builtins for half type

Signed-off-by: Jan Vesely <jano.vesely@gmail.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/libocl/include/ocl_misc.h | 2 ++
 backend/src/libocl/src/ocl_misc.cl    | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/backend/src/libocl/include/ocl_misc.h b/backend/src/libocl/include/ocl_misc.h
index 2c0d7003..a15cfe4b 100644
--- a/backend/src/libocl/include/ocl_misc.h
+++ b/backend/src/libocl/include/ocl_misc.h
@@ -48,6 +48,7 @@ DEF(char)
 DEF(uchar)
 DEF(short)
 DEF(ushort)
+DEF(half)
 DEF(int)
 DEF(uint)
 DEF(float)
@@ -112,6 +113,7 @@ DEF(char)
 DEF(uchar)
 DEF(short)
 DEF(ushort)
+DEF(half)
 DEF(int)
 DEF(uint)
 DEF(float)
diff --git a/backend/src/libocl/src/ocl_misc.cl b/backend/src/libocl/src/ocl_misc.cl
index 3b2eb929..da980c19 100644
--- a/backend/src/libocl/src/ocl_misc.cl
+++ b/backend/src/libocl/src/ocl_misc.cl
@@ -87,6 +87,7 @@ DEF(char)
 DEF(uchar)
 DEF(short)
 DEF(ushort)
+DEF(half)
 DEF(int)
 DEF(uint)
 DEF(float)
@@ -201,6 +202,7 @@ DEF(char)
 DEF(uchar)
 DEF(short)
 DEF(ushort)
+DEF(half)
 DEF(int)
 DEF(uint)
 DEF(float)

From f2af0e69e282426908698b5aaf802ffb75483131 Mon Sep 17 00:00:00 2001
From: Jan Vesely <jano.vesely@gmail.com>
Date: Tue, 19 Sep 2017 01:12:40 -0400
Subject: [PATCH 48/52] libocl: Consider only bottom ilogb(2m-1)+1 bits

Signed-off-by: Jan Vesely <jano.vesely@gmail.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/libocl/src/ocl_misc.cl | 60 +++++++++++++++++++-------------------
 1 file changed, 30 insertions(+), 30 deletions(-)

diff --git a/backend/src/libocl/src/ocl_misc.cl b/backend/src/libocl/src/ocl_misc.cl
index da980c19..9a99df99 100644
--- a/backend/src/libocl/src/ocl_misc.cl
+++ b/backend/src/libocl/src/ocl_misc.cl
@@ -108,8 +108,8 @@ DEF(ulong)
 #define DEC2X(TYPE, MASKTYPE) \
   OVERLOADABLE TYPE##2 shuffle2(TYPE##16 x, TYPE##16 y, MASKTYPE##2 mask) { \
     TYPE##2 z; \
-    z.s0 = mask.s0 < 16 ? ((TYPE *)&x)[mask.s0] : ((TYPE *)&y)[mask.s0 & 15]; \
-    z.s1 = mask.s1 < 16 ? ((TYPE *)&x)[mask.s1] : ((TYPE *)&y)[mask.s1 & 15]; \
+    z.s0 = (mask.s0 & 31) < 16 ? ((TYPE *)&x)[mask.s0 & 31] : ((TYPE *)&y)[mask.s0 & 15]; \
+    z.s1 = (mask.s1 & 31) < 16 ? ((TYPE *)&x)[mask.s1 & 31] : ((TYPE *)&y)[mask.s1 & 15]; \
     return z; \
   }
 
@@ -121,10 +121,10 @@ DEF(ulong)
 #define DEC4X(TYPE, MASKTYPE) \
   OVERLOADABLE TYPE##4 shuffle2(TYPE##16 x, TYPE##16 y, MASKTYPE##4 mask) { \
     TYPE##4 z; \
-    z.s0 = mask.s0 < 16 ? ((TYPE *)&x)[mask.s0] : ((TYPE *)&y)[mask.s0 & 15]; \
-    z.s1 = mask.s1 < 16 ? ((TYPE *)&x)[mask.s1] : ((TYPE *)&y)[mask.s1 & 15]; \
-    z.s2 = mask.s2 < 16 ? ((TYPE *)&x)[mask.s2] : ((TYPE *)&y)[mask.s2 & 15]; \
-    z.s3 = mask.s3 < 16 ? ((TYPE *)&x)[mask.s3] : ((TYPE *)&y)[mask.s3 & 15]; \
+    z.s0 = (mask.s0 & 31) < 16 ? ((TYPE *)&x)[mask.s0 & 31] : ((TYPE *)&y)[mask.s0 & 15]; \
+    z.s1 = (mask.s1 & 31) < 16 ? ((TYPE *)&x)[mask.s1 & 31] : ((TYPE *)&y)[mask.s1 & 15]; \
+    z.s2 = (mask.s2 & 31) < 16 ? ((TYPE *)&x)[mask.s2 & 31] : ((TYPE *)&y)[mask.s2 & 15]; \
+    z.s3 = (mask.s3 & 31) < 16 ? ((TYPE *)&x)[mask.s3 & 31] : ((TYPE *)&y)[mask.s3 & 15]; \
     return z; \
   }
 
@@ -136,14 +136,14 @@ DEF(ulong)
 #define DEC8X(TYPE, MASKTYPE) \
   OVERLOADABLE TYPE##8 shuffle2(TYPE##16 x, TYPE##16 y, MASKTYPE##8 mask) { \
     TYPE##8 z; \
-    z.s0 = mask.s0 < 16 ? ((TYPE *)&x)[mask.s0] : ((TYPE *)&y)[mask.s0 & 15]; \
-    z.s1 = mask.s1 < 16 ? ((TYPE *)&x)[mask.s1] : ((TYPE *)&y)[mask.s1 & 15]; \
-    z.s2 = mask.s2 < 16 ? ((TYPE *)&x)[mask.s2] : ((TYPE *)&y)[mask.s2 & 15]; \
-    z.s3 = mask.s3 < 16 ? ((TYPE *)&x)[mask.s3] : ((TYPE *)&y)[mask.s3 & 15]; \
-    z.s4 = mask.s4 < 16 ? ((TYPE *)&x)[mask.s4] : ((TYPE *)&y)[mask.s4 & 15]; \
-    z.s5 = mask.s5 < 16 ? ((TYPE *)&x)[mask.s5] : ((TYPE *)&y)[mask.s5 & 15]; \
-    z.s6 = mask.s6 < 16 ? ((TYPE *)&x)[mask.s6] : ((TYPE *)&y)[mask.s6 & 15]; \
-    z.s7 = mask.s7 < 16 ? ((TYPE *)&x)[mask.s7] : ((TYPE *)&y)[mask.s7 & 15]; \
+    z.s0 = (mask.s0 & 31) < 16 ? ((TYPE *)&x)[mask.s0 & 31] : ((TYPE *)&y)[mask.s0 & 15]; \
+    z.s1 = (mask.s1 & 31) < 16 ? ((TYPE *)&x)[mask.s1 & 31] : ((TYPE *)&y)[mask.s1 & 15]; \
+    z.s2 = (mask.s2 & 31) < 16 ? ((TYPE *)&x)[mask.s2 & 31] : ((TYPE *)&y)[mask.s2 & 15]; \
+    z.s3 = (mask.s3 & 31) < 16 ? ((TYPE *)&x)[mask.s3 & 31] : ((TYPE *)&y)[mask.s3 & 15]; \
+    z.s4 = (mask.s4 & 31) < 16 ? ((TYPE *)&x)[mask.s4 & 31] : ((TYPE *)&y)[mask.s4 & 15]; \
+    z.s5 = (mask.s5 & 31) < 16 ? ((TYPE *)&x)[mask.s5 & 31] : ((TYPE *)&y)[mask.s5 & 15]; \
+    z.s6 = (mask.s6 & 31) < 16 ? ((TYPE *)&x)[mask.s6 & 31] : ((TYPE *)&y)[mask.s6 & 15]; \
+    z.s7 = (mask.s7 & 31) < 16 ? ((TYPE *)&x)[mask.s7 & 31] : ((TYPE *)&y)[mask.s7 & 15]; \
     return z; \
   }
 
@@ -155,22 +155,22 @@ DEF(ulong)
 #define DEC16X(TYPE, MASKTYPE) \
   OVERLOADABLE TYPE##16 shuffle2(TYPE##16 x, TYPE##16 y, MASKTYPE##16 mask) { \
     TYPE##16 z; \
-    z.s0 = mask.s0 < 16 ? ((TYPE *)&x)[mask.s0] : ((TYPE *)&y)[mask.s0 & 15]; \
-    z.s1 = mask.s1 < 16 ? ((TYPE *)&x)[mask.s1] : ((TYPE *)&y)[mask.s1 & 15]; \
-    z.s2 = mask.s2 < 16 ? ((TYPE *)&x)[mask.s2] : ((TYPE *)&y)[mask.s2 & 15]; \
-    z.s3 = mask.s3 < 16 ? ((TYPE *)&x)[mask.s3] : ((TYPE *)&y)[mask.s3 & 15]; \
-    z.s4 = mask.s4 < 16 ? ((TYPE *)&x)[mask.s4] : ((TYPE *)&y)[mask.s4 & 15]; \
-    z.s5 = mask.s5 < 16 ? ((TYPE *)&x)[mask.s5] : ((TYPE *)&y)[mask.s5 & 15]; \
-    z.s6 = mask.s6 < 16 ? ((TYPE *)&x)[mask.s6] : ((TYPE *)&y)[mask.s6 & 15]; \
-    z.s7 = mask.s7 < 16 ? ((TYPE *)&x)[mask.s7] : ((TYPE *)&y)[mask.s7 & 15]; \
-    z.s8 = mask.s8 < 16 ? ((TYPE *)&x)[mask.s8] : ((TYPE *)&y)[mask.s8 & 15]; \
-    z.s9 = mask.s9 < 16 ? ((TYPE *)&x)[mask.s9] : ((TYPE *)&y)[mask.s9 & 15]; \
-    z.sA = mask.sA < 16 ? ((TYPE *)&x)[mask.sA] : ((TYPE *)&y)[mask.sA & 15]; \
-    z.sB = mask.sB < 16 ? ((TYPE *)&x)[mask.sB] : ((TYPE *)&y)[mask.sB & 15]; \
-    z.sC = mask.sC < 16 ? ((TYPE *)&x)[mask.sC] : ((TYPE *)&y)[mask.sC & 15]; \
-    z.sD = mask.sD < 16 ? ((TYPE *)&x)[mask.sD] : ((TYPE *)&y)[mask.sD & 15]; \
-    z.sE = mask.sE < 16 ? ((TYPE *)&x)[mask.sE] : ((TYPE *)&y)[mask.sE & 15]; \
-    z.sF = mask.sF < 16 ? ((TYPE *)&x)[mask.sF] : ((TYPE *)&y)[mask.sF & 15]; \
+    z.s0 = (mask.s0 & 31) < 16 ? ((TYPE *)&x)[mask.s0 & 31] : ((TYPE *)&y)[mask.s0 & 15]; \
+    z.s1 = (mask.s1 & 31) < 16 ? ((TYPE *)&x)[mask.s1 & 31] : ((TYPE *)&y)[mask.s1 & 15]; \
+    z.s2 = (mask.s2 & 31) < 16 ? ((TYPE *)&x)[mask.s2 & 31] : ((TYPE *)&y)[mask.s2 & 15]; \
+    z.s3 = (mask.s3 & 31) < 16 ? ((TYPE *)&x)[mask.s3 & 31] : ((TYPE *)&y)[mask.s3 & 15]; \
+    z.s4 = (mask.s4 & 31) < 16 ? ((TYPE *)&x)[mask.s4 & 31] : ((TYPE *)&y)[mask.s4 & 15]; \
+    z.s5 = (mask.s5 & 31) < 16 ? ((TYPE *)&x)[mask.s5 & 31] : ((TYPE *)&y)[mask.s5 & 15]; \
+    z.s6 = (mask.s6 & 31) < 16 ? ((TYPE *)&x)[mask.s6 & 31] : ((TYPE *)&y)[mask.s6 & 15]; \
+    z.s7 = (mask.s7 & 31) < 16 ? ((TYPE *)&x)[mask.s7 & 31] : ((TYPE *)&y)[mask.s7 & 15]; \
+    z.s8 = (mask.s8 & 31) < 16 ? ((TYPE *)&x)[mask.s8 & 31] : ((TYPE *)&y)[mask.s8 & 15]; \
+    z.s9 = (mask.s9 & 31) < 16 ? ((TYPE *)&x)[mask.s9 & 31] : ((TYPE *)&y)[mask.s9 & 15]; \
+    z.sA = (mask.sA & 31) < 16 ? ((TYPE *)&x)[mask.sA & 31] : ((TYPE *)&y)[mask.sA & 15]; \
+    z.sB = (mask.sB & 31) < 16 ? ((TYPE *)&x)[mask.sB & 31] : ((TYPE *)&y)[mask.sB & 15]; \
+    z.sC = (mask.sC & 31) < 16 ? ((TYPE *)&x)[mask.sC & 31] : ((TYPE *)&y)[mask.sC & 15]; \
+    z.sD = (mask.sD & 31) < 16 ? ((TYPE *)&x)[mask.sD & 31] : ((TYPE *)&y)[mask.sD & 15]; \
+    z.sE = (mask.sE & 31) < 16 ? ((TYPE *)&x)[mask.sE & 31] : ((TYPE *)&y)[mask.sE & 15]; \
+    z.sF = (mask.sF & 31) < 16 ? ((TYPE *)&x)[mask.sF & 31] : ((TYPE *)&y)[mask.sF & 15]; \
     return z; \
   }
 

From 8b96322ff2a52bc9ad865b0dcded9193afe05347 Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Wed, 20 Sep 2017 14:42:19 +0800
Subject: [PATCH 49/52] libocl: enable llvm5.0 support.

There are 2 changes:
1. enable cl_khr_3d_image_writes, llvm5.0 required.
2. change enqueue_ndrange functions and ndrange_t type for llvm5.0.

Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/libocl/include/ocl_enqueue.h | 35 +++++++++++++++------
 backend/src/libocl/include/ocl_image.h   |  2 ++
 backend/src/libocl/src/ocl_enqueue.cl    | 54 +++++++++++++++++++-------------
 3 files changed, 59 insertions(+), 32 deletions(-)

diff --git a/backend/src/libocl/include/ocl_enqueue.h b/backend/src/libocl/include/ocl_enqueue.h
index 7ccab59f..8e9fd32b 100644
--- a/backend/src/libocl/include/ocl_enqueue.h
+++ b/backend/src/libocl/include/ocl_enqueue.h
@@ -43,14 +43,30 @@ struct Block_literal {
     unsigned long int reserved;         // NULL
     unsigned long int size;         // sizeof(struct Block_literal_1)
     // optional helper functions
-    void (*copy_helper)(void *dst, void *src);     // IFF (1<<25)
-    void (*dispose_helper)(void *src);             // IFF (1<<25)
+    void *copy_helper;                // IFF (1<<25)
+    void *dispose_helper;             // IFF (1<<25)
     // required ABI.2010.3.16
     const char *signature;                         // IFF (1<<30)
   } *descriptor;
   // imported variables
 };
 
+#if __clang_major__*10 + __clang_minor__ >= 50
+typedef struct ndrange_info_t ndrange_t;
+#endif
+
+#if __clang_major__*10 + __clang_minor__ >= 50
+#define BLOCK_TYPE void*
+#else
+#define BLOCK_TYPE __private void*
+#endif
+
+#if __clang_major__*10 + __clang_minor__ >= 40
+#define EVENT_TYPE clk_event_t*
+#else
+#define EVENT_TYPE __private clk_event_t*
+#endif
+
 clk_event_t create_user_event(void);
 void retain_event(clk_event_t event);
 void release_event(clk_event_t event);
@@ -58,17 +74,16 @@ void set_user_event_status(clk_event_t event, int status);
 bool is_valid_event(clk_event_t event);
 void capture_event_profiling_info(clk_event_t event, int name, global void *value);
 
-uint __get_kernel_work_group_size_impl(__private void *block);
-uint __get_kernel_preferred_work_group_multiple_impl(__private void *block);
+uint __get_kernel_work_group_size_impl(BLOCK_TYPE block);
+uint __get_kernel_preferred_work_group_multiple_impl(BLOCK_TYPE block);
 
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^block)(void));
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange,
-                                uint num_events_in_wait_list, const clk_event_t *event_wait_list,
-                                clk_event_t *event_ret, void (^block)(void));
+int __enqueue_kernel_basic(queue_t q, int flag, ndrange_t ndrange, BLOCK_TYPE block);
+int __enqueue_kernel_basic_events(queue_t q, int flag, ndrange_t ndrange,
+                                  uint num_events_in_wait_list, const EVENT_TYPE event_wait_list,
+                                  EVENT_TYPE event_ret, BLOCK_TYPE block);
 
 queue_t get_default_queue(void);
-int __gen_enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^block)(void), int size);
-int __gen_enqueue_kernel_slm(queue_t q, int flag, ndrange_t ndrange, __private void * block, int count, __private int* slm_sizes);
+int __gen_enqueue_kernel_slm(queue_t q, int flag, ndrange_t ndrange, BLOCK_TYPE block, int count, __private int* slm_sizes);
 
 OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_size);
 OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_size, size_t local_work_size);
diff --git a/backend/src/libocl/include/ocl_image.h b/backend/src/libocl/include/ocl_image.h
index 5a679aa8..f816e1af 100644
--- a/backend/src/libocl/include/ocl_image.h
+++ b/backend/src/libocl/include/ocl_image.h
@@ -23,6 +23,8 @@
 #define int1 int
 #define float1 float
 
+#pragma OPENCL EXTENSION cl_khr_3d_image_writes : enable
+
 #define DECL_IMAGE_READ_SAMPLE_RETTYPE(IMG_TYPE, DATA_YPE, SUFFIX, N) \
   OVERLOADABLE DATA_YPE read_image ## SUFFIX(IMG_TYPE cl_image, const sampler_t sampler, int##N coord); \
   OVERLOADABLE DATA_YPE read_image ## SUFFIX(IMG_TYPE cl_image, const sampler_t sampler, float##N coord);
diff --git a/backend/src/libocl/src/ocl_enqueue.cl b/backend/src/libocl/src/ocl_enqueue.cl
index dc8fa3b1..1ae43aa4 100644
--- a/backend/src/libocl/src/ocl_enqueue.cl
+++ b/backend/src/libocl/src/ocl_enqueue.cl
@@ -30,7 +30,7 @@ ndrange_t __gen_ocl_set_ndrange_info(__private struct ndrange_info_t *info);
 __private struct ndrange_info_t* __gen_ocl_get_ndrange_info(ndrange_t info);
 __global int* __gen_ocl_get_enqueue_info_addr(void);
 
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^block)(void))
+int __enqueue_kernel_basic(queue_t q, int flag, ndrange_t ndrange, BLOCK_TYPE block)
 {
   int i;
   __private struct Block_literal *literal = (__private struct Block_literal *)block;
@@ -40,8 +40,11 @@ OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^b
   __global int* start_addr = __gen_ocl_get_enqueue_info_addr();
   int offset = atomic_add(start_addr, size + sizeof(struct ndrange_info_t));
   __global uchar* addr = (__global uchar*)start_addr + offset + sizeof(int);
+#if __clang_major__*10 + __clang_minor__ >= 50
+  __private struct ndrange_info_t *info = to_private(&ndrange);
+#else
   __private struct ndrange_info_t *info = __gen_ocl_get_ndrange_info(ndrange);
-
+#endif
   *((__global struct ndrange_info_t *)addr) = *info;
   addr += sizeof(*info);
 
@@ -51,14 +54,14 @@ OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange, void (^b
   return 0;
 }
 
-OVERLOADABLE int enqueue_kernel(queue_t q, int flag, ndrange_t ndrange,
-                                uint num_events_in_wait_list, const clk_event_t *event_wait_list,
-                                clk_event_t *event_ret, void (^block)(void))
+int __enqueue_kernel_basic_events(queue_t q, int flag, ndrange_t ndrange,
+                                uint num_events_in_wait_list, const EVENT_TYPE event_wait_list,
+                                EVENT_TYPE event_ret, BLOCK_TYPE block)
 {
-  return enqueue_kernel(q, flag, ndrange, block);
+  return __enqueue_kernel_basic(q, flag, ndrange, block);
 }
 
-int __gen_enqueue_kernel_slm(queue_t q, int flag, ndrange_t ndrange, __private void * block, int count, __private int* slm_sizes)
+int __gen_enqueue_kernel_slm(queue_t q, int flag, ndrange_t ndrange, BLOCK_TYPE block, int count, __private int* slm_sizes)
 {
   int i;
   __private struct Block_literal* literal = (__private struct Block_literal *)block;
@@ -69,7 +72,11 @@ int __gen_enqueue_kernel_slm(queue_t q, int flag, ndrange_t ndrange, __private v
   __global int* start_addr = __gen_ocl_get_enqueue_info_addr();
   int offset = atomic_add(start_addr, size + sizeof(struct ndrange_info_t) + slm_size);
   __global uchar* addr = (__global uchar*)start_addr + offset + sizeof(int);
+#if __clang_major__*10 + __clang_minor__ >= 50
+  __private struct ndrange_info_t *info = to_private(&ndrange);
+#else
   __private struct ndrange_info_t *info = __gen_ocl_get_ndrange_info(ndrange);
+#endif
 
   *((__global struct ndrange_info_t *)addr) = *info;
   addr += sizeof(*info);
@@ -111,12 +118,12 @@ bool is_valid_event(clk_event_t event)
   return 1;
 }
 
-uint __get_kernel_work_group_size_impl(__private void *block)
+uint __get_kernel_work_group_size_impl(BLOCK_TYPE block)
 {
   return 256;
 }
 
-uint __get_kernel_preferred_work_group_multiple_impl(__private  void *block)
+uint __get_kernel_preferred_work_group_multiple_impl(BLOCK_TYPE block)
 {
   return 16;
 }
@@ -127,13 +134,19 @@ void capture_event_profiling_info(clk_event_t event, int name, global void *valu
   ((__global ulong *)value)[0] = 0x3000;
   ((__global ulong *)value)[1] = 0x6000;
 }
+
+#if __clang_major__*10 + __clang_minor__ >= 50
+#define RET_INFO  return info;
+#else
+#define RET_INFO  return __gen_ocl_set_ndrange_info(&info);
+#endif
+
 OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_size)
 {
   struct ndrange_info_t info;
   info.type = 0x1;
   info.global_work_size[0] = global_work_size;
-  return __gen_ocl_set_ndrange_info(&info);
-  //return ndrange;
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_size, size_t local_work_size)
@@ -142,8 +155,7 @@ OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_size, size_t local_work_siz
   info.type = 0x2;
   info.global_work_size[0] = global_work_size;
   info.local_work_size[0] = local_work_size;
-  return __gen_ocl_set_ndrange_info(&info);
- // return ndrange;
+  RET_INFO;
 }
 
 
@@ -154,8 +166,7 @@ OVERLOADABLE ndrange_t ndrange_1D(size_t global_work_offset, size_t global_work_
   info.global_work_size[0] = global_work_size;
   info.local_work_size[0] = local_work_size;
   info.global_work_offset[0] = global_work_offset;
-  return __gen_ocl_set_ndrange_info(&info);
-  //return ndrange;
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_2D(const size_t global_work_size[2])
@@ -164,8 +175,7 @@ OVERLOADABLE ndrange_t ndrange_2D(const size_t global_work_size[2])
   info.type = 0x11;
   info.global_work_size[0] = global_work_size[0];
   info.global_work_size[1] = global_work_size[1];
-  return __gen_ocl_set_ndrange_info(&info);
-  //return ndrange;
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_2D(const size_t global_work_size[2], const size_t local_work_size[2])
@@ -176,7 +186,7 @@ OVERLOADABLE ndrange_t ndrange_2D(const size_t global_work_size[2], const size_t
   info.global_work_size[1] = global_work_size[1];
   info.local_work_size[0] = local_work_size[0];
   info.local_work_size[1] = local_work_size[1];
-  return __gen_ocl_set_ndrange_info(&info);
+  RET_INFO;
 }
 
 
@@ -190,7 +200,7 @@ OVERLOADABLE ndrange_t ndrange_2D(const size_t global_work_offset[2], const size
   info.local_work_size[1] = local_work_size[1];
   info.global_work_offset[0] = global_work_offset[0];
   info.global_work_offset[1] = global_work_offset[1];
-  return __gen_ocl_set_ndrange_info(&info);
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_size[3])
@@ -200,7 +210,7 @@ OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_size[3])
   info.global_work_size[0] = global_work_size[0];
   info.global_work_size[1] = global_work_size[1];
   info.global_work_size[2] = global_work_size[2];
-  return __gen_ocl_set_ndrange_info(&info);
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_size[3], const size_t local_work_size[3])
@@ -213,7 +223,7 @@ OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_size[3], const size_t
   info.local_work_size[0] = local_work_size[0];
   info.local_work_size[1] = local_work_size[1];
   info.local_work_size[2] = local_work_size[2];
-  return __gen_ocl_set_ndrange_info(&info);
+  RET_INFO;
 }
 
 OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_offset[3], const size_t global_work_size[3], const size_t local_work_size[3])
@@ -229,7 +239,7 @@ OVERLOADABLE ndrange_t ndrange_3D(const size_t global_work_offset[3], const size
   info.global_work_offset[0] = global_work_offset[0];
   info.global_work_offset[1] = global_work_offset[1];
   info.global_work_offset[2] = global_work_offset[2];
-  return __gen_ocl_set_ndrange_info(&info);
+  RET_INFO;
 }
 
 int enqueue_marker (queue_t queue, uint num_events_in_wait_list, const clk_event_t *event_wait_list, clk_event_t *event_ret)

From a721051769894aed18c0df96652862ef5ea57f13 Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Wed, 20 Sep 2017 16:17:50 +0800
Subject: [PATCH 50/52] GBE: enable llvm5.0 support.

1. getOrInsertFunction without nullptr.
2. handle f16 rounding.
3. remove llvm value dump.
4. handle AddrSpaceCastInst when parsing block info.

V2: use stripPointerCasts instead of BitCast and AddrSpaceCast.
Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/llvm/PromoteIntegers.cpp     |  5 ++++
 backend/src/llvm/llvm_barrier_nodup.cpp  |  4 +++
 backend/src/llvm/llvm_device_enqueue.cpp | 42 +++++++++++++++++---------------
 backend/src/llvm/llvm_gen_backend.cpp    | 41 +++++++++++++++++++++++--------
 backend/src/llvm/llvm_profiling.cpp      | 20 ++++++++++++---
 backend/src/llvm/llvm_sampler_fix.cpp    |  8 ++++++
 6 files changed, 87 insertions(+), 33 deletions(-)

diff --git a/backend/src/llvm/PromoteIntegers.cpp b/backend/src/llvm/PromoteIntegers.cpp
index a500311b..d433771e 100644
--- a/backend/src/llvm/PromoteIntegers.cpp
+++ b/backend/src/llvm/PromoteIntegers.cpp
@@ -605,8 +605,13 @@ static void convertInstruction(Instruction *Inst, ConversionState &State) {
     for (SwitchInst::CaseIt I = Switch->case_begin(),
              E = Switch->case_end();
          I != E; ++I) {
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
+      NewInst->addCase(cast<ConstantInt>(convertConstant(I->getCaseValue())),
+                       I->getCaseSuccessor());
+#else
       NewInst->addCase(cast<ConstantInt>(convertConstant(I.getCaseValue())),
                        I.getCaseSuccessor());
+#endif
     }
     Switch->eraseFromParent();
   } else {
diff --git a/backend/src/llvm/llvm_barrier_nodup.cpp b/backend/src/llvm/llvm_barrier_nodup.cpp
index a7d0d1ad..b8ffdf41 100644
--- a/backend/src/llvm/llvm_barrier_nodup.cpp
+++ b/backend/src/llvm/llvm_barrier_nodup.cpp
@@ -74,7 +74,11 @@ namespace gbe {
               if (F.hasFnAttribute(Attribute::NoDuplicate)) {
                 auto attrs = F.getAttributes();
                 F.setAttributes(attrs.removeAttribute(M.getContext(),
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
+                                AttributeList::FunctionIndex,
+#else
                                 AttributeSet::FunctionIndex,
+#endif
                                 Attribute::NoDuplicate));
                 changed = true;
               }
diff --git a/backend/src/llvm/llvm_device_enqueue.cpp b/backend/src/llvm/llvm_device_enqueue.cpp
index 9a0fb46f..58aa6817 100644
--- a/backend/src/llvm/llvm_device_enqueue.cpp
+++ b/backend/src/llvm/llvm_device_enqueue.cpp
@@ -29,6 +29,7 @@ namespace gbe {
     BitCastInst* bt = dyn_cast<BitCastInst>(I);
     if (bt == NULL)
       return NULL;
+//bt->dump();
 
     Type* type = bt->getOperand(0)->getType();
     if(!type->isPointerTy())
@@ -112,7 +113,8 @@ namespace gbe {
     ValueToValueMapTy VMap;
     for (Function::arg_iterator I = Fn->arg_begin(), E = Fn->arg_end(); I != E; ++I) {
       PointerType *ty = dyn_cast<PointerType>(I->getType());
-      if(ty && ty->getAddressSpace() == 0) //Foce set the address space to global
+      //Foce set the address space to global
+      if(ty && (ty->getAddressSpace() == 0 || ty->getAddressSpace() == 4))
         ty = PointerType::get(ty->getPointerElementType(), 1);
       ParamTys.push_back(ty);
     }
@@ -252,12 +254,13 @@ namespace gbe {
             if(gep == NULL)
               continue;
 
-            BitCastInst* fnPointer = dyn_cast<BitCastInst>(gep->getOperand(0));
-            if(fnPointer == NULL)
+            Value *fnPointer = gep->getOperand(0)->stripPointerCasts();
+
+            if(fnPointer == gep->getOperand(0))
               continue;
 
-            if(BitCastInst* bt = dyn_cast<BitCastInst>(fnPointer->getOperand(0))) {
-              std::string fnName = blocks[bt->getOperand(0)];
+            if(blocks.find(fnPointer) != blocks.end()) {
+              std::string fnName = blocks[fnPointer];
               Function* f = mod->getFunction(fnName);
               CallInst *newCI = builder.CreateCall(f, args);
               CI->replaceAllUsesWith(newCI);
@@ -266,7 +269,7 @@ namespace gbe {
             }
 
             //the function is global variable
-            if(GlobalVariable* gv = dyn_cast<GlobalVariable>(fnPointer->getOperand(0))) {
+            if(GlobalVariable* gv = dyn_cast<GlobalVariable>(fnPointer)) {
               Constant *c = gv->getInitializer();
               ConstantExpr *expr = dyn_cast<ConstantExpr>(c->getOperand(3));
               BitCastInst *bt = dyn_cast<BitCastInst>(expr->getAsInstruction());
@@ -277,7 +280,7 @@ namespace gbe {
               continue;
             }
 
-            ld = dyn_cast<LoadInst>(fnPointer->getOperand(0));
+            ld = dyn_cast<LoadInst>(fnPointer);
             if(ld == NULL)
               continue;
 
@@ -304,9 +307,7 @@ namespace gbe {
                 User *theUser = iter->getUser();
 #endif
                 if(StoreInst *st = dyn_cast<StoreInst>(theUser)) {
-                  bt = dyn_cast<BitCastInst>(st->getValueOperand());
-                  if(bt)
-                    v = bt->getOperand(0);
+                  v = st->getValueOperand()->stripPointerCasts();
                 }
               }
               if(blocks.find(v) == blocks.end()) {
@@ -339,9 +340,7 @@ namespace gbe {
             Type *type = CI->getArgOperand(block_index)->getType();
             if(type->isIntegerTy())
                 block_index = 6;
-            Value *block = CI->getArgOperand(block_index);
-            while(isa<BitCastInst>(block))
-               block = dyn_cast<BitCastInst>(block)->getOperand(0);
+            Value *block = CI->getArgOperand(block_index)->stripPointerCasts();
             LoadInst *ld = dyn_cast<LoadInst>(block);
             Value *v = NULL;
             if(ld) {
@@ -353,9 +352,7 @@ namespace gbe {
                 User *theUser = iter->getUser();
 #endif
                 if(StoreInst *st = dyn_cast<StoreInst>(theUser)) {
-                  BitCastInst *bt = dyn_cast<BitCastInst>(st->getValueOperand());
-                  if(bt)
-                    v = bt->getOperand(0);
+                  v = st->getValueOperand()->stripPointerCasts();
                 }
               }
               if(blocks.find(v) == blocks.end()) {
@@ -378,15 +375,20 @@ namespace gbe {
             if( fn->isVarArg() ) {
               //enqueue function with slm, convert to __gen_enqueue_kernel_slm call
               //store the slm information to a alloca address.
-              int start = block_index + 1;
+              int start = block_index + 1 + 1;  //the first is count, skip
               int count = CI->getNumArgOperands() - start;
               Type *intTy = IntegerType::get(mod->getContext(), 32);
+              Type *int64Ty = IntegerType::get(mod->getContext(), 64);
 
               AllocaInst *AI = builder.CreateAlloca(intTy, ConstantInt::get(intTy, count));
 
               for(uint32_t i = start; i < CI->getNumArgOperands(); i++) {
                 Value *ptr = builder.CreateGEP(AI, ConstantInt::get(intTy, i-start));
-                builder.CreateStore(CI->getArgOperand(i), ptr);
+                Value *argSize = CI->getArgOperand(i);
+                if (argSize->getType() == int64Ty) {
+                  argSize = builder.CreateTrunc(argSize, intTy);
+                }
+                builder.CreateStore(argSize, ptr);
               }
               SmallVector<Value*, 16> args(CI->op_begin(), CI->op_begin() + 3);
               args.push_back(CI->getArgOperand(block_index));
@@ -394,8 +396,8 @@ namespace gbe {
               args.push_back(AI);
 
               std::vector<Type *> ParamTys;
-              for (Value** I = args.begin(); I != args.end(); ++I)
-                ParamTys.push_back((*I)->getType());
+              for (Value** iter = args.begin(); iter != args.end(); ++iter)
+                ParamTys.push_back((*iter)->getType());
               CallInst* newCI = builder.CreateCall(cast<llvm::Function>(mod->getOrInsertFunction(
                               "__gen_enqueue_kernel_slm", FunctionType::get(intTy, ParamTys, false))), args);
               CI->replaceAllUsesWith(newCI);
diff --git a/backend/src/llvm/llvm_gen_backend.cpp b/backend/src/llvm/llvm_gen_backend.cpp
index 55b0abbd..c93d89cc 100644
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -740,6 +740,8 @@ namespace gbe
     DECL_VISIT_FN(AtomicCmpXchgInst, AtomicCmpXchgInst);
 #undef DECL_VISIT_FN
 
+    // Emit rounding instructions from gen native function
+    void emitRoundingCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode);
     // Emit unary instructions from gen native function
     void emitUnaryCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode, ir::Type = ir::TYPE_FLOAT);
     // Emit unary instructions from gen native function
@@ -972,7 +974,7 @@ namespace gbe
             CallInst *ci = dyn_cast<CallInst>(theUser);
             pointer = ci ? ci->getArgOperand(0) : NULL;
           } else {
-            theUser->dump();
+            //theUser->dump();
             GBE_ASSERT(0 && "Unknown instruction operating on pointers\n");
           }
 
@@ -1120,7 +1122,7 @@ namespace gbe
           pointerBaseMap.insert(std::make_pair(ptr, basePhi));
           return basePhi;
       } else {
-        ptr->dump();
+        //ptr->dump();
         GBE_ASSERT(0 && "Unhandled instruction in getPointerBase\n");
         return ptr;
       }
@@ -1201,7 +1203,7 @@ namespace gbe
           BtiValueMap.insert(std::make_pair(Val, btiPhi));
           return btiPhi;
         } else {
-          Val->dump();
+          //Val->dump();
           GBE_ASSERT(0 && "Unhandled instruction in getBtiRegister\n");
           return Val;
         }
@@ -1655,7 +1657,7 @@ namespace gbe
         }
       default:
         {
-          c->dump();
+          //c->dump();
           NOT_IMPLEMENTED;
         }
     }
@@ -1907,7 +1909,7 @@ namespace gbe
   ir::ImmediateIndex GenWriter::processConstantImmIndex(Constant *CPV, int32_t index) {
     if (dyn_cast<ConstantExpr>(CPV) == NULL)
       return processConstantImmIndexImpl(CPV, index);
-    CPV->dump();
+    //CPV->dump();
     GBE_ASSERT(0 && "unsupported constant.\n");
     return ctx.newImmediate((uint32_t)0);
   }
@@ -4154,6 +4156,21 @@ namespace gbe
     };
   }
 
+  void GenWriter::emitRoundingCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode) {
+    if (I.getType()->isHalfTy()) {
+      const ir::Register src = this->getRegister(I.getOperand(0));
+      const ir::Register srcFloat = ctx.reg(ir::FAMILY_DWORD);
+      const ir::Register dstFloat = ctx.reg(ir::FAMILY_DWORD);
+      const ir::Register dst = this->getRegister(&I);
+      ctx.F16TO32(ir::TYPE_FLOAT, ir::TYPE_U16, srcFloat, src);
+      ctx.ALU1(opcode, ir::TYPE_FLOAT, dstFloat, srcFloat);
+      ctx.F32TO16(ir::TYPE_U16, ir::TYPE_FLOAT, dst, dstFloat);
+    } else {
+      GBE_ASSERT(I.getType()->isFloatTy());
+      this->emitUnaryCallInst(I,CS,opcode);
+    }
+  }
+
   void GenWriter::emitUnaryCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode, ir::Type type) {
     CallSite::arg_iterator AI = CS.arg_begin();
 #if GBE_DEBUG
@@ -4738,10 +4755,10 @@ namespace gbe
           }
           break;
           case Intrinsic::sqrt: this->emitUnaryCallInst(I,CS,ir::OP_SQR); break;
-          case Intrinsic::ceil: this->emitUnaryCallInst(I,CS,ir::OP_RNDU); break;
-          case Intrinsic::trunc: this->emitUnaryCallInst(I,CS,ir::OP_RNDZ); break;
-          case Intrinsic::rint: this->emitUnaryCallInst(I,CS,ir::OP_RNDE); break;
-          case Intrinsic::floor: this->emitUnaryCallInst(I,CS,ir::OP_RNDD); break;
+          case Intrinsic::ceil: this->emitRoundingCallInst(I,CS,ir::OP_RNDU); break;
+          case Intrinsic::trunc: this->emitRoundingCallInst(I,CS,ir::OP_RNDZ); break;
+          case Intrinsic::rint: this->emitRoundingCallInst(I,CS,ir::OP_RNDE); break;
+          case Intrinsic::floor: this->emitRoundingCallInst(I,CS,ir::OP_RNDD); break;
           case Intrinsic::sin: this->emitUnaryCallInst(I,CS,ir::OP_SIN); break;
           case Intrinsic::cos: this->emitUnaryCallInst(I,CS,ir::OP_COS); break;
           case Intrinsic::log2: this->emitUnaryCallInst(I,CS,ir::OP_LOG); break;
@@ -5531,9 +5548,13 @@ namespace gbe
           case GEN_OCL_ENQUEUE_SET_NDRANGE_INFO:
           {
             GBE_ASSERT(AI != AE);
+            Value *dstValue;
+            if(I.hasStructRetAttr())
+              dstValue = *AI++;
+            else
+              dstValue = &I;
             Value *srcValue = *AI;
             ++AI;
-            Value *dstValue = &I;
             regTranslator.newValueProxy(srcValue, dstValue);
             break;
           }
diff --git a/backend/src/llvm/llvm_profiling.cpp b/backend/src/llvm/llvm_profiling.cpp
index f7e4cc53..2d2ee119 100644
--- a/backend/src/llvm/llvm_profiling.cpp
+++ b/backend/src/llvm/llvm_profiling.cpp
@@ -162,12 +162,19 @@ namespace gbe
       /* Add the timestamp store function call. */
       // __gen_ocl_store_timestamp(int nth, int type);
       Value *Args[2] = {ConstantInt::get(intTy, pointNum++), ConstantInt::get(intTy, profilingType)};
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
       builder->CreateCall(cast<llvm::Function>(module->getOrInsertFunction(
               "__gen_ocl_calc_timestamp", Type::getVoidTy(module->getContext()),
               IntegerType::getInt32Ty(module->getContext()),
+              IntegerType::getInt32Ty(module->getContext()))),
+              ArrayRef<Value*>(Args));
+#else
+      builder->CreateCall(cast<llvm::Function>(module->getOrInsertFunction(
+              "__gen_ocl_calc_timestamp", Type::getVoidTy(module->getContext()),
               IntegerType::getInt32Ty(module->getContext()),
-              NULL)),
+              IntegerType::getInt32Ty(module->getContext()), nullptr)),
               ArrayRef<Value*>(Args));
+#endif
     }
     /* We insert one store_profiling at the end of the last block to hold the place. */
     llvm::Function::iterator BE = F.end();
@@ -177,12 +184,19 @@ namespace gbe
     builder->SetInsertPoint(&*retInst);
     Value *Args2[2] = {profilingBuf, ConstantInt::get(intTy, profilingType)};
 
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
     builder->CreateCall(cast<llvm::Function>(module->getOrInsertFunction(
             "__gen_ocl_store_profiling", Type::getVoidTy(module->getContext()),
             ptrTy,
-            IntegerType::getInt32Ty(module->getContext()),
-            NULL)),
+            IntegerType::getInt32Ty(module->getContext()))),
             ArrayRef<Value*>(Args2));
+#else
+    builder->CreateCall(cast<llvm::Function>(module->getOrInsertFunction(
+            "__gen_ocl_store_profiling", Type::getVoidTy(module->getContext()),
+            ptrTy,
+            IntegerType::getInt32Ty(module->getContext()), nullptr)),
+            ArrayRef<Value*>(Args2));
+#endif
 
     delete builder;
     return changed;
diff --git a/backend/src/llvm/llvm_sampler_fix.cpp b/backend/src/llvm/llvm_sampler_fix.cpp
index c2497558..c9ec8175 100644
--- a/backend/src/llvm/llvm_sampler_fix.cpp
+++ b/backend/src/llvm/llvm_sampler_fix.cpp
@@ -81,7 +81,11 @@ namespace gbe {
 
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
           Module *M = I->getParent()->getParent()->getParent();
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
+          Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType());
+#else
           Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType(), nullptr);
+#endif
           Value *samplerVal = Builder.CreateCall(samplerCvt, {I->getOperand(0)});
 #else
           Value *samplerVal = I->getOperand(0);
@@ -119,7 +123,11 @@ namespace gbe {
           Builder.SetInsertPoint(I);
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
           Module *M = I->getParent()->getParent()->getParent();
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 50
+          Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType());
+#else
           Value* samplerCvt = M->getOrInsertFunction("__gen_ocl_sampler_to_int", i32Ty, I->getOperand(0)->getType(), nullptr);
+#endif
           Value *samplerVal = Builder.CreateCall(samplerCvt, {I->getOperand(0)});
 #else
           Value *samplerVal = I->getOperand(0);

From a746c9254216b08a52232c95a1ddd270531334bb Mon Sep 17 00:00:00 2001
From: Yang Rong <rong.r.yang@intel.com>
Date: Tue, 22 Aug 2017 12:33:55 +0800
Subject: [PATCH 51/52] GBE: remove static context to fix Segmentation fault.

If application has static clProgram, when application exit, the static
context has been deleted before delete static clProgram will cause
segmentation fault.
As the global static context is just for link, use the individual context
of each llvm module, when link the llvm module, generate the new llvm
module from src.

V2: fix llvm 3.8 build error and CleanLlvmResource delete bug.
Signed-off-by: Yang Rong <rong.r.yang@intel.com>
Reviewed-by: Ruiling Song <ruiling.song@intel.com>
---
 backend/src/backend/gen_program.cpp | 46 ++++++++++++++++++++++++++-----------
 backend/src/backend/program.cpp     | 15 ++++++------
 backend/src/llvm/llvm_to_gen.cpp    |  7 ------
 backend/src/llvm/llvm_to_gen.hpp    |  4 ----
 4 files changed, 39 insertions(+), 33 deletions(-)

diff --git a/backend/src/backend/gen_program.cpp b/backend/src/backend/gen_program.cpp
index 6ba2e549..e06ed40c 100644
--- a/backend/src/backend/gen_program.cpp
+++ b/backend/src/backend/gen_program.cpp
@@ -28,6 +28,8 @@
 #include "llvm/IR/Module.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm-c/Linker.h"
+#include "llvm-c/BitReader.h"
+#include "llvm-c/BitWriter.h"
 #include "llvm/Transforms/Utils/Cloning.h"
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
 #include "llvm/Bitcode/BitcodeWriter.h"
@@ -126,15 +128,24 @@ namespace gbe {
 
   void GenProgram::CleanLlvmResource(void){
 #ifdef GBE_COMPILER_AVAILABLE
+    llvm::LLVMContext* ctx = NULL;
     if(module){
+      ctx = &((llvm::Module*)module)->getContext();
+      (void)ctx;
       delete (llvm::Module*)module;
       module = NULL;
     }
-
+//llvm's version < 3.9, ctx is global ctx, can't be deleted.
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
+    //each module's context is individual, just delete it, ignaor llvm_ctx.
+    if (ctx != NULL)
+      delete ctx;
+#else
     if(llvm_ctx){
       delete (llvm::LLVMContext*)llvm_ctx;
       llvm_ctx = NULL;
     }
+#endif
 #endif
   }
 
@@ -353,19 +364,19 @@ namespace gbe {
     binary_content.assign(binary+1, size-1);
     llvm::StringRef llvm_bin_str(binary_content);
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-    llvm::LLVMContext& c = GBEGetLLVMContext();
+    llvm::LLVMContext *c = new llvm::LLVMContext;
 #else
-    llvm::LLVMContext& c = llvm::getGlobalContext();
+    llvm::LLVMContext *c = &llvm::getGlobalContext();
 #endif
     llvm::SMDiagnostic Err;
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
     std::unique_ptr<llvm::MemoryBuffer> memory_buffer = llvm::MemoryBuffer::getMemBuffer(llvm_bin_str, "llvm_bin_str");
     acquireLLVMContextLock();
-    llvm::Module* module = llvm::parseIR(memory_buffer->getMemBufferRef(), Err, c).release();
+    llvm::Module* module = llvm::parseIR(memory_buffer->getMemBufferRef(), Err, *c).release();
 #else
     llvm::MemoryBuffer* memory_buffer = llvm::MemoryBuffer::getMemBuffer(llvm_bin_str, "llvm_bin_str");
     acquireLLVMContextLock();
-    llvm::Module* module = llvm::ParseIR(memory_buffer, Err, c);
+    llvm::Module* module = llvm::ParseIR(memory_buffer, Err, *c);
 #endif
     // if load 32 bit spir binary, the triple should be spir-unknown-unknown.
     llvm::Triple triple(module->getTargetTriple());
@@ -506,23 +517,31 @@ namespace gbe {
     using namespace gbe;
     char* errMsg = NULL;
     if(((GenProgram*)dst_program)->module == NULL){
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
+#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
+      LLVMModuleRef modRef;
+      LLVMParseBitcodeInContext2(wrap(new llvm::LLVMContext()),
+                                 LLVMWriteBitcodeToMemoryBuffer(wrap((llvm::Module*)((GenProgram*)src_program)->module)),
+                                 &modRef);
+      ((GenProgram*)dst_program)->module = llvm::unwrap(modRef);
+#elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 38
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
 #else
       ((GenProgram*)dst_program)->module = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module);
 #endif
       errSize = 0;
     } else {
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-      // Src now will be removed automatically. So clone it.
-      llvm::Module* src = llvm::CloneModule((llvm::Module*)((GenProgram*)src_program)->module).release();
-#else
       llvm::Module* src = (llvm::Module*)((GenProgram*)src_program)->module;
-#endif
       llvm::Module* dst = (llvm::Module*)((GenProgram*)dst_program)->module;
-
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-      if (LLVMLinkModules2(wrap(dst), wrap(src))) {
+      if (&src->getContext() != &dst->getContext()) {
+        LLVMModuleRef modRef;
+        LLVMParseBitcodeInContext2(wrap(&dst->getContext()),
+                                    LLVMWriteBitcodeToMemoryBuffer(wrap(src)),
+                                    &modRef);
+        src = llvm::unwrap(modRef);
+      }
+      llvm::Module* clone = llvm::CloneModule(src).release();
+      if (LLVMLinkModules2(wrap(dst), wrap(clone))) {
 #elif LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
       if (LLVMLinkModules(wrap(dst), wrap(src), LLVMLinkerPreserveSource_Removed, &errMsg)) {
 #else
@@ -536,7 +555,6 @@ namespace gbe {
         return true;
       }
     }
-    // Everything run fine
 #endif
     return false;
   }
diff --git a/backend/src/backend/program.cpp b/backend/src/backend/program.cpp
index c06ae5a1..c37c5951 100644
--- a/backend/src/backend/program.cpp
+++ b/backend/src/backend/program.cpp
@@ -1104,22 +1104,22 @@ EXTEND_QUOTE:
       return NULL;
 
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-    llvm::LLVMContext& c = GBEGetLLVMContext();
+    llvm::LLVMContext *c = new llvm::LLVMContext;
 #else
-    llvm::LLVMContext& c = llvm::getGlobalContext();
+    llvm::LLVMContext *c = &llvm::getGlobalContext();
 #endif
     // Get the module from its file
     llvm::SMDiagnostic errDiag;
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 36
-    llvm::Module *module = parseIRFile(fileName, errDiag, c).release();
+    llvm::Module *module = parseIRFile(fileName, errDiag, *c).release();
 #else
-    llvm::Module *module = ParseIRFile(fileName, errDiag, c);
+    llvm::Module *module = ParseIRFile(fileName, errDiag, *c);
 #endif
 
     int optLevel = 1;
 
     //module will be delete in programCleanLlvmResource
-    p = gbe_program_new_from_llvm(deviceID, module, &c, NULL,
+    p = gbe_program_new_from_llvm(deviceID, module, c, NULL,
                                   string_size, err, err_size, optLevel, NULL);
     if (OCL_OUTPUT_BUILD_LOG && err && *err_size)
       llvm::errs() << err << "\n";
@@ -1152,11 +1152,10 @@ EXTEND_QUOTE:
 
     gbe_program p;
     acquireLLVMContextLock();
-    //FIXME: if use new allocated context to link two modules there would be context mismatch
-    //for some functions, so we use global context now, need switch to new context later.
+
     llvm::Module * out_module;
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-    llvm::LLVMContext* llvm_ctx = &GBEGetLLVMContext();
+    llvm::LLVMContext* llvm_ctx = new llvm::LLVMContext;
 #else
     llvm::LLVMContext* llvm_ctx = &llvm::getGlobalContext();
 #endif
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index 8546f730..7f7deffe 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -46,13 +46,6 @@ namespace gbe
   BVAR(OCL_OUTPUT_CFG_GEN_IR, false);
   using namespace llvm;
 
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-  llvm::LLVMContext& GBEGetLLVMContext() {
-    static llvm::LLVMContext GBEContext;
-    return GBEContext;
-  }
-#endif
-
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 37
   #define TARGETLIBRARY  TargetLibraryInfoImpl
 #else
diff --git a/backend/src/llvm/llvm_to_gen.hpp b/backend/src/llvm/llvm_to_gen.hpp
index 73e88194..d2247bbf 100644
--- a/backend/src/llvm/llvm_to_gen.hpp
+++ b/backend/src/llvm/llvm_to_gen.hpp
@@ -37,10 +37,6 @@ namespace gbe {
 		  optLevel 0 equal to clang -O1 and 1 equal to clang -O2*/
   bool llvmToGen(ir::Unit &unit, const void* module,
                  int optLevel, bool strictMath, int profiling, std::string &errors);
-#if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 39
-  extern llvm::LLVMContext& GBEGetLLVMContext();
-#endif
-
 } /* namespace gbe */
 
 #endif /* __GBE_IR_LLVM_TO_GEN_HPP__ */

From a97fcb17ca30778cb824b4a457668c9e3bea4f34 Mon Sep 17 00:00:00 2001
From: "Song, Ruiling" <ruiling.song@intel.com>
Date: Wed, 13 Sep 2017 14:07:26 +0800
Subject: [PATCH 52/52] backend: use simd-1 for scalar dst in indirectMov.

This fix a failure introduced by load-store optimization on IVB.
the test case is: builtin_kernel_block_motion_estimate_intel

Signed-off-by: Ruiling Song <ruiling.song@intel.com>
Reviewed-by: Yang Rong <rong.r.yang@intel.com>
---
 backend/src/backend/gen_context.cpp | 38 +++++++++++++++++++++++--------------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/backend/src/backend/gen_context.cpp b/backend/src/backend/gen_context.cpp
index bb104cf9..874e79f7 100644
--- a/backend/src/backend/gen_context.cpp
+++ b/backend/src/backend/gen_context.cpp
@@ -1949,23 +1949,33 @@ namespace gbe
     indirect_src = GenRegister::indirect(dst.type, 0, GEN_WIDTH_1,
                                          GEN_VERTICAL_STRIDE_ONE_DIMENSIONAL, GEN_HORIZONTAL_STRIDE_0);
 
-    p->push();
-      p->curr.execWidth = 8;
-      p->curr.quarterControl = GEN_COMPRESSION_Q1;
-      p->MOV(a0, tmp);
-      p->MOV(dst, indirect_src);
-    p->pop();
-
-    if (simdWidth == 16) {
+    if (sel->isScalarReg(dst.reg())) {
+      p->push();
+        p->curr.execWidth = 1;
+        p->curr.predicate = GEN_PREDICATE_NONE;
+        p->curr.noMask = 1;
+        p->MOV(a0, tmp);
+        p->MOV(dst, indirect_src);
+      p->pop();
+    } else {
       p->push();
         p->curr.execWidth = 8;
-        p->curr.quarterControl = GEN_COMPRESSION_Q2;
-
-        const GenRegister nextDst = GenRegister::Qn(dst, 1);
-        const GenRegister nextOffset = GenRegister::Qn(tmp, 1);
-        p->MOV(a0, nextOffset);
-        p->MOV(nextDst, indirect_src);
+        p->curr.quarterControl = GEN_COMPRESSION_Q1;
+        p->MOV(a0, tmp);
+        p->MOV(dst, indirect_src);
       p->pop();
+
+      if (simdWidth == 16) {
+        p->push();
+          p->curr.execWidth = 8;
+          p->curr.quarterControl = GEN_COMPRESSION_Q2;
+
+          const GenRegister nextDst = GenRegister::Qn(dst, 1);
+          const GenRegister nextOffset = GenRegister::Qn(tmp, 1);
+          p->MOV(a0, nextOffset);
+          p->MOV(nextDst, indirect_src);
+        p->pop();
+      }
     }
   }
 
