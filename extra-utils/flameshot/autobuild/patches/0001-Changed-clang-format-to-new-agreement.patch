From 7f22d0cfefc13becfeb212d030602ca73213f8e3 Mon Sep 17 00:00:00 2001
From: Jeremy Borgman <borgman.jeremy@pm.me>
Date: Wed, 23 Sep 2020 20:39:30 -0500
Subject: [PATCH] Changed clang format to new agreement

---
 .clang-format                                 |    4 +
 .github/workflows/clang-format.yml            |    2 +-
 external/Qt-Color-Widgets/src/color_utils.cpp |   88 +-
 external/Qt-Color-Widgets/src/color_wheel.cpp |  814 ++++----
 .../singleapplication/singleapplication.cpp   |  665 ++++---
 .../singleapplication/singleapplication.h     |  170 +-
 .../singleapplication/singleapplication_p.h   |   62 +-
 src/cli/commandargument.cpp                   |   30 +-
 src/cli/commandargument.h                     |   20 +-
 src/cli/commandlineparser.cpp                 |  619 +++---
 src/cli/commandlineparser.h                   |  103 +-
 src/cli/commandoption.cpp                     |  102 +-
 src/cli/commandoption.h                       |   58 +-
 src/config/buttonlistview.cpp                 |  132 +-
 src/config/buttonlistview.h                   |   16 +-
 src/config/clickablelabel.cpp                 |    7 +-
 src/config/clickablelabel.h                   |   10 +-
 src/config/configwindow.cpp                   |   96 +-
 src/config/configwindow.h                     |   16 +-
 src/config/extendedslider.cpp                 |   43 +-
 src/config/extendedslider.h                   |   16 +-
 src/config/filenameeditor.cpp                 |  152 +-
 src/config/filenameeditor.h                   |   36 +-
 src/config/geneneralconf.cpp                  |  527 +++---
 src/config/geneneralconf.h                    |   74 +-
 src/config/strftimechooserwidget.cpp          |   83 +-
 src/config/strftimechooserwidget.h            |    8 +-
 src/config/uicoloreditor.cpp                  |  266 ++-
 src/config/uicoloreditor.h                    |   44 +-
 src/config/visualseditor.cpp                  |  104 +-
 src/config/visualseditor.h                    |   20 +-
 src/core/capturerequest.cpp                   |   78 +-
 src/core/capturerequest.h                     |   81 +-
 src/core/controller.cpp                       |  397 ++--
 src/core/controller.h                         |   72 +-
 src/core/flameshotdbusadapter.cpp             |  136 +-
 src/core/flameshotdbusadapter.h               |   39 +-
 src/core/globalshortcutfilter.cpp             |   41 +-
 src/core/globalshortcutfilter.h               |   20 +-
 src/main.cpp                                  |  807 ++++----
 src/tools/abstractactiontool.cpp              |   67 +-
 src/tools/abstractactiontool.h                |   34 +-
 src/tools/abstractpathtool.cpp                |   85 +-
 src/tools/abstractpathtool.h                  |   46 +-
 src/tools/abstracttwopointtool.cpp            |  162 +-
 src/tools/abstracttwopointtool.h              |   48 +-
 src/tools/arrow/arrowtool.cpp                 |  154 +-
 src/tools/arrow/arrowtool.h                   |   28 +-
 src/tools/capturecontext.cpp                  |   13 +-
 src/tools/capturecontext.h                    |   44 +-
 src/tools/capturetool.h                       |  258 +--
 src/tools/circle/circletool.cpp               |   68 +-
 src/tools/circle/circletool.h                 |   28 +-
 src/tools/circlecount/circlecounttool.cpp     |  157 +-
 src/tools/circlecount/circlecounttool.h       |   30 +-
 src/tools/copy/copytool.cpp                   |   39 +-
 src/tools/copy/copytool.h                     |   18 +-
 src/tools/exit/exittool.cpp                   |   39 +-
 src/tools/exit/exittool.h                     |   18 +-
 src/tools/imgur/imguruploader.cpp             |  251 ++-
 src/tools/imgur/imguruploader.h               |   50 +-
 src/tools/imgur/imguruploadertool.cpp         |   46 +-
 src/tools/imgur/imguruploadertool.h           |   22 +-
 src/tools/launcher/applaunchertool.cpp        |   46 +-
 src/tools/launcher/applaunchertool.h          |   22 +-
 src/tools/launcher/applauncherwidget.cpp      |  335 ++--
 src/tools/launcher/applauncherwidget.h        |   42 +-
 src/tools/launcher/launcheritemdelegate.cpp   |   71 +-
 src/tools/launcher/launcheritemdelegate.h     |   14 +-
 src/tools/launcher/openwithprogram.cpp        |   38 +-
 src/tools/launcher/openwithprogram.h          |    3 +-
 src/tools/launcher/terminallauncher.cpp       |   52 +-
 src/tools/launcher/terminallauncher.h         |   12 +-
 src/tools/line/linetool.cpp                   |   70 +-
 src/tools/line/linetool.h                     |   28 +-
 src/tools/marker/markertool.cpp               |   83 +-
 src/tools/marker/markertool.h                 |   30 +-
 src/tools/move/movetool.cpp                   |   39 +-
 src/tools/move/movetool.h                     |   18 +-
 src/tools/pencil/penciltool.cpp               |   68 +-
 src/tools/pencil/penciltool.h                 |   28 +-
 src/tools/pin/pintool.cpp                     |   58 +-
 src/tools/pin/pintool.h                       |   24 +-
 src/tools/pin/pinwidget.cpp                   |  120 +-
 src/tools/pin/pinwidget.h                     |   36 +-
 src/tools/pixelate/pixelatetool.cpp           |  125 +-
 src/tools/pixelate/pixelatetool.h             |   28 +-
 src/tools/rectangle/rectangletool.cpp         |   73 +-
 src/tools/rectangle/rectangletool.h           |   28 +-
 src/tools/redo/redotool.cpp                   |   39 +-
 src/tools/redo/redotool.h                     |   18 +-
 src/tools/save/savetool.cpp                   |   61 +-
 src/tools/save/savetool.h                     |   18 +-
 src/tools/selection/selectiontool.cpp         |   76 +-
 src/tools/selection/selectiontool.h           |   30 +-
 src/tools/sizeindicator/sizeindicatortool.cpp |   37 +-
 src/tools/sizeindicator/sizeindicatortool.h   |   18 +-
 src/tools/text/textconfig.cpp                 |  139 +-
 src/tools/text/textconfig.h                   |   34 +-
 src/tools/text/texttool.cpp                   |  307 ++-
 src/tools/text/texttool.h                     |   80 +-
 src/tools/text/textwidget.cpp                 |  102 +-
 src/tools/text/textwidget.h                   |   26 +-
 src/tools/toolfactory.cpp                     |  138 +-
 src/tools/toolfactory.h                       |   12 +-
 src/tools/undo/undotool.cpp                   |   39 +-
 src/tools/undo/undotool.h                     |   18 +-
 src/utils/colorutils.cpp                      |   29 +-
 src/utils/colorutils.h                        |    6 +-
 src/utils/confighandler.cpp                   |  584 +++---
 src/utils/confighandler.h                     |   96 +-
 src/utils/dbusutils.cpp                       |   72 +-
 src/utils/dbusutils.h                         |   14 +-
 src/utils/desktopfileparse.cpp                |  212 +--
 src/utils/desktopfileparse.h                  |   70 +-
 src/utils/desktopinfo.cpp                     |   48 +-
 src/utils/desktopinfo.h                       |   32 +-
 src/utils/filenamehandler.cpp                 |  136 +-
 src/utils/filenamehandler.h                   |   26 +-
 src/utils/globalvalues.cpp                    |    5 +-
 src/utils/globalvalues.h                      |    3 +-
 src/utils/pathinfo.cpp                        |   28 +-
 src/utils/pathinfo.h                          |    9 +-
 src/utils/screengrabber.cpp                   |  167 +-
 src/utils/screengrabber.h                     |   10 +-
 src/utils/screenshotsaver.cpp                 |  136 +-
 src/utils/screenshotsaver.h                   |   12 +-
 src/utils/systemnotification.cpp              |   75 +-
 src/utils/systemnotification.h                |   16 +-
 src/utils/waylandutils.cpp                    |    4 +-
 src/utils/waylandutils.h                      |    4 +-
 src/widgets/capture/buttonhandler.cpp         |  582 +++---
 src/widgets/capture/buttonhandler.h           |  101 +-
 src/widgets/capture/capturebutton.cpp         |   70 +-
 src/widgets/capture/capturebutton.h           |   24 +-
 src/widgets/capture/capturetoolbutton.cpp     |  191 +-
 src/widgets/capture/capturetoolbutton.h       |  102 +-
 src/widgets/capture/capturewidget.cpp         | 1654 ++++++++---------
 src/widgets/capture/capturewidget.h           |  188 +-
 src/widgets/capture/colorpicker.cpp           |  146 +-
 src/widgets/capture/colorpicker.h             |   26 +-
 src/widgets/capture/hovereventfilter.cpp      |   27 +-
 src/widgets/capture/hovereventfilter.h        |   10 +-
 src/widgets/capture/modificationcommand.cpp   |   16 +-
 src/widgets/capture/modificationcommand.h     |   10 +-
 src/widgets/capture/notifierbox.cpp           |   68 +-
 src/widgets/capture/notifierbox.h             |   20 +-
 src/widgets/capture/selectionwidget.cpp       |  179 +-
 src/widgets/capture/selectionwidget.h         |   76 +-
 src/widgets/capturelauncher.cpp               |  220 ++-
 src/widgets/capturelauncher.h                 |   26 +-
 src/widgets/draggablewidgetmaker.cpp          |   88 +-
 src/widgets/draggablewidgetmaker.h            |   16 +-
 src/widgets/imagelabel.cpp                    |   90 +-
 src/widgets/imagelabel.h                      |   24 +-
 src/widgets/infowindow.cpp                    |  183 +-
 src/widgets/infowindow.h                      |   16 +-
 src/widgets/loadspinner.cpp                   |  105 +-
 src/widgets/loadspinner.h                     |   32 +-
 src/widgets/notificationwidget.cpp            |   69 +-
 src/widgets/notificationwidget.h              |   22 +-
 src/widgets/orientablepushbutton.cpp          |   56 +-
 src/widgets/orientablepushbutton.h            |   34 +-
 src/widgets/panel/sidepanelwidget.cpp         |  280 ++-
 src/widgets/panel/sidepanelwidget.h           |   54 +-
 src/widgets/panel/utilitypanel.cpp            |  135 +-
 src/widgets/panel/utilitypanel.h              |   36 +-
 167 files changed, 8351 insertions(+), 8865 deletions(-)

diff --git a/.clang-format b/.clang-format
index e5e8ccc2..c4ac57ae 100644
--- a/.clang-format
+++ b/.clang-format
@@ -1,2 +1,6 @@
 Language: Cpp
 BasedOnStyle: Mozilla
+IndentWidth: 4
+AccessModifierOffset: -4
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
diff --git a/.github/workflows/clang-format.yml b/.github/workflows/clang-format.yml
index 2b5c36e1..24382ae9 100644
--- a/.github/workflows/clang-format.yml
+++ b/.github/workflows/clang-format.yml
@@ -14,4 +14,4 @@ jobs:
         #exclude: './third_party ./external'
         extensions: 'h,cpp'
         clangFormatVersion: 11
-        style: mozilla
+        style: file
diff --git a/external/Qt-Color-Widgets/src/color_utils.cpp b/external/Qt-Color-Widgets/src/color_utils.cpp
index e459381d..205d8f7c 100644
--- a/external/Qt-Color-Widgets/src/color_utils.cpp
+++ b/external/Qt-Color-Widgets/src/color_utils.cpp
@@ -24,59 +24,57 @@
 namespace color_widgets {
 namespace detail {
 
-QColor
-color_from_lch(qreal hue, qreal chroma, qreal luma, qreal alpha)
+QColor color_from_lch(qreal hue, qreal chroma, qreal luma, qreal alpha)
 {
-  qreal h1 = hue * 6;
-  qreal x = chroma * (1 - qAbs(std::fmod(h1, 2) - 1));
-  QColor col;
-  if (h1 >= 0 && h1 < 1)
-    col = QColor::fromRgbF(chroma, x, 0);
-  else if (h1 < 2)
-    col = QColor::fromRgbF(x, chroma, 0);
-  else if (h1 < 3)
-    col = QColor::fromRgbF(0, chroma, x);
-  else if (h1 < 4)
-    col = QColor::fromRgbF(0, x, chroma);
-  else if (h1 < 5)
-    col = QColor::fromRgbF(x, 0, chroma);
-  else if (h1 < 6)
-    col = QColor::fromRgbF(chroma, 0, x);
+    qreal h1 = hue * 6;
+    qreal x = chroma * (1 - qAbs(std::fmod(h1, 2) - 1));
+    QColor col;
+    if (h1 >= 0 && h1 < 1)
+        col = QColor::fromRgbF(chroma, x, 0);
+    else if (h1 < 2)
+        col = QColor::fromRgbF(x, chroma, 0);
+    else if (h1 < 3)
+        col = QColor::fromRgbF(0, chroma, x);
+    else if (h1 < 4)
+        col = QColor::fromRgbF(0, x, chroma);
+    else if (h1 < 5)
+        col = QColor::fromRgbF(x, 0, chroma);
+    else if (h1 < 6)
+        col = QColor::fromRgbF(chroma, 0, x);
 
-  qreal m = luma - color_lumaF(col);
+    qreal m = luma - color_lumaF(col);
 
-  return QColor::fromRgbF(qBound(0.0, col.redF() + m, 1.0),
-                          qBound(0.0, col.greenF() + m, 1.0),
-                          qBound(0.0, col.blueF() + m, 1.0),
-                          alpha);
+    return QColor::fromRgbF(qBound(0.0, col.redF() + m, 1.0),
+                            qBound(0.0, col.greenF() + m, 1.0),
+                            qBound(0.0, col.blueF() + m, 1.0),
+                            alpha);
 }
 
-QColor
-color_from_hsl(qreal hue, qreal sat, qreal lig, qreal alpha)
+QColor color_from_hsl(qreal hue, qreal sat, qreal lig, qreal alpha)
 {
-  qreal chroma = (1 - qAbs(2 * lig - 1)) * sat;
-  qreal h1 = hue * 6;
-  qreal x = chroma * (1 - qAbs(std::fmod(h1, 2) - 1));
-  QColor col;
-  if (h1 >= 0 && h1 < 1)
-    col = QColor::fromRgbF(chroma, x, 0);
-  else if (h1 < 2)
-    col = QColor::fromRgbF(x, chroma, 0);
-  else if (h1 < 3)
-    col = QColor::fromRgbF(0, chroma, x);
-  else if (h1 < 4)
-    col = QColor::fromRgbF(0, x, chroma);
-  else if (h1 < 5)
-    col = QColor::fromRgbF(x, 0, chroma);
-  else if (h1 < 6)
-    col = QColor::fromRgbF(chroma, 0, x);
+    qreal chroma = (1 - qAbs(2 * lig - 1)) * sat;
+    qreal h1 = hue * 6;
+    qreal x = chroma * (1 - qAbs(std::fmod(h1, 2) - 1));
+    QColor col;
+    if (h1 >= 0 && h1 < 1)
+        col = QColor::fromRgbF(chroma, x, 0);
+    else if (h1 < 2)
+        col = QColor::fromRgbF(x, chroma, 0);
+    else if (h1 < 3)
+        col = QColor::fromRgbF(0, chroma, x);
+    else if (h1 < 4)
+        col = QColor::fromRgbF(0, x, chroma);
+    else if (h1 < 5)
+        col = QColor::fromRgbF(x, 0, chroma);
+    else if (h1 < 6)
+        col = QColor::fromRgbF(chroma, 0, x);
 
-  qreal m = lig - chroma / 2;
+    qreal m = lig - chroma / 2;
 
-  return QColor::fromRgbF(qBound(0.0, col.redF() + m, 1.0),
-                          qBound(0.0, col.greenF() + m, 1.0),
-                          qBound(0.0, col.blueF() + m, 1.0),
-                          alpha);
+    return QColor::fromRgbF(qBound(0.0, col.redF() + m, 1.0),
+                            qBound(0.0, col.greenF() + m, 1.0),
+                            qBound(0.0, col.blueF() + m, 1.0),
+                            alpha);
 }
 
 } // namespace detail
diff --git a/external/Qt-Color-Widgets/src/color_wheel.cpp b/external/Qt-Color-Widgets/src/color_wheel.cpp
index e188e28e..22915f54 100644
--- a/external/Qt-Color-Widgets/src/color_wheel.cpp
+++ b/external/Qt-Color-Widgets/src/color_wheel.cpp
@@ -34,9 +34,9 @@ namespace color_widgets {
 
 enum MouseStatus
 {
-  Nothing,
-  DragCircle,
-  DragSquare
+    Nothing,
+    DragCircle,
+    DragSquare
 };
 
 static const ColorWheel::DisplayFlags hard_default_flags =
@@ -48,517 +48,499 @@ static const double selector_radius = 6;
 class ColorWheel::Private
 {
 private:
-  ColorWheel* const w;
+    ColorWheel* const w;
 
 public:
-  qreal hue, sat, val;
-  qreal bgBrightness;
-  unsigned int wheel_width;
-  MouseStatus mouse_status;
-  QPixmap hue_ring;
-  QImage inner_selector;
-  DisplayFlags display_flags;
-  QColor (*color_from)(qreal, qreal, qreal, qreal);
-  QColor (*rainbow_from_hue)(qreal);
-  int max_size = 128;
-
-  explicit Private(ColorWheel* widget)
-    : w(widget)
-    , hue(0)
-    , sat(0)
-    , val(0)
-    , wheel_width(20)
-    , mouse_status(Nothing)
-    , display_flags(FLAGS_DEFAULT)
-    , color_from(&QColor::fromHsvF)
-    , rainbow_from_hue(&detail::rainbow_hsv)
-  {
-    QColor bgColor = widget->palette().window().color();
-    bgBrightness = color_widgets::detail::color_lumaF(bgColor);
-  }
-
-  /// Calculate outer wheel radius from idget center
-  qreal outer_radius() const
-  {
-    return qMin(w->geometry().width(), w->geometry().height()) / 2;
-  }
-
-  /// Calculate inner wheel radius from idget center
-  qreal inner_radius() const { return outer_radius() - wheel_width; }
-
-  /// Calculate the edge length of the inner square
-  qreal square_size() const { return inner_radius() * qSqrt(2); }
-
-  /// Calculate the height of the inner triangle
-  qreal triangle_height() const { return inner_radius() * 3 / 2; }
-
-  /// Calculate the side of the inner triangle
-  qreal triangle_side() const { return inner_radius() * qSqrt(3); }
-
-  /// return line from center to given point
-  QLineF line_to_point(const QPoint& p) const
-  {
-    return QLineF(
-      w->geometry().width() / 2, w->geometry().height() / 2, p.x(), p.y());
-  }
-
-  void render_square()
-  {
-    int width = qMin<int>(square_size(), max_size);
-    QSize size(width, width);
-    inner_selector = QImage(size, QImage::Format_RGB32);
-
-    for (int y = 0; y < width; ++y) {
-      for (int x = 0; x < width; ++x) {
-        inner_selector.setPixel(
-          x, y, color_from(hue, double(x) / width, double(y) / width, 1).rgb());
-      }
+    qreal hue, sat, val;
+    qreal bgBrightness;
+    unsigned int wheel_width;
+    MouseStatus mouse_status;
+    QPixmap hue_ring;
+    QImage inner_selector;
+    DisplayFlags display_flags;
+    QColor (*color_from)(qreal, qreal, qreal, qreal);
+    QColor (*rainbow_from_hue)(qreal);
+    int max_size = 128;
+
+    explicit Private(ColorWheel* widget)
+      : w(widget)
+      , hue(0)
+      , sat(0)
+      , val(0)
+      , wheel_width(20)
+      , mouse_status(Nothing)
+      , display_flags(FLAGS_DEFAULT)
+      , color_from(&QColor::fromHsvF)
+      , rainbow_from_hue(&detail::rainbow_hsv)
+    {
+        QColor bgColor = widget->palette().window().color();
+        bgBrightness = color_widgets::detail::color_lumaF(bgColor);
     }
-  }
-
-  /**
-   * \brief renders the selector as a triangle
-   * \note It's the same as a square with the edge with value=0 collapsed to a
-   * single point
-   */
-  void render_triangle()
-  {
-    QSizeF size = selector_size();
-    if (size.height() > max_size)
-      size *= max_size / size.height();
-
-    qreal ycenter = size.height() / 2;
-    inner_selector = QImage(size.toSize(), QImage::Format_RGB32);
-
-    for (int x = 0; x < inner_selector.width(); x++) {
-      qreal pval = x / size.height();
-      qreal slice_h = size.height() * pval;
-      for (int y = 0; y < inner_selector.height(); y++) {
-        qreal ymin = ycenter - slice_h / 2;
-        qreal psat = qBound(0.0, (y - ymin) / slice_h, 1.0);
-
-        inner_selector.setPixel(x, y, color_from(hue, psat, pval, 1).rgb());
-      }
+
+    /// Calculate outer wheel radius from idget center
+    qreal outer_radius() const
+    {
+        return qMin(w->geometry().width(), w->geometry().height()) / 2;
     }
-  }
-
-  /// Updates the inner image that displays the saturation-value selector
-  void render_inner_selector()
-  {
-    if (display_flags & ColorWheel::SHAPE_TRIANGLE)
-      render_triangle();
-    else
-      render_square();
-  }
-
-  /// Offset of the selector image
-  QPointF selector_image_offset()
-  {
-    if (display_flags & SHAPE_TRIANGLE)
-      return QPointF(-inner_radius(), -triangle_side() / 2);
-    return QPointF(-square_size() / 2, -square_size() / 2);
-  }
-
-  /**
-   * \brief Size of the selector when rendered to the screen
-   */
-  QSizeF selector_size()
-  {
-    if (display_flags & SHAPE_TRIANGLE)
-      return QSizeF(triangle_height(), triangle_side());
-    return QSizeF(square_size(), square_size());
-  }
-
-  /// Rotation of the selector image
-  qreal selector_image_angle()
-  {
-    if (display_flags & SHAPE_TRIANGLE) {
-      if (display_flags & ANGLE_ROTATING)
-        return -hue * 360 - 60;
-      return -150;
-    } else {
-      if (display_flags & ANGLE_ROTATING)
-        return -hue * 360 - 45;
-      else
-        return 180;
+
+    /// Calculate inner wheel radius from idget center
+    qreal inner_radius() const { return outer_radius() - wheel_width; }
+
+    /// Calculate the edge length of the inner square
+    qreal square_size() const { return inner_radius() * qSqrt(2); }
+
+    /// Calculate the height of the inner triangle
+    qreal triangle_height() const { return inner_radius() * 3 / 2; }
+
+    /// Calculate the side of the inner triangle
+    qreal triangle_side() const { return inner_radius() * qSqrt(3); }
+
+    /// return line from center to given point
+    QLineF line_to_point(const QPoint& p) const
+    {
+        return QLineF(
+          w->geometry().width() / 2, w->geometry().height() / 2, p.x(), p.y());
     }
-  }
-
-  /// Updates the outer ring that displays the hue selector
-  void render_ring()
-  {
-    hue_ring = QPixmap(outer_radius() * 2, outer_radius() * 2);
-    hue_ring.fill(Qt::transparent);
-    QPainter painter(&hue_ring);
-    painter.setRenderHint(QPainter::Antialiasing);
-    painter.setCompositionMode(QPainter::CompositionMode_Source);
-
-    const int hue_stops = 24;
-    QConicalGradient gradient_hue(0, 0, 0);
-    if (gradient_hue.stops().size() < hue_stops) {
-      for (double a = 0; a < 1.0; a += 1.0 / (hue_stops - 1)) {
-        gradient_hue.setColorAt(a, rainbow_from_hue(a));
-      }
-      gradient_hue.setColorAt(1, rainbow_from_hue(0));
+
+    void render_square()
+    {
+        int width = qMin<int>(square_size(), max_size);
+        QSize size(width, width);
+        inner_selector = QImage(size, QImage::Format_RGB32);
+
+        for (int y = 0; y < width; ++y) {
+            for (int x = 0; x < width; ++x) {
+                inner_selector.setPixel(
+                  x,
+                  y,
+                  color_from(hue, double(x) / width, double(y) / width, 1)
+                    .rgb());
+            }
+        }
+    }
+
+    /**
+     * \brief renders the selector as a triangle
+     * \note It's the same as a square with the edge with value=0 collapsed to a
+     * single point
+     */
+    void render_triangle()
+    {
+        QSizeF size = selector_size();
+        if (size.height() > max_size)
+            size *= max_size / size.height();
+
+        qreal ycenter = size.height() / 2;
+        inner_selector = QImage(size.toSize(), QImage::Format_RGB32);
+
+        for (int x = 0; x < inner_selector.width(); x++) {
+            qreal pval = x / size.height();
+            qreal slice_h = size.height() * pval;
+            for (int y = 0; y < inner_selector.height(); y++) {
+                qreal ymin = ycenter - slice_h / 2;
+                qreal psat = qBound(0.0, (y - ymin) / slice_h, 1.0);
+
+                inner_selector.setPixel(
+                  x, y, color_from(hue, psat, pval, 1).rgb());
+            }
+        }
+    }
+
+    /// Updates the inner image that displays the saturation-value selector
+    void render_inner_selector()
+    {
+        if (display_flags & ColorWheel::SHAPE_TRIANGLE)
+            render_triangle();
+        else
+            render_square();
+    }
+
+    /// Offset of the selector image
+    QPointF selector_image_offset()
+    {
+        if (display_flags & SHAPE_TRIANGLE)
+            return QPointF(-inner_radius(), -triangle_side() / 2);
+        return QPointF(-square_size() / 2, -square_size() / 2);
+    }
+
+    /**
+     * \brief Size of the selector when rendered to the screen
+     */
+    QSizeF selector_size()
+    {
+        if (display_flags & SHAPE_TRIANGLE)
+            return QSizeF(triangle_height(), triangle_side());
+        return QSizeF(square_size(), square_size());
+    }
+
+    /// Rotation of the selector image
+    qreal selector_image_angle()
+    {
+        if (display_flags & SHAPE_TRIANGLE) {
+            if (display_flags & ANGLE_ROTATING)
+                return -hue * 360 - 60;
+            return -150;
+        } else {
+            if (display_flags & ANGLE_ROTATING)
+                return -hue * 360 - 45;
+            else
+                return 180;
+        }
+    }
+
+    /// Updates the outer ring that displays the hue selector
+    void render_ring()
+    {
+        hue_ring = QPixmap(outer_radius() * 2, outer_radius() * 2);
+        hue_ring.fill(Qt::transparent);
+        QPainter painter(&hue_ring);
+        painter.setRenderHint(QPainter::Antialiasing);
+        painter.setCompositionMode(QPainter::CompositionMode_Source);
+
+        const int hue_stops = 24;
+        QConicalGradient gradient_hue(0, 0, 0);
+        if (gradient_hue.stops().size() < hue_stops) {
+            for (double a = 0; a < 1.0; a += 1.0 / (hue_stops - 1)) {
+                gradient_hue.setColorAt(a, rainbow_from_hue(a));
+            }
+            gradient_hue.setColorAt(1, rainbow_from_hue(0));
+        }
+
+        painter.translate(outer_radius(), outer_radius());
+
+        painter.setPen(Qt::NoPen);
+        painter.setBrush(QBrush(gradient_hue));
+        painter.drawEllipse(QPointF(0, 0), outer_radius(), outer_radius());
+
+        painter.setBrush(Qt::transparent); // palette().background());
+        painter.drawEllipse(QPointF(0, 0), inner_radius(), inner_radius());
     }
 
-    painter.translate(outer_radius(), outer_radius());
-
-    painter.setPen(Qt::NoPen);
-    painter.setBrush(QBrush(gradient_hue));
-    painter.drawEllipse(QPointF(0, 0), outer_radius(), outer_radius());
-
-    painter.setBrush(Qt::transparent); // palette().background());
-    painter.drawEllipse(QPointF(0, 0), inner_radius(), inner_radius());
-  }
-
-  void set_color(const QColor& c)
-  {
-    if (display_flags & ColorWheel::COLOR_HSV) {
-      hue = qMax(0.0, c.hsvHueF());
-      sat = c.hsvSaturationF();
-      val = c.valueF();
-    } else if (display_flags & ColorWheel::COLOR_HSL) {
-      hue = qMax(0.0, c.hueF());
-      sat = detail::color_HSL_saturationF(c);
-      val = detail::color_lightnessF(c);
-    } else if (display_flags & ColorWheel::COLOR_LCH) {
-      hue = qMax(0.0, c.hsvHueF());
-      sat = detail::color_chromaF(c);
-      val = detail::color_lumaF(c);
+    void set_color(const QColor& c)
+    {
+        if (display_flags & ColorWheel::COLOR_HSV) {
+            hue = qMax(0.0, c.hsvHueF());
+            sat = c.hsvSaturationF();
+            val = c.valueF();
+        } else if (display_flags & ColorWheel::COLOR_HSL) {
+            hue = qMax(0.0, c.hueF());
+            sat = detail::color_HSL_saturationF(c);
+            val = detail::color_lightnessF(c);
+        } else if (display_flags & ColorWheel::COLOR_LCH) {
+            hue = qMax(0.0, c.hsvHueF());
+            sat = detail::color_chromaF(c);
+            val = detail::color_lumaF(c);
+        }
     }
-  }
 };
 
 ColorWheel::ColorWheel(QWidget* parent)
   : QWidget(parent)
   , p(new Private(this))
 {
-  setDisplayFlags(FLAGS_DEFAULT);
-  setAcceptDrops(true);
+    setDisplayFlags(FLAGS_DEFAULT);
+    setAcceptDrops(true);
 }
 
 ColorWheel::~ColorWheel()
 {
-  delete p;
+    delete p;
 }
 
-QColor
-ColorWheel::color() const
+QColor ColorWheel::color() const
 {
-  return p->color_from(p->hue, p->sat, p->val, 1);
+    return p->color_from(p->hue, p->sat, p->val, 1);
 }
 
-QSize
-ColorWheel::sizeHint() const
+QSize ColorWheel::sizeHint() const
 {
-  return QSize(p->wheel_width * 5, p->wheel_width * 5);
+    return QSize(p->wheel_width * 5, p->wheel_width * 5);
 }
 
-qreal
-ColorWheel::hue() const
+qreal ColorWheel::hue() const
 {
-  if ((p->display_flags & COLOR_LCH) && p->sat > 0.01)
-    return color().hueF();
-  return p->hue;
+    if ((p->display_flags & COLOR_LCH) && p->sat > 0.01)
+        return color().hueF();
+    return p->hue;
 }
 
-qreal
-ColorWheel::saturation() const
+qreal ColorWheel::saturation() const
 {
-  return color().hsvSaturationF();
+    return color().hsvSaturationF();
 }
 
-qreal
-ColorWheel::value() const
+qreal ColorWheel::value() const
 {
-  return color().valueF();
+    return color().valueF();
 }
 
-unsigned int
-ColorWheel::wheelWidth() const
+unsigned int ColorWheel::wheelWidth() const
 {
-  return p->wheel_width;
+    return p->wheel_width;
 }
 
-void
-ColorWheel::setWheelWidth(unsigned int w)
+void ColorWheel::setWheelWidth(unsigned int w)
 {
-  p->wheel_width = w;
-  p->render_inner_selector();
-  update();
+    p->wheel_width = w;
+    p->render_inner_selector();
+    update();
 }
 
-void
-ColorWheel::paintEvent(QPaintEvent*)
+void ColorWheel::paintEvent(QPaintEvent*)
 {
-  QPainter painter(this);
-  painter.setRenderHint(QPainter::Antialiasing);
-  painter.translate(geometry().width() / 2, geometry().height() / 2);
+    QPainter painter(this);
+    painter.setRenderHint(QPainter::Antialiasing);
+    painter.translate(geometry().width() / 2, geometry().height() / 2);
 
-  // hue wheel
-  if (p->hue_ring.isNull())
-    p->render_ring();
+    // hue wheel
+    if (p->hue_ring.isNull())
+        p->render_ring();
 
-  painter.drawPixmap(-p->outer_radius(), -p->outer_radius(), p->hue_ring);
-
-  // hue selector
-  QColor penColor = p->bgBrightness < 0.6 ? Qt::white : Qt::black;
-  painter.setPen(QPen(penColor, 3));
-  painter.setBrush(Qt::NoBrush);
-  QLineF ray(0, 0, p->outer_radius(), 0);
-  ray.setAngle(p->hue * 360);
-  QPointF h1 = ray.p2();
-  ray.setLength(p->inner_radius());
-  QPointF h2 = ray.p2();
-  painter.drawLine(h1, h2);
-
-  // lum-sat square
-  if (p->inner_selector.isNull())
-    p->render_inner_selector();
+    painter.drawPixmap(-p->outer_radius(), -p->outer_radius(), p->hue_ring);
 
-  painter.rotate(p->selector_image_angle());
-  painter.translate(p->selector_image_offset());
-
-  QPointF selector_position;
-  if (p->display_flags & SHAPE_SQUARE) {
-    qreal side = p->square_size();
-    selector_position = QPointF(p->sat * side, p->val * side);
-  } else if (p->display_flags & SHAPE_TRIANGLE) {
-    qreal side = p->triangle_side();
-    qreal height = p->triangle_height();
-    qreal slice_h = side * p->val;
-    qreal ymin = side / 2 - slice_h / 2;
-
-    selector_position = QPointF(p->val * height, ymin + p->sat * slice_h);
-    QPolygonF triangle;
-    triangle.append(QPointF(0, side / 2));
-    triangle.append(QPointF(height, 0));
-    triangle.append(QPointF(height, side));
-    QPainterPath clip;
-    clip.addPolygon(triangle);
-    painter.setClipPath(clip);
-  }
-
-  painter.drawImage(QRectF(QPointF(0, 0), p->selector_size()),
-                    p->inner_selector);
-  painter.setClipping(false);
-
-  // lum-sat selector
-  // we define the color of the selecto based on the background color of the
-  // widget in order to improve the contrast
-  qreal colorBrightness = color_widgets::detail::color_lumaF(color());
-  if (p->bgBrightness < 0.6) // dark theme
-  {
-    bool isWhite = (colorBrightness < 0.7);
-    painter.setPen(QPen(isWhite ? Qt::white : Qt::black, 3));
-  } else // light theme
-  {
-    bool isWhite = (colorBrightness < 0.4 && p->val < 0.3);
-    painter.setPen(QPen(isWhite ? Qt::white : Qt::black, 3));
-  }
-  painter.setBrush(Qt::NoBrush);
-  painter.drawEllipse(selector_position, selector_radius, selector_radius);
-}
+    // hue selector
+    QColor penColor = p->bgBrightness < 0.6 ? Qt::white : Qt::black;
+    painter.setPen(QPen(penColor, 3));
+    painter.setBrush(Qt::NoBrush);
+    QLineF ray(0, 0, p->outer_radius(), 0);
+    ray.setAngle(p->hue * 360);
+    QPointF h1 = ray.p2();
+    ray.setLength(p->inner_radius());
+    QPointF h2 = ray.p2();
+    painter.drawLine(h1, h2);
 
-void
-ColorWheel::mouseMoveEvent(QMouseEvent* ev)
-{
-  if (p->mouse_status == DragCircle) {
-    p->hue = p->line_to_point(ev->pos()).angle() / 360.0;
-    p->render_inner_selector();
-
-    emit colorSelected(color());
-    emit colorChanged(color());
-    update();
-  } else if (p->mouse_status == DragSquare) {
-    QLineF glob_mouse_ln = p->line_to_point(ev->pos());
-    QLineF center_mouse_ln(QPointF(0, 0),
-                           glob_mouse_ln.p2() - glob_mouse_ln.p1());
+    // lum-sat square
+    if (p->inner_selector.isNull())
+        p->render_inner_selector();
 
-    center_mouse_ln.setAngle(center_mouse_ln.angle() +
-                             p->selector_image_angle());
-    center_mouse_ln.setP2(center_mouse_ln.p2() - p->selector_image_offset());
+    painter.rotate(p->selector_image_angle());
+    painter.translate(p->selector_image_offset());
 
+    QPointF selector_position;
     if (p->display_flags & SHAPE_SQUARE) {
-      p->sat = qBound(0.0, center_mouse_ln.x2() / p->square_size(), 1.0);
-      p->val = qBound(0.0, center_mouse_ln.y2() / p->square_size(), 1.0);
+        qreal side = p->square_size();
+        selector_position = QPointF(p->sat * side, p->val * side);
     } else if (p->display_flags & SHAPE_TRIANGLE) {
-      QPointF pt = center_mouse_ln.p2();
-
-      qreal side = p->triangle_side();
-      p->val = qBound(0.0, pt.x() / p->triangle_height(), 1.0);
-      qreal slice_h = side * p->val;
-
-      qreal ycenter = side / 2;
-      qreal ymin = ycenter - slice_h / 2;
-
-      if (slice_h > 0)
-        p->sat = qBound(0.0, (pt.y() - ymin) / slice_h, 1.0);
+        qreal side = p->triangle_side();
+        qreal height = p->triangle_height();
+        qreal slice_h = side * p->val;
+        qreal ymin = side / 2 - slice_h / 2;
+
+        selector_position = QPointF(p->val * height, ymin + p->sat * slice_h);
+        QPolygonF triangle;
+        triangle.append(QPointF(0, side / 2));
+        triangle.append(QPointF(height, 0));
+        triangle.append(QPointF(height, side));
+        QPainterPath clip;
+        clip.addPolygon(triangle);
+        painter.setClipPath(clip);
     }
 
-    emit colorSelected(color());
-    emit colorChanged(color());
-    update();
-  }
+    painter.drawImage(QRectF(QPointF(0, 0), p->selector_size()),
+                      p->inner_selector);
+    painter.setClipping(false);
+
+    // lum-sat selector
+    // we define the color of the selecto based on the background color of the
+    // widget in order to improve the contrast
+    qreal colorBrightness = color_widgets::detail::color_lumaF(color());
+    if (p->bgBrightness < 0.6) // dark theme
+    {
+        bool isWhite = (colorBrightness < 0.7);
+        painter.setPen(QPen(isWhite ? Qt::white : Qt::black, 3));
+    } else // light theme
+    {
+        bool isWhite = (colorBrightness < 0.4 && p->val < 0.3);
+        painter.setPen(QPen(isWhite ? Qt::white : Qt::black, 3));
+    }
+    painter.setBrush(Qt::NoBrush);
+    painter.drawEllipse(selector_position, selector_radius, selector_radius);
 }
 
-void
-ColorWheel::mousePressEvent(QMouseEvent* ev)
+void ColorWheel::mouseMoveEvent(QMouseEvent* ev)
 {
-  if (ev->buttons() & Qt::LeftButton) {
-    setFocus();
-    QLineF ray = p->line_to_point(ev->pos());
-    if (ray.length() <= p->inner_radius())
-      p->mouse_status = DragSquare;
-    else if (ray.length() <= p->outer_radius())
-      p->mouse_status = DragCircle;
-
-    // Update the color
-    mouseMoveEvent(ev);
-  }
+    if (p->mouse_status == DragCircle) {
+        p->hue = p->line_to_point(ev->pos()).angle() / 360.0;
+        p->render_inner_selector();
+
+        emit colorSelected(color());
+        emit colorChanged(color());
+        update();
+    } else if (p->mouse_status == DragSquare) {
+        QLineF glob_mouse_ln = p->line_to_point(ev->pos());
+        QLineF center_mouse_ln(QPointF(0, 0),
+                               glob_mouse_ln.p2() - glob_mouse_ln.p1());
+
+        center_mouse_ln.setAngle(center_mouse_ln.angle() +
+                                 p->selector_image_angle());
+        center_mouse_ln.setP2(center_mouse_ln.p2() -
+                              p->selector_image_offset());
+
+        if (p->display_flags & SHAPE_SQUARE) {
+            p->sat = qBound(0.0, center_mouse_ln.x2() / p->square_size(), 1.0);
+            p->val = qBound(0.0, center_mouse_ln.y2() / p->square_size(), 1.0);
+        } else if (p->display_flags & SHAPE_TRIANGLE) {
+            QPointF pt = center_mouse_ln.p2();
+
+            qreal side = p->triangle_side();
+            p->val = qBound(0.0, pt.x() / p->triangle_height(), 1.0);
+            qreal slice_h = side * p->val;
+
+            qreal ycenter = side / 2;
+            qreal ymin = ycenter - slice_h / 2;
+
+            if (slice_h > 0)
+                p->sat = qBound(0.0, (pt.y() - ymin) / slice_h, 1.0);
+        }
+
+        emit colorSelected(color());
+        emit colorChanged(color());
+        update();
+    }
 }
 
-void
-ColorWheel::mouseReleaseEvent(QMouseEvent* ev)
+void ColorWheel::mousePressEvent(QMouseEvent* ev)
 {
-  mouseMoveEvent(ev);
-  p->mouse_status = Nothing;
-  emit mouseReleaseOnColor(color());
+    if (ev->buttons() & Qt::LeftButton) {
+        setFocus();
+        QLineF ray = p->line_to_point(ev->pos());
+        if (ray.length() <= p->inner_radius())
+            p->mouse_status = DragSquare;
+        else if (ray.length() <= p->outer_radius())
+            p->mouse_status = DragCircle;
+
+        // Update the color
+        mouseMoveEvent(ev);
+    }
 }
 
-void
-ColorWheel::resizeEvent(QResizeEvent*)
+void ColorWheel::mouseReleaseEvent(QMouseEvent* ev)
 {
-  p->render_ring();
-  p->render_inner_selector();
+    mouseMoveEvent(ev);
+    p->mouse_status = Nothing;
+    emit mouseReleaseOnColor(color());
 }
 
-void
-ColorWheel::setColor(QColor c)
+void ColorWheel::resizeEvent(QResizeEvent*)
 {
-  qreal oldh = p->hue;
-  p->set_color(c);
-  if (!qFuzzyCompare(oldh + 1, p->hue + 1))
+    p->render_ring();
     p->render_inner_selector();
-  update();
-  emit colorChanged(c);
 }
 
-void
-ColorWheel::setHue(qreal h)
+void ColorWheel::setColor(QColor c)
+{
+    qreal oldh = p->hue;
+    p->set_color(c);
+    if (!qFuzzyCompare(oldh + 1, p->hue + 1))
+        p->render_inner_selector();
+    update();
+    emit colorChanged(c);
+}
+
+void ColorWheel::setHue(qreal h)
 {
-  p->hue = qBound(0.0, h, 1.0);
-  p->render_inner_selector();
-  update();
+    p->hue = qBound(0.0, h, 1.0);
+    p->render_inner_selector();
+    update();
 }
 
-void
-ColorWheel::setSaturation(qreal s)
+void ColorWheel::setSaturation(qreal s)
 {
-  p->sat = qBound(0.0, s, 1.0);
-  update();
+    p->sat = qBound(0.0, s, 1.0);
+    update();
 }
 
-void
-ColorWheel::setValue(qreal v)
+void ColorWheel::setValue(qreal v)
 {
-  p->val = qBound(0.0, v, 1.0);
-  update();
+    p->val = qBound(0.0, v, 1.0);
+    update();
 }
 
-void
-ColorWheel::setDisplayFlags(DisplayFlags flags)
+void ColorWheel::setDisplayFlags(DisplayFlags flags)
 {
-  if (!(flags & COLOR_FLAGS))
-    flags |= default_flags & COLOR_FLAGS;
-  if (!(flags & ANGLE_FLAGS))
-    flags |= default_flags & ANGLE_FLAGS;
-  if (!(flags & SHAPE_FLAGS))
-    flags |= default_flags & SHAPE_FLAGS;
-
-  if ((flags & COLOR_FLAGS) != (p->display_flags & COLOR_FLAGS)) {
-    QColor old_col = color();
-    if (flags & ColorWheel::COLOR_HSL) {
-      p->hue = old_col.hueF();
-      p->sat = detail::color_HSL_saturationF(old_col);
-      p->val = detail::color_lightnessF(old_col);
-      p->color_from = &detail::color_from_hsl;
-      p->rainbow_from_hue = &detail::rainbow_hsv;
-    } else if (flags & ColorWheel::COLOR_LCH) {
-      p->hue = old_col.hueF();
-      p->sat = detail::color_chromaF(old_col);
-      p->val = detail::color_lumaF(old_col);
-      p->color_from = &detail::color_from_lch;
-      p->rainbow_from_hue = &detail::rainbow_lch;
-    } else {
-      p->hue = old_col.hsvHueF();
-      p->sat = old_col.hsvSaturationF();
-      p->val = old_col.valueF();
-      p->color_from = &QColor::fromHsvF;
-      p->rainbow_from_hue = &detail::rainbow_hsv;
+    if (!(flags & COLOR_FLAGS))
+        flags |= default_flags & COLOR_FLAGS;
+    if (!(flags & ANGLE_FLAGS))
+        flags |= default_flags & ANGLE_FLAGS;
+    if (!(flags & SHAPE_FLAGS))
+        flags |= default_flags & SHAPE_FLAGS;
+
+    if ((flags & COLOR_FLAGS) != (p->display_flags & COLOR_FLAGS)) {
+        QColor old_col = color();
+        if (flags & ColorWheel::COLOR_HSL) {
+            p->hue = old_col.hueF();
+            p->sat = detail::color_HSL_saturationF(old_col);
+            p->val = detail::color_lightnessF(old_col);
+            p->color_from = &detail::color_from_hsl;
+            p->rainbow_from_hue = &detail::rainbow_hsv;
+        } else if (flags & ColorWheel::COLOR_LCH) {
+            p->hue = old_col.hueF();
+            p->sat = detail::color_chromaF(old_col);
+            p->val = detail::color_lumaF(old_col);
+            p->color_from = &detail::color_from_lch;
+            p->rainbow_from_hue = &detail::rainbow_lch;
+        } else {
+            p->hue = old_col.hsvHueF();
+            p->sat = old_col.hsvSaturationF();
+            p->val = old_col.valueF();
+            p->color_from = &QColor::fromHsvF;
+            p->rainbow_from_hue = &detail::rainbow_hsv;
+        }
+        p->render_ring();
     }
-    p->render_ring();
-  }
 
-  p->display_flags = flags;
-  p->render_inner_selector();
-  update();
-  emit displayFlagsChanged(flags);
+    p->display_flags = flags;
+    p->render_inner_selector();
+    update();
+    emit displayFlagsChanged(flags);
 }
 
-ColorWheel::DisplayFlags
-ColorWheel::displayFlags(DisplayFlags mask) const
+ColorWheel::DisplayFlags ColorWheel::displayFlags(DisplayFlags mask) const
 {
-  return p->display_flags & mask;
+    return p->display_flags & mask;
 }
 
-void
-ColorWheel::setDefaultDisplayFlags(DisplayFlags flags)
+void ColorWheel::setDefaultDisplayFlags(DisplayFlags flags)
 {
-  if (!(flags & COLOR_FLAGS))
-    flags |= hard_default_flags & COLOR_FLAGS;
-  if (!(flags & ANGLE_FLAGS))
-    flags |= hard_default_flags & ANGLE_FLAGS;
-  if (!(flags & SHAPE_FLAGS))
-    flags |= hard_default_flags & SHAPE_FLAGS;
-  default_flags = flags;
+    if (!(flags & COLOR_FLAGS))
+        flags |= hard_default_flags & COLOR_FLAGS;
+    if (!(flags & ANGLE_FLAGS))
+        flags |= hard_default_flags & ANGLE_FLAGS;
+    if (!(flags & SHAPE_FLAGS))
+        flags |= hard_default_flags & SHAPE_FLAGS;
+    default_flags = flags;
 }
 
-ColorWheel::DisplayFlags
-ColorWheel::defaultDisplayFlags(DisplayFlags mask)
+ColorWheel::DisplayFlags ColorWheel::defaultDisplayFlags(DisplayFlags mask)
 {
-  return default_flags & mask;
+    return default_flags & mask;
 }
 
-void
-ColorWheel::setDisplayFlag(DisplayFlags flag, DisplayFlags mask)
+void ColorWheel::setDisplayFlag(DisplayFlags flag, DisplayFlags mask)
 {
-  setDisplayFlags((p->display_flags & ~mask) | flag);
+    setDisplayFlags((p->display_flags & ~mask) | flag);
 }
 
-void
-ColorWheel::dragEnterEvent(QDragEnterEvent* event)
+void ColorWheel::dragEnterEvent(QDragEnterEvent* event)
 {
-  if (event->mimeData()->hasColor() ||
-      (event->mimeData()->hasText() &&
-       QColor(event->mimeData()->text()).isValid()))
-    event->acceptProposedAction();
+    if (event->mimeData()->hasColor() ||
+        (event->mimeData()->hasText() &&
+         QColor(event->mimeData()->text()).isValid()))
+        event->acceptProposedAction();
 }
 
-void
-ColorWheel::dropEvent(QDropEvent* event)
+void ColorWheel::dropEvent(QDropEvent* event)
 {
-  if (event->mimeData()->hasColor()) {
-    setColor(event->mimeData()->colorData().value<QColor>());
-    event->accept();
-  } else if (event->mimeData()->hasText()) {
-    QColor col(event->mimeData()->text());
-    if (col.isValid()) {
-      setColor(col);
-      event->accept();
+    if (event->mimeData()->hasColor()) {
+        setColor(event->mimeData()->colorData().value<QColor>());
+        event->accept();
+    } else if (event->mimeData()->hasText()) {
+        QColor col(event->mimeData()->text());
+        if (col.isValid()) {
+            setColor(col);
+            event->accept();
+        }
     }
-  }
 }
 
 } //  namespace color_widgets
diff --git a/external/singleapplication/singleapplication.cpp b/external/singleapplication/singleapplication.cpp
index f929701b..b344445c 100644
--- a/external/singleapplication/singleapplication.cpp
+++ b/external/singleapplication/singleapplication.cpp
@@ -49,324 +49,319 @@
 SingleApplicationPrivate::SingleApplicationPrivate(SingleApplication* q_ptr)
   : q_ptr(q_ptr)
 {
-  server = nullptr;
-  socket = nullptr;
+    server = nullptr;
+    socket = nullptr;
 }
 
 SingleApplicationPrivate::~SingleApplicationPrivate()
 {
-  if (socket != nullptr) {
-    socket->close();
-    delete socket;
-  }
-
-  memory->lock();
-  InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
-  if (server != nullptr) {
-    server->close();
-    delete server;
-    inst->primary = false;
-    inst->primaryPid = -1;
-  }
-  memory->unlock();
-
-  delete memory;
+    if (socket != nullptr) {
+        socket->close();
+        delete socket;
+    }
+
+    memory->lock();
+    InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
+    if (server != nullptr) {
+        server->close();
+        delete server;
+        inst->primary = false;
+        inst->primaryPid = -1;
+    }
+    memory->unlock();
+
+    delete memory;
 }
 
-void
-SingleApplicationPrivate::genBlockServerName(int timeout)
+void SingleApplicationPrivate::genBlockServerName(int timeout)
 {
-  QCryptographicHash appData(QCryptographicHash::Sha256);
-  appData.addData("SingleApplication", 17);
-  appData.addData(SingleApplication::app_t::applicationName().toUtf8());
-  appData.addData(SingleApplication::app_t::organizationName().toUtf8());
-  appData.addData(SingleApplication::app_t::organizationDomain().toUtf8());
-
-  if (!(options & SingleApplication::Mode::ExcludeAppVersion)) {
-    appData.addData(SingleApplication::app_t::applicationVersion().toUtf8());
-  }
+    QCryptographicHash appData(QCryptographicHash::Sha256);
+    appData.addData("SingleApplication", 17);
+    appData.addData(SingleApplication::app_t::applicationName().toUtf8());
+    appData.addData(SingleApplication::app_t::organizationName().toUtf8());
+    appData.addData(SingleApplication::app_t::organizationDomain().toUtf8());
+
+    if (!(options & SingleApplication::Mode::ExcludeAppVersion)) {
+        appData.addData(
+          SingleApplication::app_t::applicationVersion().toUtf8());
+    }
 
-  if (!(options & SingleApplication::Mode::ExcludeAppPath)) {
+    if (!(options & SingleApplication::Mode::ExcludeAppPath)) {
 #ifdef Q_OS_WIN
-    appData.addData(
-      SingleApplication::app_t::applicationFilePath().toLower().toUtf8());
+        appData.addData(
+          SingleApplication::app_t::applicationFilePath().toLower().toUtf8());
 #else
-    appData.addData(SingleApplication::app_t::applicationFilePath().toUtf8());
+        appData.addData(
+          SingleApplication::app_t::applicationFilePath().toUtf8());
 #endif
-  }
+    }
 
-  // User level block requires a user specific data in the hash
-  if (options & SingleApplication::Mode::User) {
+    // User level block requires a user specific data in the hash
+    if (options & SingleApplication::Mode::User) {
 #ifdef Q_OS_WIN
-    Q_UNUSED(timeout);
-    wchar_t username[UNLEN + 1];
-    // Specifies size of the buffer on input
-    DWORD usernameLength = UNLEN + 1;
-    if (GetUserNameW(username, &usernameLength)) {
-      appData.addData(QString::fromWCharArray(username).toUtf8());
-    } else {
-      appData.addData(
-        QStandardPaths::standardLocations(QStandardPaths::HomeLocation)
-          .join("")
-          .toUtf8());
-    }
+        Q_UNUSED(timeout);
+        wchar_t username[UNLEN + 1];
+        // Specifies size of the buffer on input
+        DWORD usernameLength = UNLEN + 1;
+        if (GetUserNameW(username, &usernameLength)) {
+            appData.addData(QString::fromWCharArray(username).toUtf8());
+        } else {
+            appData.addData(
+              QStandardPaths::standardLocations(QStandardPaths::HomeLocation)
+                .join("")
+                .toUtf8());
+        }
 #endif
 #ifdef Q_OS_UNIX
-    QProcess process;
-    process.start(QStringLiteral("whoami"), QStringList{});
-
-    if (process.waitForFinished(timeout) &&
-        process.exitCode() == QProcess::NormalExit) {
-      appData.addData(process.readLine());
-    } else {
-      appData.addData(
-        QDir(QStandardPaths::standardLocations(QStandardPaths::HomeLocation)
-               .first())
-          .absolutePath()
-          .toUtf8());
-    }
+        QProcess process;
+        process.start(QStringLiteral("whoami"), QStringList{});
+
+        if (process.waitForFinished(timeout) &&
+            process.exitCode() == QProcess::NormalExit) {
+            appData.addData(process.readLine());
+        } else {
+            appData.addData(QDir(QStandardPaths::standardLocations(
+                                   QStandardPaths::HomeLocation)
+                                   .first())
+                              .absolutePath()
+                              .toUtf8());
+        }
 #endif
-  }
+    }
 
-  // Replace the backslash in RFC 2045 Base64 [a-zA-Z0-9+/=] to comply with
-  // server naming requirements.
-  blockServerName = appData.result().toBase64().replace("/", "_");
+    // Replace the backslash in RFC 2045 Base64 [a-zA-Z0-9+/=] to comply with
+    // server naming requirements.
+    blockServerName = appData.result().toBase64().replace("/", "_");
 }
 
-void
-SingleApplicationPrivate::startPrimary(bool resetMemory)
+void SingleApplicationPrivate::startPrimary(bool resetMemory)
 {
-  Q_Q(SingleApplication);
+    Q_Q(SingleApplication);
 
 #ifdef Q_OS_UNIX
-  // Handle any further termination signals to ensure the
-  // QSharedMemory block is deleted even if the process crashes
-  crashHandler();
+    // Handle any further termination signals to ensure the
+    // QSharedMemory block is deleted even if the process crashes
+    crashHandler();
 #endif
-  // Successful creation means that no main process exists
-  // So we start a QLocalServer to listen for connections
-  QLocalServer::removeServer(blockServerName);
-  server = new QLocalServer();
-
-  // Restrict access to the socket according to the
-  // SingleApplication::Mode::User flag on User level or no restrictions
-  if (options & SingleApplication::Mode::User) {
-    server->setSocketOptions(QLocalServer::UserAccessOption);
-  } else {
-    server->setSocketOptions(QLocalServer::WorldAccessOption);
-  }
-
-  server->listen(blockServerName);
-  QObject::connect(server,
-                   &QLocalServer::newConnection,
-                   this,
-                   &SingleApplicationPrivate::slotConnectionEstablished);
-
-  // Reset the number of connections
-  memory->lock();
-  InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
-
-  if (resetMemory) {
-    inst->secondary = 0;
-  }
-
-  inst->primary = true;
-  inst->primaryPid = q->applicationPid();
-
-  memory->unlock();
-
-  instanceNumber = 0;
+    // Successful creation means that no main process exists
+    // So we start a QLocalServer to listen for connections
+    QLocalServer::removeServer(blockServerName);
+    server = new QLocalServer();
+
+    // Restrict access to the socket according to the
+    // SingleApplication::Mode::User flag on User level or no restrictions
+    if (options & SingleApplication::Mode::User) {
+        server->setSocketOptions(QLocalServer::UserAccessOption);
+    } else {
+        server->setSocketOptions(QLocalServer::WorldAccessOption);
+    }
+
+    server->listen(blockServerName);
+    QObject::connect(server,
+                     &QLocalServer::newConnection,
+                     this,
+                     &SingleApplicationPrivate::slotConnectionEstablished);
+
+    // Reset the number of connections
+    memory->lock();
+    InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
+
+    if (resetMemory) {
+        inst->secondary = 0;
+    }
+
+    inst->primary = true;
+    inst->primaryPid = q->applicationPid();
+
+    memory->unlock();
+
+    instanceNumber = 0;
 }
 
-void
-SingleApplicationPrivate::startSecondary()
+void SingleApplicationPrivate::startSecondary()
 {
 #ifdef Q_OS_UNIX
-  // Handle any further termination signals to ensure the
-  // QSharedMemory block is deleted even if the process crashes
-  crashHandler();
+    // Handle any further termination signals to ensure the
+    // QSharedMemory block is deleted even if the process crashes
+    crashHandler();
 #endif
 }
 
-void
-SingleApplicationPrivate::connectToPrimary(int msecs,
-                                           ConnectionType connectionType)
+void SingleApplicationPrivate::connectToPrimary(int msecs,
+                                                ConnectionType connectionType)
 {
-  // Connect to the Local Server of the Primary Instance if not already
-  // connected.
-  if (socket == nullptr) {
-    socket = new QLocalSocket();
-  }
-
-  // If already connected - we are done;
-  if (socket->state() == QLocalSocket::ConnectedState)
-    return;
-
-  // If not connect
-  if (socket->state() == QLocalSocket::UnconnectedState ||
-      socket->state() == QLocalSocket::ClosingState) {
-    socket->connectToServer(blockServerName);
-  }
-
-  // Wait for being connected
-  if (socket->state() == QLocalSocket::ConnectingState) {
-    socket->waitForConnected(msecs);
-  }
-
-  // Initialisation message according to the SingleApplication protocol
-  if (socket->state() == QLocalSocket::ConnectedState) {
-    // Notify the parent that a new instance had been started;
-    QByteArray initMsg;
-    QDataStream writeStream(&initMsg, QIODevice::WriteOnly);
-    writeStream.setVersion(QDataStream::Qt_5_2);
-    writeStream << blockServerName.toLatin1();
-    writeStream << static_cast<quint8>(connectionType);
-    writeStream << instanceNumber;
-    quint16 checksum =
-      qChecksum(initMsg.constData(), static_cast<quint32>(initMsg.length()));
-    writeStream << checksum;
-
-    socket->write(initMsg);
-    socket->flush();
-    socket->waitForBytesWritten(msecs);
-  }
+    // Connect to the Local Server of the Primary Instance if not already
+    // connected.
+    if (socket == nullptr) {
+        socket = new QLocalSocket();
+    }
+
+    // If already connected - we are done;
+    if (socket->state() == QLocalSocket::ConnectedState)
+        return;
+
+    // If not connect
+    if (socket->state() == QLocalSocket::UnconnectedState ||
+        socket->state() == QLocalSocket::ClosingState) {
+        socket->connectToServer(blockServerName);
+    }
+
+    // Wait for being connected
+    if (socket->state() == QLocalSocket::ConnectingState) {
+        socket->waitForConnected(msecs);
+    }
+
+    // Initialisation message according to the SingleApplication protocol
+    if (socket->state() == QLocalSocket::ConnectedState) {
+        // Notify the parent that a new instance had been started;
+        QByteArray initMsg;
+        QDataStream writeStream(&initMsg, QIODevice::WriteOnly);
+        writeStream.setVersion(QDataStream::Qt_5_2);
+        writeStream << blockServerName.toLatin1();
+        writeStream << static_cast<quint8>(connectionType);
+        writeStream << instanceNumber;
+        quint16 checksum = qChecksum(initMsg.constData(),
+                                     static_cast<quint32>(initMsg.length()));
+        writeStream << checksum;
+
+        socket->write(initMsg);
+        socket->flush();
+        socket->waitForBytesWritten(msecs);
+    }
 }
 
-qint64
-SingleApplicationPrivate::primaryPid()
+qint64 SingleApplicationPrivate::primaryPid()
 {
-  qint64 pid;
+    qint64 pid;
 
-  memory->lock();
-  InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
-  pid = inst->primaryPid;
-  memory->unlock();
+    memory->lock();
+    InstancesInfo* inst = static_cast<InstancesInfo*>(memory->data());
+    pid = inst->primaryPid;
+    memory->unlock();
 
-  return pid;
+    return pid;
 }
 
 #ifdef Q_OS_UNIX
-void
-SingleApplicationPrivate::crashHandler()
+void SingleApplicationPrivate::crashHandler()
 {
-  // Handle any further termination signals to ensure the
-  // QSharedMemory block is deleted even if the process crashes
-  signal(SIGHUP, SingleApplicationPrivate::terminate);  // 1
-  signal(SIGINT, SingleApplicationPrivate::terminate);  // 2
-  signal(SIGQUIT, SingleApplicationPrivate::terminate); // 3
-  signal(SIGILL, SingleApplicationPrivate::terminate);  // 4
-  signal(SIGABRT, SingleApplicationPrivate::terminate); // 6
-  signal(SIGFPE, SingleApplicationPrivate::terminate);  // 8
-  signal(SIGBUS, SingleApplicationPrivate::terminate);  // 10
-  signal(SIGSEGV, SingleApplicationPrivate::terminate); // 11
-  signal(SIGSYS, SingleApplicationPrivate::terminate);  // 12
-  signal(SIGPIPE, SingleApplicationPrivate::terminate); // 13
-  signal(SIGALRM, SingleApplicationPrivate::terminate); // 14
-  signal(SIGTERM, SingleApplicationPrivate::terminate); // 15
-  signal(SIGXCPU, SingleApplicationPrivate::terminate); // 24
-  signal(SIGXFSZ, SingleApplicationPrivate::terminate); // 25
+    // Handle any further termination signals to ensure the
+    // QSharedMemory block is deleted even if the process crashes
+    signal(SIGHUP, SingleApplicationPrivate::terminate);  // 1
+    signal(SIGINT, SingleApplicationPrivate::terminate);  // 2
+    signal(SIGQUIT, SingleApplicationPrivate::terminate); // 3
+    signal(SIGILL, SingleApplicationPrivate::terminate);  // 4
+    signal(SIGABRT, SingleApplicationPrivate::terminate); // 6
+    signal(SIGFPE, SingleApplicationPrivate::terminate);  // 8
+    signal(SIGBUS, SingleApplicationPrivate::terminate);  // 10
+    signal(SIGSEGV, SingleApplicationPrivate::terminate); // 11
+    signal(SIGSYS, SingleApplicationPrivate::terminate);  // 12
+    signal(SIGPIPE, SingleApplicationPrivate::terminate); // 13
+    signal(SIGALRM, SingleApplicationPrivate::terminate); // 14
+    signal(SIGTERM, SingleApplicationPrivate::terminate); // 15
+    signal(SIGXCPU, SingleApplicationPrivate::terminate); // 24
+    signal(SIGXFSZ, SingleApplicationPrivate::terminate); // 25
 }
 
-void
-SingleApplicationPrivate::terminate(int signum)
+void SingleApplicationPrivate::terminate(int signum)
 {
-  delete ((SingleApplication*)QCoreApplication::instance())->d_ptr;
-  ::exit(128 + signum);
+    delete ((SingleApplication*)QCoreApplication::instance())->d_ptr;
+    ::exit(128 + signum);
 }
 #endif
 
 /**
  * @brief Executed when a connection has been made to the LocalServer
  */
-void
-SingleApplicationPrivate::slotConnectionEstablished()
+void SingleApplicationPrivate::slotConnectionEstablished()
 {
-  Q_Q(SingleApplication);
-
-  QLocalSocket* nextConnSocket = server->nextPendingConnection();
-
-  quint32 instanceId = 0;
-  ConnectionType connectionType = InvalidConnection;
-  if (nextConnSocket->waitForReadyRead(100)) {
-    // read all data from message in same order/format as written
-    QByteArray msgBytes = nextConnSocket->read(
-      nextConnSocket->bytesAvailable() - static_cast<qint64>(sizeof(quint16)));
-    QByteArray checksumBytes = nextConnSocket->read(sizeof(quint16));
-    QDataStream readStream(msgBytes);
-    readStream.setVersion(QDataStream::Qt_5_2);
-
-    // server name
-    QByteArray latin1Name;
-    readStream >> latin1Name;
-    // connectioon type
-    quint8 connType = InvalidConnection;
-    readStream >> connType;
-    connectionType = static_cast<ConnectionType>(connType);
-    // instance id
-    readStream >> instanceId;
-    // checksum
-    quint16 msgChecksum = 0;
-    QDataStream checksumStream(checksumBytes);
-    checksumStream.setVersion(QDataStream::Qt_5_2);
-    checksumStream >> msgChecksum;
-
-    const quint16 actualChecksum =
-      qChecksum(msgBytes.constData(), static_cast<quint32>(msgBytes.length()));
-
-    if (readStream.status() != QDataStream::Ok ||
-        QLatin1String(latin1Name) != blockServerName ||
-        msgChecksum != actualChecksum) {
-      connectionType = InvalidConnection;
+    Q_Q(SingleApplication);
+
+    QLocalSocket* nextConnSocket = server->nextPendingConnection();
+
+    quint32 instanceId = 0;
+    ConnectionType connectionType = InvalidConnection;
+    if (nextConnSocket->waitForReadyRead(100)) {
+        // read all data from message in same order/format as written
+        QByteArray msgBytes =
+          nextConnSocket->read(nextConnSocket->bytesAvailable() -
+                               static_cast<qint64>(sizeof(quint16)));
+        QByteArray checksumBytes = nextConnSocket->read(sizeof(quint16));
+        QDataStream readStream(msgBytes);
+        readStream.setVersion(QDataStream::Qt_5_2);
+
+        // server name
+        QByteArray latin1Name;
+        readStream >> latin1Name;
+        // connectioon type
+        quint8 connType = InvalidConnection;
+        readStream >> connType;
+        connectionType = static_cast<ConnectionType>(connType);
+        // instance id
+        readStream >> instanceId;
+        // checksum
+        quint16 msgChecksum = 0;
+        QDataStream checksumStream(checksumBytes);
+        checksumStream.setVersion(QDataStream::Qt_5_2);
+        checksumStream >> msgChecksum;
+
+        const quint16 actualChecksum = qChecksum(
+          msgBytes.constData(), static_cast<quint32>(msgBytes.length()));
+
+        if (readStream.status() != QDataStream::Ok ||
+            QLatin1String(latin1Name) != blockServerName ||
+            msgChecksum != actualChecksum) {
+            connectionType = InvalidConnection;
+        }
+    }
+
+    if (connectionType == InvalidConnection) {
+        nextConnSocket->close();
+        delete nextConnSocket;
+        return;
+    }
+
+    QObject::connect(nextConnSocket,
+                     &QLocalSocket::aboutToClose,
+                     this,
+                     [nextConnSocket, instanceId, this]() {
+                         emit this->slotClientConnectionClosed(nextConnSocket,
+                                                               instanceId);
+                     });
+
+    QObject::connect(nextConnSocket,
+                     &QLocalSocket::readyRead,
+                     this,
+                     [nextConnSocket, instanceId, this]() {
+                         emit this->slotDataAvailable(nextConnSocket,
+                                                      instanceId);
+                     });
+
+    if (connectionType == NewInstance ||
+        (connectionType == SecondaryInstance &&
+         options & SingleApplication::Mode::SecondaryNotification)) {
+        emit q->instanceStarted();
+    }
+
+    if (nextConnSocket->bytesAvailable() > 0) {
+        emit this->slotDataAvailable(nextConnSocket, instanceId);
     }
-  }
-
-  if (connectionType == InvalidConnection) {
-    nextConnSocket->close();
-    delete nextConnSocket;
-    return;
-  }
-
-  QObject::connect(nextConnSocket,
-                   &QLocalSocket::aboutToClose,
-                   this,
-                   [nextConnSocket, instanceId, this]() {
-                     emit this->slotClientConnectionClosed(nextConnSocket,
-                                                           instanceId);
-                   });
-
-  QObject::connect(nextConnSocket,
-                   &QLocalSocket::readyRead,
-                   this,
-                   [nextConnSocket, instanceId, this]() {
-                     emit this->slotDataAvailable(nextConnSocket, instanceId);
-                   });
-
-  if (connectionType == NewInstance ||
-      (connectionType == SecondaryInstance &&
-       options & SingleApplication::Mode::SecondaryNotification)) {
-    emit q->instanceStarted();
-  }
-
-  if (nextConnSocket->bytesAvailable() > 0) {
-    emit this->slotDataAvailable(nextConnSocket, instanceId);
-  }
 }
 
-void
-SingleApplicationPrivate::slotDataAvailable(QLocalSocket* dataSocket,
-                                            quint32 instanceId)
+void SingleApplicationPrivate::slotDataAvailable(QLocalSocket* dataSocket,
+                                                 quint32 instanceId)
 {
-  Q_Q(SingleApplication);
-  emit q->receivedMessage(instanceId, dataSocket->readAll());
+    Q_Q(SingleApplication);
+    emit q->receivedMessage(instanceId, dataSocket->readAll());
 }
 
-void
-SingleApplicationPrivate::slotClientConnectionClosed(QLocalSocket* closedSocket,
-                                                     quint32 instanceId)
+void SingleApplicationPrivate::slotClientConnectionClosed(
+  QLocalSocket* closedSocket,
+  quint32 instanceId)
 {
-  if (closedSocket->bytesAvailable() > 0)
-    emit slotDataAvailable(closedSocket, instanceId);
-  closedSocket->deleteLater();
+    if (closedSocket->bytesAvailable() > 0)
+        emit slotDataAvailable(closedSocket, instanceId);
+    closedSocket->deleteLater();
 }
 
 /**
@@ -384,61 +379,62 @@ SingleApplication::SingleApplication(int& argc,
   : app_t(argc, argv)
   , d_ptr(new SingleApplicationPrivate(this))
 {
-  Q_D(SingleApplication);
+    Q_D(SingleApplication);
 
-  // Store the current mode of the program
-  d->options = options;
+    // Store the current mode of the program
+    d->options = options;
 
-  // Generating an application ID used for identifying the shared memory
-  // block and QLocalServer
-  d->genBlockServerName(timeout);
+    // Generating an application ID used for identifying the shared memory
+    // block and QLocalServer
+    d->genBlockServerName(timeout);
 
-  // Guarantee thread safe behaviour with a shared memory block. Also by
-  // explicitly attaching it and then deleting it we make sure that the
-  // memory is deleted even if the process had crashed on Unix.
+    // Guarantee thread safe behaviour with a shared memory block. Also by
+    // explicitly attaching it and then deleting it we make sure that the
+    // memory is deleted even if the process had crashed on Unix.
 #ifdef Q_OS_UNIX
-  d->memory = new QSharedMemory(d->blockServerName);
-  d->memory->attach();
-  delete d->memory;
+    d->memory = new QSharedMemory(d->blockServerName);
+    d->memory->attach();
+    delete d->memory;
 #endif
-  d->memory = new QSharedMemory(d->blockServerName);
-
-  // Create a shared memory block
-  if (d->memory->create(sizeof(InstancesInfo))) {
-    d->startPrimary(true);
-    return;
-  } else {
-    // Attempt to attach to the memory segment
-    if (d->memory->attach()) {
-      d->memory->lock();
-      InstancesInfo* inst = static_cast<InstancesInfo*>(d->memory->data());
-
-      if (!inst->primary) {
-        d->startPrimary(false);
-        d->memory->unlock();
+    d->memory = new QSharedMemory(d->blockServerName);
+
+    // Create a shared memory block
+    if (d->memory->create(sizeof(InstancesInfo))) {
+        d->startPrimary(true);
         return;
-      }
-
-      // Check if another instance can be started
-      if (allowSecondary) {
-        inst->secondary += 1;
-        d->instanceNumber = inst->secondary;
-        d->startSecondary();
-        if (d->options & Mode::SecondaryNotification) {
-          d->connectToPrimary(timeout,
-                              SingleApplicationPrivate::SecondaryInstance);
+    } else {
+        // Attempt to attach to the memory segment
+        if (d->memory->attach()) {
+            d->memory->lock();
+            InstancesInfo* inst =
+              static_cast<InstancesInfo*>(d->memory->data());
+
+            if (!inst->primary) {
+                d->startPrimary(false);
+                d->memory->unlock();
+                return;
+            }
+
+            // Check if another instance can be started
+            if (allowSecondary) {
+                inst->secondary += 1;
+                d->instanceNumber = inst->secondary;
+                d->startSecondary();
+                if (d->options & Mode::SecondaryNotification) {
+                    d->connectToPrimary(
+                      timeout, SingleApplicationPrivate::SecondaryInstance);
+                }
+                d->memory->unlock();
+                return;
+            }
+
+            d->memory->unlock();
         }
-        d->memory->unlock();
-        return;
-      }
-
-      d->memory->unlock();
     }
-  }
 
-  d->connectToPrimary(timeout, SingleApplicationPrivate::NewInstance);
-  delete d;
-  ::exit(EXIT_SUCCESS);
+    d->connectToPrimary(timeout, SingleApplicationPrivate::NewInstance);
+    delete d;
+    ::exit(EXIT_SUCCESS);
 }
 
 /**
@@ -446,52 +442,47 @@ SingleApplication::SingleApplication(int& argc,
  */
 SingleApplication::~SingleApplication()
 {
-  Q_D(SingleApplication);
-  delete d;
+    Q_D(SingleApplication);
+    delete d;
 }
 
-bool
-SingleApplication::isPrimary()
+bool SingleApplication::isPrimary()
 {
-  Q_D(SingleApplication);
-  return d->server != nullptr;
+    Q_D(SingleApplication);
+    return d->server != nullptr;
 }
 
-bool
-SingleApplication::isSecondary()
+bool SingleApplication::isSecondary()
 {
-  Q_D(SingleApplication);
-  return d->server == nullptr;
+    Q_D(SingleApplication);
+    return d->server == nullptr;
 }
 
-quint32
-SingleApplication::instanceId()
+quint32 SingleApplication::instanceId()
 {
-  Q_D(SingleApplication);
-  return d->instanceNumber;
+    Q_D(SingleApplication);
+    return d->instanceNumber;
 }
 
-qint64
-SingleApplication::primaryPid()
+qint64 SingleApplication::primaryPid()
 {
-  Q_D(SingleApplication);
-  return d->primaryPid();
+    Q_D(SingleApplication);
+    return d->primaryPid();
 }
 
-bool
-SingleApplication::sendMessage(QByteArray message, int timeout)
+bool SingleApplication::sendMessage(QByteArray message, int timeout)
 {
-  Q_D(SingleApplication);
+    Q_D(SingleApplication);
 
-  // Nobody to connect to
-  if (isPrimary())
-    return false;
+    // Nobody to connect to
+    if (isPrimary())
+        return false;
 
-  // Make sure the socket is connected
-  d->connectToPrimary(timeout, SingleApplicationPrivate::Reconnect);
+    // Make sure the socket is connected
+    d->connectToPrimary(timeout, SingleApplicationPrivate::Reconnect);
 
-  d->socket->write(message);
-  bool dataWritten = d->socket->flush();
-  d->socket->waitForBytesWritten(timeout);
-  return dataWritten;
+    d->socket->write(message);
+    bool dataWritten = d->socket->flush();
+    d->socket->waitForBytesWritten(timeout);
+    return dataWritten;
 }
diff --git a/external/singleapplication/singleapplication.h b/external/singleapplication/singleapplication.h
index 23872809..18115af4 100644
--- a/external/singleapplication/singleapplication.h
+++ b/external/singleapplication/singleapplication.h
@@ -41,98 +41,98 @@ class SingleApplicationPrivate;
  */
 class SingleApplication : public QAPPLICATION_CLASS
 {
-  Q_OBJECT
+    Q_OBJECT
 
-  typedef QAPPLICATION_CLASS app_t;
+    typedef QAPPLICATION_CLASS app_t;
 
 public:
-  /**
-   * @brief Mode of operation of SingleApplication.
-   * Whether the block should be user-wide or system-wide and whether the
-   * primary instance should be notified when a secondary instance had been
-   * started.
-   * @note Operating system can restrict the shared memory blocks to the same
-   * user, in which case the User/System modes will have no effect and the
-   * block will be user wide.
-   * @enum
-   */
-  enum Mode
-  {
-    User = 1 << 0,
-    System = 1 << 1,
-    SecondaryNotification = 1 << 2,
-    ExcludeAppVersion = 1 << 3,
-    ExcludeAppPath = 1 << 4
-  };
-  Q_DECLARE_FLAGS(Options, Mode)
-
-  /**
-   * @brief Intitializes a SingleApplication instance with argc command line
-   * arguments in argv
-   * @arg {int &} argc - Number of arguments in argv
-   * @arg {const char *[]} argv - Supplied command line arguments
-   * @arg {bool} allowSecondary - Whether to start the instance as secondary
-   * if there is already a primary instance.
-   * @arg {Mode} mode - Whether for the SingleApplication block to be applied
-   * User wide or System wide.
-   * @arg {int} timeout - Timeout to wait in miliseconds.
-   * @note argc and argv may be changed as Qt removes arguments that it
-   * recognizes
-   * @note Mode::SecondaryNotification only works if set on both the primary
-   * instance and the secondary instance.
-   * @note The timeout is just a hint for the maximum time of blocking
-   * operations. It does not guarantee that the SingleApplication
-   * initialisation will be completed in given time, though is a good hint.
-   * Usually 4*timeout would be the worst case (fail) scenario.
-   * @see See the corresponding QAPPLICATION_CLASS constructor for reference
-   */
-  explicit SingleApplication(int& argc,
-                             char* argv[],
-                             bool allowSecondary = false,
-                             Options options = Mode::User,
-                             int timeout = 100);
-  ~SingleApplication();
-
-  /**
-   * @brief Returns if the instance is the primary instance
-   * @returns {bool}
-   */
-  bool isPrimary();
-
-  /**
-   * @brief Returns if the instance is a secondary instance
-   * @returns {bool}
-   */
-  bool isSecondary();
-
-  /**
-   * @brief Returns a unique identifier for the current instance
-   * @returns {qint32}
-   */
-  quint32 instanceId();
-
-  /**
-   * @brief Returns the process ID (PID) of the primary instance
-   * @returns {qint64}
-   */
-  qint64 primaryPid();
-
-  /**
-   * @brief Sends a message to the primary instance. Returns true on success.
-   * @param {int} timeout - Timeout for connecting
-   * @returns {bool}
-   * @note sendMessage() will return false if invoked from the primary
-   * instance.
-   */
-  bool sendMessage(QByteArray message, int timeout = 100);
+    /**
+     * @brief Mode of operation of SingleApplication.
+     * Whether the block should be user-wide or system-wide and whether the
+     * primary instance should be notified when a secondary instance had been
+     * started.
+     * @note Operating system can restrict the shared memory blocks to the same
+     * user, in which case the User/System modes will have no effect and the
+     * block will be user wide.
+     * @enum
+     */
+    enum Mode
+    {
+        User = 1 << 0,
+        System = 1 << 1,
+        SecondaryNotification = 1 << 2,
+        ExcludeAppVersion = 1 << 3,
+        ExcludeAppPath = 1 << 4
+    };
+    Q_DECLARE_FLAGS(Options, Mode)
+
+    /**
+     * @brief Intitializes a SingleApplication instance with argc command line
+     * arguments in argv
+     * @arg {int &} argc - Number of arguments in argv
+     * @arg {const char *[]} argv - Supplied command line arguments
+     * @arg {bool} allowSecondary - Whether to start the instance as secondary
+     * if there is already a primary instance.
+     * @arg {Mode} mode - Whether for the SingleApplication block to be applied
+     * User wide or System wide.
+     * @arg {int} timeout - Timeout to wait in miliseconds.
+     * @note argc and argv may be changed as Qt removes arguments that it
+     * recognizes
+     * @note Mode::SecondaryNotification only works if set on both the primary
+     * instance and the secondary instance.
+     * @note The timeout is just a hint for the maximum time of blocking
+     * operations. It does not guarantee that the SingleApplication
+     * initialisation will be completed in given time, though is a good hint.
+     * Usually 4*timeout would be the worst case (fail) scenario.
+     * @see See the corresponding QAPPLICATION_CLASS constructor for reference
+     */
+    explicit SingleApplication(int& argc,
+                               char* argv[],
+                               bool allowSecondary = false,
+                               Options options = Mode::User,
+                               int timeout = 100);
+    ~SingleApplication();
+
+    /**
+     * @brief Returns if the instance is the primary instance
+     * @returns {bool}
+     */
+    bool isPrimary();
+
+    /**
+     * @brief Returns if the instance is a secondary instance
+     * @returns {bool}
+     */
+    bool isSecondary();
+
+    /**
+     * @brief Returns a unique identifier for the current instance
+     * @returns {qint32}
+     */
+    quint32 instanceId();
+
+    /**
+     * @brief Returns the process ID (PID) of the primary instance
+     * @returns {qint64}
+     */
+    qint64 primaryPid();
+
+    /**
+     * @brief Sends a message to the primary instance. Returns true on success.
+     * @param {int} timeout - Timeout for connecting
+     * @returns {bool}
+     * @note sendMessage() will return false if invoked from the primary
+     * instance.
+     */
+    bool sendMessage(QByteArray message, int timeout = 100);
 
 Q_SIGNALS:
-  void instanceStarted();
-  void receivedMessage(quint32 instanceId, QByteArray message);
+    void instanceStarted();
+    void receivedMessage(quint32 instanceId, QByteArray message);
 
 private:
-  SingleApplicationPrivate* d_ptr;
-  Q_DECLARE_PRIVATE(SingleApplication)
+    SingleApplicationPrivate* d_ptr;
+    Q_DECLARE_PRIVATE(SingleApplication)
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(SingleApplication::Options)
diff --git a/external/singleapplication/singleapplication_p.h b/external/singleapplication/singleapplication_p.h
index 90885ed9..491f246d 100644
--- a/external/singleapplication/singleapplication_p.h
+++ b/external/singleapplication/singleapplication_p.h
@@ -39,50 +39,50 @@
 
 struct InstancesInfo
 {
-  bool primary;
-  quint32 secondary;
-  qint64 primaryPid;
+    bool primary;
+    quint32 secondary;
+    qint64 primaryPid;
 };
 
 class SingleApplicationPrivate : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  enum ConnectionType : quint8
-  {
-    InvalidConnection = 0,
-    NewInstance = 1,
-    SecondaryInstance = 2,
-    Reconnect = 3
-  };
-  Q_DECLARE_PUBLIC(SingleApplication)
+    enum ConnectionType : quint8
+    {
+        InvalidConnection = 0,
+        NewInstance = 1,
+        SecondaryInstance = 2,
+        Reconnect = 3
+    };
+    Q_DECLARE_PUBLIC(SingleApplication)
 
-  SingleApplicationPrivate(SingleApplication* q_ptr);
-  ~SingleApplicationPrivate();
+    SingleApplicationPrivate(SingleApplication* q_ptr);
+    ~SingleApplicationPrivate();
 
-  void genBlockServerName(int msecs);
-  void startPrimary(bool resetMemory);
-  void startSecondary();
-  void connectToPrimary(int msecs, ConnectionType connectionType);
-  qint64 primaryPid();
+    void genBlockServerName(int msecs);
+    void startPrimary(bool resetMemory);
+    void startSecondary();
+    void connectToPrimary(int msecs, ConnectionType connectionType);
+    qint64 primaryPid();
 
 #ifdef Q_OS_UNIX
-  void crashHandler();
-  static void terminate(int signum);
+    void crashHandler();
+    static void terminate(int signum);
 #endif
 
-  QSharedMemory* memory;
-  SingleApplication* q_ptr;
-  QLocalSocket* socket;
-  QLocalServer* server;
-  quint32 instanceNumber;
-  QString blockServerName;
-  SingleApplication::Options options;
+    QSharedMemory* memory;
+    SingleApplication* q_ptr;
+    QLocalSocket* socket;
+    QLocalServer* server;
+    quint32 instanceNumber;
+    QString blockServerName;
+    SingleApplication::Options options;
 
 public Q_SLOTS:
-  void slotConnectionEstablished();
-  void slotDataAvailable(QLocalSocket*, quint32);
-  void slotClientConnectionClosed(QLocalSocket*, quint32);
+    void slotConnectionEstablished();
+    void slotDataAvailable(QLocalSocket*, quint32);
+    void slotClientConnectionClosed(QLocalSocket*, quint32);
 };
 
 #endif // SINGLEAPPLICATION_P_H
diff --git a/src/cli/commandargument.cpp b/src/cli/commandargument.cpp
index ef7da845..f1eeeda9 100644
--- a/src/cli/commandargument.cpp
+++ b/src/cli/commandargument.cpp
@@ -25,38 +25,32 @@ CommandArgument::CommandArgument(const QString& name,
   , m_description(description)
 {}
 
-void
-CommandArgument::setName(const QString& name)
+void CommandArgument::setName(const QString& name)
 {
-  m_name = name;
+    m_name = name;
 }
 
-QString
-CommandArgument::name() const
+QString CommandArgument::name() const
 {
-  return m_name;
+    return m_name;
 }
 
-void
-CommandArgument::setDescription(const QString& description)
+void CommandArgument::setDescription(const QString& description)
 {
-  m_description = description;
+    m_description = description;
 }
 
-QString
-CommandArgument::description() const
+QString CommandArgument::description() const
 {
-  return m_description;
+    return m_description;
 }
 
-bool
-CommandArgument::isRoot() const
+bool CommandArgument::isRoot() const
 {
-  return m_name.isEmpty() && m_description.isEmpty();
+    return m_name.isEmpty() && m_description.isEmpty();
 }
 
-bool
-CommandArgument::operator==(const CommandArgument& arg) const
+bool CommandArgument::operator==(const CommandArgument& arg) const
 {
-  return m_description == arg.m_description && m_name == arg.m_name;
+    return m_description == arg.m_description && m_name == arg.m_name;
 }
diff --git a/src/cli/commandargument.h b/src/cli/commandargument.h
index e37f0e24..64211833 100644
--- a/src/cli/commandargument.h
+++ b/src/cli/commandargument.h
@@ -22,20 +22,20 @@
 class CommandArgument
 {
 public:
-  CommandArgument();
-  explicit CommandArgument(const QString& name, const QString& description);
+    CommandArgument();
+    explicit CommandArgument(const QString& name, const QString& description);
 
-  void setName(const QString& name);
-  QString name() const;
+    void setName(const QString& name);
+    QString name() const;
 
-  void setDescription(const QString& description);
-  QString description() const;
+    void setDescription(const QString& description);
+    QString description() const;
 
-  bool isRoot() const;
+    bool isRoot() const;
 
-  bool operator==(const CommandArgument& arg) const;
+    bool operator==(const CommandArgument& arg) const;
 
 private:
-  QString m_name;
-  QString m_description;
+    QString m_name;
+    QString m_description;
 };
diff --git a/src/cli/commandlineparser.cpp b/src/cli/commandlineparser.cpp
index b7d40ac4..049dbd22 100644
--- a/src/cli/commandlineparser.cpp
+++ b/src/cli/commandlineparser.cpp
@@ -34,399 +34,386 @@ auto versionOption =
 auto helpOption =
   CommandOption({ "h", "help" }, QStringLiteral("Displays this help"));
 
-QString
-optionsToString(const QList<CommandOption>& options,
-                const QList<CommandArgument>& arguments)
+QString optionsToString(const QList<CommandOption>& options,
+                        const QList<CommandArgument>& arguments)
 {
-  int size = 0; // track the largest size
-  QStringList dashedOptionList;
-  // save the dashed options and its size in order to print the description
-  // of every option at the same horizontal character position.
-  for (auto const& option : options) {
-    QStringList dashedOptions = option.dashedNames();
-    QString joinedDashedOptions = dashedOptions.join(QStringLiteral(", "));
-    if (!option.valueName().isEmpty()) {
-      joinedDashedOptions += QStringLiteral(" <%1>").arg(option.valueName());
+    int size = 0; // track the largest size
+    QStringList dashedOptionList;
+    // save the dashed options and its size in order to print the description
+    // of every option at the same horizontal character position.
+    for (auto const& option : options) {
+        QStringList dashedOptions = option.dashedNames();
+        QString joinedDashedOptions = dashedOptions.join(QStringLiteral(", "));
+        if (!option.valueName().isEmpty()) {
+            joinedDashedOptions +=
+              QStringLiteral(" <%1>").arg(option.valueName());
+        }
+        if (joinedDashedOptions.length() > size) {
+            size = joinedDashedOptions.length();
+        }
+        dashedOptionList << joinedDashedOptions;
     }
-    if (joinedDashedOptions.length() > size) {
-      size = joinedDashedOptions.length();
+    // check the length of the arguments
+    for (auto const& arg : arguments) {
+        if (arg.name().length() > size)
+            size = arg.name().length();
     }
-    dashedOptionList << joinedDashedOptions;
-  }
-  // check the length of the arguments
-  for (auto const& arg : arguments) {
-    if (arg.name().length() > size)
-      size = arg.name().length();
-  }
-  // generate the text
-  QString result;
-  if (!dashedOptionList.isEmpty()) {
-    result += QObject::tr("Options") + ":\n";
-    QString linePadding = QStringLiteral(" ").repeated(size + 4).prepend("\n");
-    for (int i = 0; i < options.length(); ++i) {
-      result += QStringLiteral("  %1  %2\n")
-                  .arg(dashedOptionList.at(i).leftJustified(size, ' '))
-                  .arg(options.at(i).description().replace(QLatin1String("\n"),
-                                                           linePadding));
+    // generate the text
+    QString result;
+    if (!dashedOptionList.isEmpty()) {
+        result += QObject::tr("Options") + ":\n";
+        QString linePadding =
+          QStringLiteral(" ").repeated(size + 4).prepend("\n");
+        for (int i = 0; i < options.length(); ++i) {
+            result += QStringLiteral("  %1  %2\n")
+                        .arg(dashedOptionList.at(i).leftJustified(size, ' '))
+                        .arg(options.at(i).description().replace(
+                          QLatin1String("\n"), linePadding));
+        }
+        if (!arguments.isEmpty()) {
+            result += QLatin1String("\n");
+        }
     }
     if (!arguments.isEmpty()) {
-      result += QLatin1String("\n");
+        result += QObject::tr("Arguments") + ":\n";
     }
-  }
-  if (!arguments.isEmpty()) {
-    result += QObject::tr("Arguments") + ":\n";
-  }
-  for (int i = 0; i < arguments.length(); ++i) {
-    result += QStringLiteral("  %1  %2\n")
-                .arg(arguments.at(i).name().leftJustified(size, ' '))
-                .arg(arguments.at(i).description());
-  }
-  return result;
+    for (int i = 0; i < arguments.length(); ++i) {
+        result += QStringLiteral("  %1  %2\n")
+                    .arg(arguments.at(i).name().leftJustified(size, ' '))
+                    .arg(arguments.at(i).description());
+    }
+    return result;
 }
 
 } // unnamed namespace
 
-bool
-CommandLineParser::processArgs(const QStringList& args,
-                               QStringList::const_iterator& actualIt,
-                               Node*& actualNode)
+bool CommandLineParser::processArgs(const QStringList& args,
+                                    QStringList::const_iterator& actualIt,
+                                    Node*& actualNode)
 {
-  QString argument = *actualIt;
-  bool ok = true;
-  bool isValidArg = false;
-  for (Node& n : actualNode->subNodes) {
-    if (n.argument.name() == argument) {
-      actualNode = &n;
-      isValidArg = true;
-      break;
+    QString argument = *actualIt;
+    bool ok = true;
+    bool isValidArg = false;
+    for (Node& n : actualNode->subNodes) {
+        if (n.argument.name() == argument) {
+            actualNode = &n;
+            isValidArg = true;
+            break;
+        }
+    }
+    if (isValidArg) {
+        auto nextArg = actualNode->argument;
+        m_foundArgs.append(nextArg);
+        // check next is help
+        ++actualIt;
+        ok = processIfOptionIsHelp(args, actualIt, actualNode);
+        --actualIt;
+    } else {
+        ok = false;
+        out << QStringLiteral("'%1' is not a valid argument.").arg(argument);
     }
-  }
-  if (isValidArg) {
-    auto nextArg = actualNode->argument;
-    m_foundArgs.append(nextArg);
-    // check next is help
-    ++actualIt;
-    ok = processIfOptionIsHelp(args, actualIt, actualNode);
-    --actualIt;
-  } else {
-    ok = false;
-    out << QStringLiteral("'%1' is not a valid argument.").arg(argument);
-  }
-  return ok;
+    return ok;
 }
 
-bool
-CommandLineParser::processOptions(const QStringList& args,
-                                  QStringList::const_iterator& actualIt,
-                                  Node* const actualNode)
+bool CommandLineParser::processOptions(const QStringList& args,
+                                       QStringList::const_iterator& actualIt,
+                                       Node* const actualNode)
 {
-  QString arg = *actualIt;
-  bool ok = true;
-  // track values
-  int equalsPos = arg.indexOf(QLatin1String("="));
-  QString valueStr;
-  if (equalsPos != -1) {
-    valueStr = arg.mid(equalsPos + 1); // right
-    arg = arg.mid(0, equalsPos);       // left
-  }
-  // check format -x --xx...
-  bool isDoubleDashed = arg.startsWith(QLatin1String("--"));
-  ok = isDoubleDashed ? arg.length() > 3 : arg.length() == 2;
-  if (!ok) {
-    out << QStringLiteral("the option %1 has a wrong format.").arg(arg);
-    return ok;
-  }
-  arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1);
-  // get option
-  auto endIt = actualNode->options.cend();
-  auto optionIt = endIt;
-  for (auto i = actualNode->options.cbegin(); i != endIt; ++i) {
-    if ((*i).names().contains(arg)) {
-      optionIt = i;
-      break;
+    QString arg = *actualIt;
+    bool ok = true;
+    // track values
+    int equalsPos = arg.indexOf(QLatin1String("="));
+    QString valueStr;
+    if (equalsPos != -1) {
+        valueStr = arg.mid(equalsPos + 1); // right
+        arg = arg.mid(0, equalsPos);       // left
     }
-  }
-  if (optionIt == endIt) {
-    QString argName = actualNode->argument.name();
-    if (argName.isEmpty()) {
-      argName = qApp->applicationName();
+    // check format -x --xx...
+    bool isDoubleDashed = arg.startsWith(QLatin1String("--"));
+    ok = isDoubleDashed ? arg.length() > 3 : arg.length() == 2;
+    if (!ok) {
+        out << QStringLiteral("the option %1 has a wrong format.").arg(arg);
+        return ok;
     }
-    out << QStringLiteral("the option '%1' is not a valid option "
-                          "for the argument '%2'.")
-             .arg(arg)
-             .arg(argName);
-    ok = false;
-    return ok;
-  }
-  // check presence of values
-  CommandOption option = *optionIt;
-  bool requiresValue = !(option.valueName().isEmpty());
-  if (!requiresValue && equalsPos != -1) {
-    out << QStringLiteral("the option '%1' contains a '=' and it doesn't "
-                          "require a value.")
-             .arg(arg);
-    ok = false;
-    return ok;
-  } else if (requiresValue && valueStr.isEmpty()) {
-    // find in the next
-    if (actualIt + 1 != args.cend()) {
-      ++actualIt;
-    } else {
-      out << QStringLiteral("Expected value after the option '%1'.").arg(arg);
-      ok = false;
-      return ok;
+    arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1);
+    // get option
+    auto endIt = actualNode->options.cend();
+    auto optionIt = endIt;
+    for (auto i = actualNode->options.cbegin(); i != endIt; ++i) {
+        if ((*i).names().contains(arg)) {
+            optionIt = i;
+            break;
+        }
     }
-    valueStr = *actualIt;
-  }
-  // check the value correctness
-  if (requiresValue) {
-    ok = option.checkValue(valueStr);
-    if (!ok) {
-      QString err = option.errorMsg();
-      if (!err.endsWith(QLatin1String(".")))
-        err += QLatin1String(".");
-      out << err;
-      return ok;
+    if (optionIt == endIt) {
+        QString argName = actualNode->argument.name();
+        if (argName.isEmpty()) {
+            argName = qApp->applicationName();
+        }
+        out << QStringLiteral("the option '%1' is not a valid option "
+                              "for the argument '%2'.")
+                 .arg(arg)
+                 .arg(argName);
+        ok = false;
+        return ok;
+    }
+    // check presence of values
+    CommandOption option = *optionIt;
+    bool requiresValue = !(option.valueName().isEmpty());
+    if (!requiresValue && equalsPos != -1) {
+        out << QStringLiteral("the option '%1' contains a '=' and it doesn't "
+                              "require a value.")
+                 .arg(arg);
+        ok = false;
+        return ok;
+    } else if (requiresValue && valueStr.isEmpty()) {
+        // find in the next
+        if (actualIt + 1 != args.cend()) {
+            ++actualIt;
+        } else {
+            out << QStringLiteral("Expected value after the option '%1'.")
+                     .arg(arg);
+            ok = false;
+            return ok;
+        }
+        valueStr = *actualIt;
     }
-    option.setValue(valueStr);
-  }
-  m_foundOptions.append(option);
-  return ok;
+    // check the value correctness
+    if (requiresValue) {
+        ok = option.checkValue(valueStr);
+        if (!ok) {
+            QString err = option.errorMsg();
+            if (!err.endsWith(QLatin1String(".")))
+                err += QLatin1String(".");
+            out << err;
+            return ok;
+        }
+        option.setValue(valueStr);
+    }
+    m_foundOptions.append(option);
+    return ok;
 }
 
-bool
-CommandLineParser::parse(const QStringList& args)
+bool CommandLineParser::parse(const QStringList& args)
 {
-  m_foundArgs.clear();
-  m_foundOptions.clear();
-  bool ok = true;
-  Node* actualNode = &m_parseTree;
-  auto it = ++args.cbegin();
-  // check  version option
-  QStringList dashedVersion = versionOption.dashedNames();
-  if (m_withVersion && args.length() > 1 &&
-      dashedVersion.contains(args.at(1))) {
-    if (args.length() == 2) {
-      printVersion();
-      m_foundOptions << versionOption;
-    } else {
-      out << "Invalid arguments after the version option.";
-      ok = false;
+    m_foundArgs.clear();
+    m_foundOptions.clear();
+    bool ok = true;
+    Node* actualNode = &m_parseTree;
+    auto it = ++args.cbegin();
+    // check  version option
+    QStringList dashedVersion = versionOption.dashedNames();
+    if (m_withVersion && args.length() > 1 &&
+        dashedVersion.contains(args.at(1))) {
+        if (args.length() == 2) {
+            printVersion();
+            m_foundOptions << versionOption;
+        } else {
+            out << "Invalid arguments after the version option.";
+            ok = false;
+        }
+        return ok;
     }
-    return ok;
-  }
-  // check  help option
-  ok = processIfOptionIsHelp(args, it, actualNode);
-  // process the other args
-  for (; it != args.cend() && ok; ++it) {
-    const QString& value = *it;
-    if (value.startsWith(QLatin1String("-"))) {
-      ok = processOptions(args, it, actualNode);
+    // check  help option
+    ok = processIfOptionIsHelp(args, it, actualNode);
+    // process the other args
+    for (; it != args.cend() && ok; ++it) {
+        const QString& value = *it;
+        if (value.startsWith(QLatin1String("-"))) {
+            ok = processOptions(args, it, actualNode);
 
-    } else {
-      ok = processArgs(args, it, actualNode);
+        } else {
+            ok = processArgs(args, it, actualNode);
+        }
     }
-  }
-  if (!ok && !m_generalErrorMessage.isEmpty()) {
-    out << QStringLiteral(" %1\n").arg(m_generalErrorMessage);
-  }
-  return ok;
+    if (!ok && !m_generalErrorMessage.isEmpty()) {
+        out << QStringLiteral(" %1\n").arg(m_generalErrorMessage);
+    }
+    return ok;
 }
 
-CommandOption
-CommandLineParser::addVersionOption()
+CommandOption CommandLineParser::addVersionOption()
 {
-  m_withVersion = true;
-  return versionOption;
+    m_withVersion = true;
+    return versionOption;
 }
 
-CommandOption
-CommandLineParser::addHelpOption()
+CommandOption CommandLineParser::addHelpOption()
 {
-  m_withHelp = true;
-  return helpOption;
+    m_withHelp = true;
+    return helpOption;
 }
 
-bool
-CommandLineParser::AddArgument(const CommandArgument& arg,
-                               const CommandArgument& parent)
+bool CommandLineParser::AddArgument(const CommandArgument& arg,
+                                    const CommandArgument& parent)
 {
-  bool res = true;
-  Node* n = findParent(parent);
-  if (n == nullptr) {
-    res = false;
-  } else {
-    Node child;
-    child.argument = arg;
-    n->subNodes.append(child);
-  }
-  return res;
+    bool res = true;
+    Node* n = findParent(parent);
+    if (n == nullptr) {
+        res = false;
+    } else {
+        Node child;
+        child.argument = arg;
+        n->subNodes.append(child);
+    }
+    return res;
 }
 
-bool
-CommandLineParser::AddOption(const CommandOption& option,
-                             const CommandArgument& parent)
+bool CommandLineParser::AddOption(const CommandOption& option,
+                                  const CommandArgument& parent)
 {
-  bool res = true;
-  Node* n = findParent(parent);
-  if (n == nullptr) {
-    res = false;
-  } else {
-    n->options.append(option);
-  }
-  return res;
+    bool res = true;
+    Node* n = findParent(parent);
+    if (n == nullptr) {
+        res = false;
+    } else {
+        n->options.append(option);
+    }
+    return res;
 }
 
-bool
-CommandLineParser::AddOptions(const QList<CommandOption>& options,
-                              const CommandArgument& parent)
+bool CommandLineParser::AddOptions(const QList<CommandOption>& options,
+                                   const CommandArgument& parent)
 {
-  bool res = true;
-  for (auto const& option : options) {
-    if (!AddOption(option, parent)) {
-      res = false;
-      break;
+    bool res = true;
+    for (auto const& option : options) {
+        if (!AddOption(option, parent)) {
+            res = false;
+            break;
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-void
-CommandLineParser::setGeneralErrorMessage(const QString& msg)
+void CommandLineParser::setGeneralErrorMessage(const QString& msg)
 {
-  m_generalErrorMessage = msg;
+    m_generalErrorMessage = msg;
 }
 
-void
-CommandLineParser::setDescription(const QString& description)
+void CommandLineParser::setDescription(const QString& description)
 {
-  m_description = description;
+    m_description = description;
 }
 
-bool
-CommandLineParser::isSet(const CommandArgument& arg) const
+bool CommandLineParser::isSet(const CommandArgument& arg) const
 {
-  return m_foundArgs.contains(arg);
+    return m_foundArgs.contains(arg);
 }
 
-bool
-CommandLineParser::isSet(const CommandOption& option) const
+bool CommandLineParser::isSet(const CommandOption& option) const
 {
-  return m_foundOptions.contains(option);
+    return m_foundOptions.contains(option);
 }
 
-QString
-CommandLineParser::value(const CommandOption& option) const
+QString CommandLineParser::value(const CommandOption& option) const
 {
-  QString value = option.value();
-  for (const CommandOption& fOption : m_foundOptions) {
-    if (option == fOption) {
-      value = fOption.value();
-      break;
+    QString value = option.value();
+    for (const CommandOption& fOption : m_foundOptions) {
+        if (option == fOption) {
+            value = fOption.value();
+            break;
+        }
     }
-  }
-  return value;
+    return value;
 }
 
-void
-CommandLineParser::printVersion()
+void CommandLineParser::printVersion()
 {
-  out << "Flameshot " << qApp->applicationVersion() << "\nCompiled with Qt "
-      << static_cast<QString>(QT_VERSION_STR) << "\n";
+    out << "Flameshot " << qApp->applicationVersion() << "\nCompiled with Qt "
+        << static_cast<QString>(QT_VERSION_STR) << "\n";
 }
 
-void
-CommandLineParser::printHelp(QStringList args, const Node* node)
+void CommandLineParser::printHelp(QStringList args, const Node* node)
 {
-  args.removeLast(); // remove the help, it's always the last
-  QString helpText;
+    args.removeLast(); // remove the help, it's always the last
+    QString helpText;
 
-  // add usage info
-  QString argName = node->argument.name();
-  if (argName.isEmpty()) {
-    argName = qApp->applicationName();
-  }
-  QString argText =
-    node->subNodes.isEmpty() ? "" : "[" + QObject::tr("arguments") + "]";
-  helpText += QObject::tr("Usage") + ": %1 [%2-" + QObject::tr("options") +
-              QStringLiteral("] %3\n\n")
-                .arg(args.join(QStringLiteral(" ")))
-                .arg(argName)
-                .arg(argText);
+    // add usage info
+    QString argName = node->argument.name();
+    if (argName.isEmpty()) {
+        argName = qApp->applicationName();
+    }
+    QString argText =
+      node->subNodes.isEmpty() ? "" : "[" + QObject::tr("arguments") + "]";
+    helpText += QObject::tr("Usage") + ": %1 [%2-" + QObject::tr("options") +
+                QStringLiteral("] %3\n\n")
+                  .arg(args.join(QStringLiteral(" ")))
+                  .arg(argName)
+                  .arg(argText);
 
-  // short section about default behavior
-  helpText += QObject::tr("Per default runs Flameshot in the background and \
+    // short section about default behavior
+    helpText += QObject::tr("Per default runs Flameshot in the background and \
   adds a tray icon for configuration.");
-  helpText += "\n\n";
+    helpText += "\n\n";
 
-  // add command options and subarguments
-  QList<CommandArgument> subArgs;
-  for (const Node& n : node->subNodes)
-    subArgs.append(n.argument);
-  auto modifiedOptions = node->options;
-  if (m_withHelp)
-    modifiedOptions << helpOption;
-  if (m_withVersion && node == &m_parseTree) {
-    modifiedOptions << versionOption;
-  }
-  helpText += optionsToString(modifiedOptions, subArgs);
-  // print it
-  out << helpText;
+    // add command options and subarguments
+    QList<CommandArgument> subArgs;
+    for (const Node& n : node->subNodes)
+        subArgs.append(n.argument);
+    auto modifiedOptions = node->options;
+    if (m_withHelp)
+        modifiedOptions << helpOption;
+    if (m_withVersion && node == &m_parseTree) {
+        modifiedOptions << versionOption;
+    }
+    helpText += optionsToString(modifiedOptions, subArgs);
+    // print it
+    out << helpText;
 }
 
-CommandLineParser::Node*
-CommandLineParser::findParent(const CommandArgument& parent)
+CommandLineParser::Node* CommandLineParser::findParent(
+  const CommandArgument& parent)
 {
-  if (parent == CommandArgument()) {
-    return &m_parseTree;
-  }
-  // find the parent in the subNodes recursively
-  Node* res = nullptr;
-  for (auto i = m_parseTree.subNodes.begin(); i != m_parseTree.subNodes.end();
-       ++i) {
-    res = recursiveParentSearch(parent, *i);
-    if (res != nullptr) {
-      break;
+    if (parent == CommandArgument()) {
+        return &m_parseTree;
+    }
+    // find the parent in the subNodes recursively
+    Node* res = nullptr;
+    for (auto i = m_parseTree.subNodes.begin(); i != m_parseTree.subNodes.end();
+         ++i) {
+        res = recursiveParentSearch(parent, *i);
+        if (res != nullptr) {
+            break;
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-CommandLineParser::Node*
-CommandLineParser::recursiveParentSearch(const CommandArgument& parent,
-                                         Node& node) const
+CommandLineParser::Node* CommandLineParser::recursiveParentSearch(
+  const CommandArgument& parent,
+  Node& node) const
 {
-  Node* res = nullptr;
-  if (node.argument == parent) {
-    res = &node;
-  } else {
-    for (auto i = node.subNodes.begin(); i != node.subNodes.end(); ++i) {
-      res = recursiveParentSearch(parent, *i);
-      if (res != nullptr) {
-        break;
-      }
+    Node* res = nullptr;
+    if (node.argument == parent) {
+        res = &node;
+    } else {
+        for (auto i = node.subNodes.begin(); i != node.subNodes.end(); ++i) {
+            res = recursiveParentSearch(parent, *i);
+            if (res != nullptr) {
+                break;
+            }
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-bool
-CommandLineParser::processIfOptionIsHelp(const QStringList& args,
-                                         QStringList::const_iterator& actualIt,
-                                         Node*& actualNode)
+bool CommandLineParser::processIfOptionIsHelp(
+  const QStringList& args,
+  QStringList::const_iterator& actualIt,
+  Node*& actualNode)
 {
-  bool ok = true;
-  auto dashedHelpNames = helpOption.dashedNames();
-  if (m_withHelp && actualIt != args.cend() &&
-      dashedHelpNames.contains(*actualIt)) {
-    if (actualIt + 1 == args.cend()) {
-      m_foundOptions << helpOption;
-      printHelp(args, actualNode);
-      actualIt++;
-    } else {
-      out << "Invalid arguments after the help option.";
-      ok = false;
+    bool ok = true;
+    auto dashedHelpNames = helpOption.dashedNames();
+    if (m_withHelp && actualIt != args.cend() &&
+        dashedHelpNames.contains(*actualIt)) {
+        if (actualIt + 1 == args.cend()) {
+            m_foundOptions << helpOption;
+            printHelp(args, actualNode);
+            actualIt++;
+        } else {
+            out << "Invalid arguments after the help option.";
+            ok = false;
+        }
     }
-  }
-  return ok;
+    return ok;
 }
diff --git a/src/cli/commandlineparser.h b/src/cli/commandlineparser.h
index 1635edbe..5fc9ad90 100644
--- a/src/cli/commandlineparser.h
+++ b/src/cli/commandlineparser.h
@@ -24,69 +24,70 @@
 class CommandLineParser
 {
 public:
-  CommandLineParser();
+    CommandLineParser();
 
-  bool parse(const QStringList& args);
+    bool parse(const QStringList& args);
 
-  CommandArgument rootArgument() const { return CommandArgument(); }
+    CommandArgument rootArgument() const { return CommandArgument(); }
 
-  CommandOption addVersionOption();
-  CommandOption addHelpOption();
+    CommandOption addVersionOption();
+    CommandOption addHelpOption();
 
-  bool AddArgument(const CommandArgument& arg,
-                   const CommandArgument& parent = CommandArgument());
+    bool AddArgument(const CommandArgument& arg,
+                     const CommandArgument& parent = CommandArgument());
 
-  bool AddOption(const CommandOption& option,
-                 const CommandArgument& parent = CommandArgument());
+    bool AddOption(const CommandOption& option,
+                   const CommandArgument& parent = CommandArgument());
 
-  bool AddOptions(const QList<CommandOption>& options,
-                  const CommandArgument& parent = CommandArgument());
+    bool AddOptions(const QList<CommandOption>& options,
+                    const CommandArgument& parent = CommandArgument());
 
-  void setGeneralErrorMessage(const QString& msg);
-  void setDescription(const QString& description);
+    void setGeneralErrorMessage(const QString& msg);
+    void setDescription(const QString& description);
 
-  bool isSet(const CommandArgument& arg) const;
-  bool isSet(const CommandOption& option) const;
-  QString value(const CommandOption& option) const;
+    bool isSet(const CommandArgument& arg) const;
+    bool isSet(const CommandOption& option) const;
+    QString value(const CommandOption& option) const;
 
 private:
-  bool m_withHelp = false;
-  bool m_withVersion = false;
-  QString m_description;
-  QString m_generalErrorMessage;
+    bool m_withHelp = false;
+    bool m_withVersion = false;
+    QString m_description;
+    QString m_generalErrorMessage;
 
-  struct Node
-  {
-    explicit Node(const CommandArgument& arg)
-      : argument(arg)
-    {}
-    Node() {}
-    bool operator==(const Node& n) const
+    struct Node
     {
-      return argument == n.argument && options == n.options &&
-             subNodes == n.subNodes;
-    }
-    CommandArgument argument;
-    QList<CommandOption> options;
-    QList<Node> subNodes;
-  };
+        explicit Node(const CommandArgument& arg)
+          : argument(arg)
+        {}
+        Node() {}
+        bool operator==(const Node& n) const
+        {
+            return argument == n.argument && options == n.options &&
+                   subNodes == n.subNodes;
+        }
+        CommandArgument argument;
+        QList<CommandOption> options;
+        QList<Node> subNodes;
+    };
 
-  Node m_parseTree;
-  QList<CommandOption> m_foundOptions;
-  QList<CommandArgument> m_foundArgs;
+    Node m_parseTree;
+    QList<CommandOption> m_foundOptions;
+    QList<CommandArgument> m_foundArgs;
 
-  // helper functions
-  void printVersion();
-  void printHelp(QStringList args, const Node* node);
-  Node* findParent(const CommandArgument& parent);
-  Node* recursiveParentSearch(const CommandArgument& parent, Node& node) const;
-  bool processIfOptionIsHelp(const QStringList& args,
-                             QStringList::const_iterator& actualIt,
-                             Node*& actualNode);
-  bool processArgs(const QStringList& args,
-                   QStringList::const_iterator& actualIt,
-                   Node*& actualNode);
-  bool processOptions(const QStringList& args,
-                      QStringList::const_iterator& actualIt,
-                      Node* const actualNode);
+    // helper functions
+    void printVersion();
+    void printHelp(QStringList args, const Node* node);
+    Node* findParent(const CommandArgument& parent);
+    Node* recursiveParentSearch(const CommandArgument& parent,
+                                Node& node) const;
+    bool processIfOptionIsHelp(const QStringList& args,
+                               QStringList::const_iterator& actualIt,
+                               Node*& actualNode);
+    bool processArgs(const QStringList& args,
+                     QStringList::const_iterator& actualIt,
+                     Node*& actualNode);
+    bool processOptions(const QStringList& args,
+                        QStringList::const_iterator& actualIt,
+                        Node* const actualNode);
 };
diff --git a/src/cli/commandoption.cpp b/src/cli/commandoption.cpp
index ba7d9339..6c076612 100644
--- a/src/cli/commandoption.cpp
+++ b/src/cli/commandoption.cpp
@@ -26,7 +26,7 @@ CommandOption::CommandOption(const QString& name,
   , m_valueName(valueName)
   , m_value(defaultValue)
 {
-  m_checker = [](QString const&) { return true; };
+    m_checker = [](QString const&) { return true; };
 }
 
 CommandOption::CommandOption(const QStringList& names,
@@ -38,103 +38,89 @@ CommandOption::CommandOption(const QStringList& names,
   , m_valueName(valueName)
   , m_value(defaultValue)
 {
-  m_checker = [](QString const&) -> bool { return true; };
+    m_checker = [](QString const&) -> bool { return true; };
 }
 
-void
-CommandOption::setName(const QString& name)
+void CommandOption::setName(const QString& name)
 {
-  m_names = QStringList() << name;
+    m_names = QStringList() << name;
 }
 
-void
-CommandOption::setNames(const QStringList& names)
+void CommandOption::setNames(const QStringList& names)
 {
-  m_names = names;
+    m_names = names;
 }
 
-QStringList
-CommandOption::names() const
+QStringList CommandOption::names() const
 {
-  return m_names;
+    return m_names;
 }
 
-QStringList
-CommandOption::dashedNames() const
+QStringList CommandOption::dashedNames() const
 {
-  QStringList dashedNames;
-  for (const QString& name : m_names) {
-    // prepend "-" to single character options, and "--" to the others
-    QString dashedName = (name.length() == 1)
-                           ? QStringLiteral("-%1").arg(name)
-                           : QStringLiteral("--%1").arg(name);
-    dashedNames << dashedName;
-  }
-  return dashedNames;
+    QStringList dashedNames;
+    for (const QString& name : m_names) {
+        // prepend "-" to single character options, and "--" to the others
+        QString dashedName = (name.length() == 1)
+                               ? QStringLiteral("-%1").arg(name)
+                               : QStringLiteral("--%1").arg(name);
+        dashedNames << dashedName;
+    }
+    return dashedNames;
 }
 
-void
-CommandOption::setValueName(const QString& name)
+void CommandOption::setValueName(const QString& name)
 {
-  m_valueName = name;
+    m_valueName = name;
 }
 
-QString
-CommandOption::valueName() const
+QString CommandOption::valueName() const
 {
-  return m_valueName;
+    return m_valueName;
 }
 
-void
-CommandOption::setValue(const QString& value)
+void CommandOption::setValue(const QString& value)
 {
-  if (m_valueName.isEmpty()) {
-    m_valueName = QLatin1String("value");
-  }
-  m_value = value;
+    if (m_valueName.isEmpty()) {
+        m_valueName = QLatin1String("value");
+    }
+    m_value = value;
 }
 
-QString
-CommandOption::value() const
+QString CommandOption::value() const
 {
-  return m_value;
+    return m_value;
 }
 
-void
-CommandOption::addChecker(const function<bool(const QString&)> checker,
-                          const QString& errMsg)
+void CommandOption::addChecker(const function<bool(const QString&)> checker,
+                               const QString& errMsg)
 {
-  m_checker = checker;
-  m_errorMsg = errMsg;
+    m_checker = checker;
+    m_errorMsg = errMsg;
 }
 
-bool
-CommandOption::checkValue(const QString& value) const
+bool CommandOption::checkValue(const QString& value) const
 {
-  return m_checker(value);
+    return m_checker(value);
 }
 
-QString
-CommandOption::description() const
+QString CommandOption::description() const
 {
-  return m_description;
+    return m_description;
 }
 
-void
-CommandOption::setDescription(const QString& description)
+void CommandOption::setDescription(const QString& description)
 {
-  m_description = description;
+    m_description = description;
 }
 
-QString
-CommandOption::errorMsg() const
+QString CommandOption::errorMsg() const
 {
-  return m_errorMsg;
+    return m_errorMsg;
 }
 
-bool
-CommandOption::operator==(const CommandOption& option) const
+bool CommandOption::operator==(const CommandOption& option) const
 {
-  return m_description == option.m_description && m_names == option.m_names &&
-         m_valueName == option.m_valueName;
+    return m_description == option.m_description && m_names == option.m_names &&
+           m_valueName == option.m_valueName;
 }
diff --git a/src/cli/commandoption.h b/src/cli/commandoption.h
index efcc388a..25fd8b82 100644
--- a/src/cli/commandoption.h
+++ b/src/cli/commandoption.h
@@ -25,44 +25,44 @@ using std::function;
 class CommandOption
 {
 public:
-  CommandOption(const QString& name,
-                const QString& description,
-                const QString& valueName = QString(),
-                const QString& defaultValue = QString());
+    CommandOption(const QString& name,
+                  const QString& description,
+                  const QString& valueName = QString(),
+                  const QString& defaultValue = QString());
 
-  CommandOption(const QStringList& names,
-                const QString& description,
-                const QString& valueName = QString(),
-                const QString& defaultValue = QString());
+    CommandOption(const QStringList& names,
+                  const QString& description,
+                  const QString& valueName = QString(),
+                  const QString& defaultValue = QString());
 
-  void setName(const QString& name);
-  void setNames(const QStringList& names);
-  QStringList names() const;
-  QStringList dashedNames() const;
+    void setName(const QString& name);
+    void setNames(const QStringList& names);
+    QStringList names() const;
+    QStringList dashedNames() const;
 
-  void setValueName(const QString& name);
-  QString valueName() const;
+    void setValueName(const QString& name);
+    QString valueName() const;
 
-  void setValue(const QString& value);
-  QString value() const;
+    void setValue(const QString& value);
+    QString value() const;
 
-  void addChecker(const function<bool(QString const&)> checker,
-                  const QString& errMsg);
-  bool checkValue(const QString& value) const;
+    void addChecker(const function<bool(QString const&)> checker,
+                    const QString& errMsg);
+    bool checkValue(const QString& value) const;
 
-  QString description() const;
-  void setDescription(const QString& description);
+    QString description() const;
+    void setDescription(const QString& description);
 
-  QString errorMsg() const;
+    QString errorMsg() const;
 
-  bool operator==(const CommandOption& option) const;
+    bool operator==(const CommandOption& option) const;
 
 private:
-  QStringList m_names;
-  QString m_description;
-  QString m_valueName;
-  QString m_value;
+    QStringList m_names;
+    QString m_description;
+    QString m_valueName;
+    QString m_value;
 
-  function<bool(QString const&)> m_checker;
-  QString m_errorMsg;
+    function<bool(QString const&)> m_checker;
+    QString m_errorMsg;
 };
diff --git a/src/config/buttonlistview.cpp b/src/config/buttonlistview.cpp
index bb134d37..6db9192b 100644
--- a/src/config/buttonlistview.cpp
+++ b/src/config/buttonlistview.cpp
@@ -24,94 +24,90 @@
 ButtonListView::ButtonListView(QWidget* parent)
   : QListWidget(parent)
 {
-  setMouseTracking(true);
-  setFlow(QListWidget::TopToBottom);
-  initButtonList();
-  updateComponents();
-  connect(
-    this, &QListWidget::itemClicked, this, &ButtonListView::reverseItemCheck);
+    setMouseTracking(true);
+    setFlow(QListWidget::TopToBottom);
+    initButtonList();
+    updateComponents();
+    connect(
+      this, &QListWidget::itemClicked, this, &ButtonListView::reverseItemCheck);
 }
 
-void
-ButtonListView::initButtonList()
+void ButtonListView::initButtonList()
 {
-  ToolFactory factory;
-  auto listTypes = CaptureToolButton::getIterableButtonTypes();
+    ToolFactory factory;
+    auto listTypes = CaptureToolButton::getIterableButtonTypes();
 
-  for (const CaptureToolButton::ButtonType t : listTypes) {
-    CaptureTool* tool = factory.CreateTool(t);
+    for (const CaptureToolButton::ButtonType t : listTypes) {
+        CaptureTool* tool = factory.CreateTool(t);
 
-    // add element to the local map
-    m_buttonTypeByName.insert(tool->name(), t);
+        // add element to the local map
+        m_buttonTypeByName.insert(tool->name(), t);
 
-    // init the menu option
-    QListWidgetItem* m_buttonItem = new QListWidgetItem(this);
+        // init the menu option
+        QListWidgetItem* m_buttonItem = new QListWidgetItem(this);
 
-    // when the background is lighter than gray, it uses the white icons
-    QColor bgColor = this->palette().color(QWidget::backgroundRole());
-    m_buttonItem->setIcon(tool->icon(bgColor, false));
+        // when the background is lighter than gray, it uses the white icons
+        QColor bgColor = this->palette().color(QWidget::backgroundRole());
+        m_buttonItem->setIcon(tool->icon(bgColor, false));
 
-    m_buttonItem->setFlags(Qt::ItemIsUserCheckable);
-    QColor foregroundColor = this->palette().color(QWidget::foregroundRole());
-    m_buttonItem->setForeground(foregroundColor);
+        m_buttonItem->setFlags(Qt::ItemIsUserCheckable);
+        QColor foregroundColor =
+          this->palette().color(QWidget::foregroundRole());
+        m_buttonItem->setForeground(foregroundColor);
 
-    m_buttonItem->setText(tool->name());
-    m_buttonItem->setToolTip(tool->description());
-    tool->deleteLater();
-  }
+        m_buttonItem->setText(tool->name());
+        m_buttonItem->setToolTip(tool->description());
+        tool->deleteLater();
+    }
 }
 
-void
-ButtonListView::updateActiveButtons(QListWidgetItem* item)
+void ButtonListView::updateActiveButtons(QListWidgetItem* item)
 {
-  CaptureToolButton::ButtonType bType = m_buttonTypeByName[item->text()];
-  if (item->checkState() == Qt::Checked) {
-    m_listButtons.append(bType);
-    // TODO refactor so we don't need external sorts
-    using bt = CaptureToolButton::ButtonType;
-    std::sort(m_listButtons.begin(), m_listButtons.end(), [](bt a, bt b) {
-      return CaptureToolButton::getPriorityByButton(a) <
-             CaptureToolButton::getPriorityByButton(b);
-    });
-  } else {
-    m_listButtons.remove(m_listButtons.indexOf(bType));
-  }
-  ConfigHandler().setButtons(m_listButtons);
+    CaptureToolButton::ButtonType bType = m_buttonTypeByName[item->text()];
+    if (item->checkState() == Qt::Checked) {
+        m_listButtons.append(bType);
+        // TODO refactor so we don't need external sorts
+        using bt = CaptureToolButton::ButtonType;
+        std::sort(m_listButtons.begin(), m_listButtons.end(), [](bt a, bt b) {
+            return CaptureToolButton::getPriorityByButton(a) <
+                   CaptureToolButton::getPriorityByButton(b);
+        });
+    } else {
+        m_listButtons.remove(m_listButtons.indexOf(bType));
+    }
+    ConfigHandler().setButtons(m_listButtons);
 }
 
-void
-ButtonListView::reverseItemCheck(QListWidgetItem* item)
+void ButtonListView::reverseItemCheck(QListWidgetItem* item)
 {
-  if (item->checkState() == Qt::Checked) {
-    item->setCheckState(Qt::Unchecked);
-  } else {
-    item->setCheckState(Qt::Checked);
-  }
-  updateActiveButtons(item);
+    if (item->checkState() == Qt::Checked) {
+        item->setCheckState(Qt::Unchecked);
+    } else {
+        item->setCheckState(Qt::Checked);
+    }
+    updateActiveButtons(item);
 }
 
-void
-ButtonListView::selectAll()
+void ButtonListView::selectAll()
 {
-  ConfigHandler().setAllTheButtons();
-  for (int i = 0; i < this->count(); ++i) {
-    QListWidgetItem* item = this->item(i);
-    item->setCheckState(Qt::Checked);
-  }
+    ConfigHandler().setAllTheButtons();
+    for (int i = 0; i < this->count(); ++i) {
+        QListWidgetItem* item = this->item(i);
+        item->setCheckState(Qt::Checked);
+    }
 }
 
-void
-ButtonListView::updateComponents()
+void ButtonListView::updateComponents()
 {
-  m_listButtons = ConfigHandler().getButtons();
-  auto listTypes = CaptureToolButton::getIterableButtonTypes();
-  for (int i = 0; i < this->count(); ++i) {
-    QListWidgetItem* item = this->item(i);
-    auto elem = static_cast<CaptureToolButton::ButtonType>(listTypes.at(i));
-    if (m_listButtons.contains(elem)) {
-      item->setCheckState(Qt::Checked);
-    } else {
-      item->setCheckState(Qt::Unchecked);
+    m_listButtons = ConfigHandler().getButtons();
+    auto listTypes = CaptureToolButton::getIterableButtonTypes();
+    for (int i = 0; i < this->count(); ++i) {
+        QListWidgetItem* item = this->item(i);
+        auto elem = static_cast<CaptureToolButton::ButtonType>(listTypes.at(i));
+        if (m_listButtons.contains(elem)) {
+            item->setCheckState(Qt::Checked);
+        } else {
+            item->setCheckState(Qt::Unchecked);
+        }
     }
-  }
 }
diff --git a/src/config/buttonlistview.h b/src/config/buttonlistview.h
index 779957fc..55bacb7b 100644
--- a/src/config/buttonlistview.h
+++ b/src/config/buttonlistview.h
@@ -23,21 +23,21 @@
 class ButtonListView : public QListWidget
 {
 public:
-  explicit ButtonListView(QWidget* parent = nullptr);
+    explicit ButtonListView(QWidget* parent = nullptr);
 
 public slots:
-  void selectAll();
-  void updateComponents();
+    void selectAll();
+    void updateComponents();
 
 private slots:
-  void reverseItemCheck(QListWidgetItem*);
+    void reverseItemCheck(QListWidgetItem*);
 
 protected:
-  void initButtonList();
+    void initButtonList();
 
 private:
-  QVector<CaptureToolButton::ButtonType> m_listButtons;
-  QMap<QString, CaptureToolButton::ButtonType> m_buttonTypeByName;
+    QVector<CaptureToolButton::ButtonType> m_listButtons;
+    QMap<QString, CaptureToolButton::ButtonType> m_buttonTypeByName;
 
-  void updateActiveButtons(QListWidgetItem*);
+    void updateActiveButtons(QListWidgetItem*);
 };
diff --git a/src/config/clickablelabel.cpp b/src/config/clickablelabel.cpp
index 5702a702..85f9d6ae 100644
--- a/src/config/clickablelabel.cpp
+++ b/src/config/clickablelabel.cpp
@@ -24,11 +24,10 @@ ClickableLabel::ClickableLabel(QWidget* parent)
 ClickableLabel::ClickableLabel(QString s, QWidget* parent)
   : QLabel(parent)
 {
-  setText(s);
+    setText(s);
 }
 
-void
-ClickableLabel::mousePressEvent(QMouseEvent*)
+void ClickableLabel::mousePressEvent(QMouseEvent*)
 {
-  emit clicked();
+    emit clicked();
 }
diff --git a/src/config/clickablelabel.h b/src/config/clickablelabel.h
index 5042e0f3..d5dcbe53 100644
--- a/src/config/clickablelabel.h
+++ b/src/config/clickablelabel.h
@@ -21,14 +21,14 @@
 
 class ClickableLabel : public QLabel
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ClickableLabel(QWidget* parent = nullptr);
-  ClickableLabel(QString s, QWidget* parent = nullptr);
+    explicit ClickableLabel(QWidget* parent = nullptr);
+    ClickableLabel(QString s, QWidget* parent = nullptr);
 
 signals:
-  void clicked();
+    void clicked();
 
 private:
-  void mousePressEvent(QMouseEvent*);
+    void mousePressEvent(QMouseEvent*);
 };
diff --git a/src/config/configwindow.cpp b/src/config/configwindow.cpp
index e6591f36..737c6573 100644
--- a/src/config/configwindow.cpp
+++ b/src/config/configwindow.cpp
@@ -36,61 +36,61 @@
 ConfigWindow::ConfigWindow(QWidget* parent)
   : QTabWidget(parent)
 {
-  setAttribute(Qt::WA_DeleteOnClose);
-  const int size = GlobalValues::buttonBaseSize() * 12;
-  setMinimumSize(size, size);
-  setWindowIcon(QIcon(":img/app/flameshot.svg"));
-  setWindowTitle(tr("Configuration"));
+    setAttribute(Qt::WA_DeleteOnClose);
+    const int size = GlobalValues::buttonBaseSize() * 12;
+    setMinimumSize(size, size);
+    setWindowIcon(QIcon(":img/app/flameshot.svg"));
+    setWindowTitle(tr("Configuration"));
 
-  auto changedSlot = [this](QString s) {
-    QStringList files = m_configWatcher->files();
-    if (!files.contains(s)) {
-      this->m_configWatcher->addPath(s);
-    }
-    emit updateChildren();
-  };
-  m_configWatcher = new QFileSystemWatcher(this);
-  m_configWatcher->addPath(ConfigHandler().configFilePath());
-  connect(m_configWatcher, &QFileSystemWatcher::fileChanged, this, changedSlot);
+    auto changedSlot = [this](QString s) {
+        QStringList files = m_configWatcher->files();
+        if (!files.contains(s)) {
+            this->m_configWatcher->addPath(s);
+        }
+        emit updateChildren();
+    };
+    m_configWatcher = new QFileSystemWatcher(this);
+    m_configWatcher->addPath(ConfigHandler().configFilePath());
+    connect(
+      m_configWatcher, &QFileSystemWatcher::fileChanged, this, changedSlot);
 
-  QColor background = this->palette().window().color();
-  bool isDark = ColorUtils::colorIsDark(background);
-  QString modifier =
-    isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();
+    QColor background = this->palette().window().color();
+    bool isDark = ColorUtils::colorIsDark(background);
+    QString modifier =
+      isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();
 
-  // visuals
-  m_visuals = new VisualsEditor();
-  addTab(m_visuals, QIcon(modifier + "graphics.svg"), tr("Interface"));
+    // visuals
+    m_visuals = new VisualsEditor();
+    addTab(m_visuals, QIcon(modifier + "graphics.svg"), tr("Interface"));
 
-  // filename
-  m_filenameEditor = new FileNameEditor();
-  addTab(m_filenameEditor,
-         QIcon(modifier + "name_edition.svg"),
-         tr("Filename Editor"));
+    // filename
+    m_filenameEditor = new FileNameEditor();
+    addTab(m_filenameEditor,
+           QIcon(modifier + "name_edition.svg"),
+           tr("Filename Editor"));
 
-  // general
-  m_generalConfig = new GeneneralConf();
-  addTab(m_generalConfig, QIcon(modifier + "config.svg"), tr("General"));
+    // general
+    m_generalConfig = new GeneneralConf();
+    addTab(m_generalConfig, QIcon(modifier + "config.svg"), tr("General"));
 
-  // connect update sigslots
-  connect(this,
-          &ConfigWindow::updateChildren,
-          m_filenameEditor,
-          &FileNameEditor::updateComponents);
-  connect(this,
-          &ConfigWindow::updateChildren,
-          m_visuals,
-          &VisualsEditor::updateComponents);
-  connect(this,
-          &ConfigWindow::updateChildren,
-          m_generalConfig,
-          &GeneneralConf::updateComponents);
+    // connect update sigslots
+    connect(this,
+            &ConfigWindow::updateChildren,
+            m_filenameEditor,
+            &FileNameEditor::updateComponents);
+    connect(this,
+            &ConfigWindow::updateChildren,
+            m_visuals,
+            &VisualsEditor::updateComponents);
+    connect(this,
+            &ConfigWindow::updateChildren,
+            m_generalConfig,
+            &GeneneralConf::updateComponents);
 }
 
-void
-ConfigWindow::keyPressEvent(QKeyEvent* e)
+void ConfigWindow::keyPressEvent(QKeyEvent* e)
 {
-  if (e->key() == Qt::Key_Escape) {
-    close();
-  }
+    if (e->key() == Qt::Key_Escape) {
+        close();
+    }
 }
diff --git a/src/config/configwindow.h b/src/config/configwindow.h
index 979e1a72..6d305d98 100644
--- a/src/config/configwindow.h
+++ b/src/config/configwindow.h
@@ -26,19 +26,19 @@ class VisualsEditor;
 
 class ConfigWindow : public QTabWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ConfigWindow(QWidget* parent = nullptr);
+    explicit ConfigWindow(QWidget* parent = nullptr);
 
 signals:
-  void updateChildren();
+    void updateChildren();
 
 protected:
-  void keyPressEvent(QKeyEvent*);
+    void keyPressEvent(QKeyEvent*);
 
 private:
-  FileNameEditor* m_filenameEditor;
-  GeneneralConf* m_generalConfig;
-  VisualsEditor* m_visuals;
-  QFileSystemWatcher* m_configWatcher;
+    FileNameEditor* m_filenameEditor;
+    GeneneralConf* m_generalConfig;
+    VisualsEditor* m_visuals;
+    QFileSystemWatcher* m_configWatcher;
 };
diff --git a/src/config/extendedslider.cpp b/src/config/extendedslider.cpp
index 124d1bf3..6d937c5c 100644
--- a/src/config/extendedslider.cpp
+++ b/src/config/extendedslider.cpp
@@ -20,38 +20,37 @@
 ExtendedSlider::ExtendedSlider(QWidget* parent)
   : QSlider(parent)
 {
-  connect(
-    this, &ExtendedSlider::valueChanged, this, &ExtendedSlider::updateTooltip);
-  connect(this, &ExtendedSlider::sliderMoved, this, &ExtendedSlider::fireTimer);
-  m_timer.setSingleShot(true);
-  connect(
-    &m_timer, &QTimer::timeout, this, &ExtendedSlider::modificationsEnded);
+    connect(this,
+            &ExtendedSlider::valueChanged,
+            this,
+            &ExtendedSlider::updateTooltip);
+    connect(
+      this, &ExtendedSlider::sliderMoved, this, &ExtendedSlider::fireTimer);
+    m_timer.setSingleShot(true);
+    connect(
+      &m_timer, &QTimer::timeout, this, &ExtendedSlider::modificationsEnded);
 }
 
-int
-ExtendedSlider::mappedValue(int min, int max)
+int ExtendedSlider::mappedValue(int min, int max)
 {
-  qreal progress =
-    ((value() - minimum())) / static_cast<qreal>(maximum() - minimum());
-  return min + (max - min) * progress;
+    qreal progress =
+      ((value() - minimum())) / static_cast<qreal>(maximum() - minimum());
+    return min + (max - min) * progress;
 }
 
-void
-ExtendedSlider::setMapedValue(int min, int val, int max)
+void ExtendedSlider::setMapedValue(int min, int val, int max)
 {
-  qreal progress = ((val - min) + 1) / static_cast<qreal>(max - min);
-  int value = minimum() + (maximum() - minimum()) * progress;
-  setValue(value);
+    qreal progress = ((val - min) + 1) / static_cast<qreal>(max - min);
+    int value = minimum() + (maximum() - minimum()) * progress;
+    setValue(value);
 }
 
-void
-ExtendedSlider::updateTooltip()
+void ExtendedSlider::updateTooltip()
 {
-  setToolTip(QString::number(value()) + "%");
+    setToolTip(QString::number(value()) + "%");
 }
 
-void
-ExtendedSlider::fireTimer()
+void ExtendedSlider::fireTimer()
 {
-  m_timer.start(500);
+    m_timer.start(500);
 }
diff --git a/src/config/extendedslider.h b/src/config/extendedslider.h
index 7ef22f13..ea4a7608 100644
--- a/src/config/extendedslider.h
+++ b/src/config/extendedslider.h
@@ -22,20 +22,20 @@
 
 class ExtendedSlider : public QSlider
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ExtendedSlider(QWidget* parent = nullptr);
+    explicit ExtendedSlider(QWidget* parent = nullptr);
 
-  int mappedValue(int min, int max);
-  void setMapedValue(int min, int val, int max);
+    int mappedValue(int min, int max);
+    void setMapedValue(int min, int val, int max);
 
 signals:
-  void modificationsEnded();
+    void modificationsEnded();
 
 private slots:
-  void updateTooltip();
-  void fireTimer();
+    void updateTooltip();
+    void fireTimer();
 
 private:
-  QTimer m_timer;
+    QTimer m_timer;
 };
diff --git a/src/config/filenameeditor.cpp b/src/config/filenameeditor.cpp
index d3bae1a6..a8631a73 100644
--- a/src/config/filenameeditor.cpp
+++ b/src/config/filenameeditor.cpp
@@ -28,110 +28,104 @@
 FileNameEditor::FileNameEditor(QWidget* parent)
   : QWidget(parent)
 {
-  initWidgets();
-  initLayout();
+    initWidgets();
+    initLayout();
 }
 
-void
-FileNameEditor::initLayout()
+void FileNameEditor::initLayout()
 {
-  m_layout = new QVBoxLayout(this);
-  auto infoLabel = new QLabel(tr("Edit the name of your captures:"), this);
-  infoLabel->setFixedHeight(20);
-  m_layout->addWidget(infoLabel);
-  m_layout->addWidget(m_helperButtons);
-  m_layout->addWidget(new QLabel(tr("Edit:")));
-  m_layout->addWidget(m_nameEditor);
-  m_layout->addWidget(new QLabel(tr("Preview:")));
-  m_layout->addWidget(m_outputLabel);
+    m_layout = new QVBoxLayout(this);
+    auto infoLabel = new QLabel(tr("Edit the name of your captures:"), this);
+    infoLabel->setFixedHeight(20);
+    m_layout->addWidget(infoLabel);
+    m_layout->addWidget(m_helperButtons);
+    m_layout->addWidget(new QLabel(tr("Edit:")));
+    m_layout->addWidget(m_nameEditor);
+    m_layout->addWidget(new QLabel(tr("Preview:")));
+    m_layout->addWidget(m_outputLabel);
 
-  QHBoxLayout* horizLayout = new QHBoxLayout();
-  horizLayout->addWidget(m_saveButton);
-  horizLayout->addWidget(m_resetButton);
-  horizLayout->addWidget(m_clearButton);
-  m_layout->addLayout(horizLayout);
+    QHBoxLayout* horizLayout = new QHBoxLayout();
+    horizLayout->addWidget(m_saveButton);
+    horizLayout->addWidget(m_resetButton);
+    horizLayout->addWidget(m_clearButton);
+    m_layout->addLayout(horizLayout);
 }
 
-void
-FileNameEditor::initWidgets()
+void FileNameEditor::initWidgets()
 {
-  m_nameHandler = new FileNameHandler(this);
+    m_nameHandler = new FileNameHandler(this);
 
-  // editor
-  m_nameEditor = new QLineEdit(this);
-  m_nameEditor->setMaxLength(FileNameHandler::MAX_CHARACTERS);
+    // editor
+    m_nameEditor = new QLineEdit(this);
+    m_nameEditor->setMaxLength(FileNameHandler::MAX_CHARACTERS);
 
-  // preview
-  m_outputLabel = new QLineEdit(this);
-  m_outputLabel->setDisabled(true);
-  QString foreground = this->palette().windowText().color().name();
-  m_outputLabel->setStyleSheet(QStringLiteral("color: %1").arg(foreground));
-  QPalette pal = m_outputLabel->palette();
-  QColor color = pal.color(QPalette::Disabled, m_outputLabel->backgroundRole());
-  pal.setColor(QPalette::Active, m_outputLabel->backgroundRole(), color);
-  m_outputLabel->setPalette(pal);
+    // preview
+    m_outputLabel = new QLineEdit(this);
+    m_outputLabel->setDisabled(true);
+    QString foreground = this->palette().windowText().color().name();
+    m_outputLabel->setStyleSheet(QStringLiteral("color: %1").arg(foreground));
+    QPalette pal = m_outputLabel->palette();
+    QColor color =
+      pal.color(QPalette::Disabled, m_outputLabel->backgroundRole());
+    pal.setColor(QPalette::Active, m_outputLabel->backgroundRole(), color);
+    m_outputLabel->setPalette(pal);
 
-  connect(m_nameEditor,
-          &QLineEdit::textChanged,
-          this,
-          &FileNameEditor::showParsedPattern);
-  updateComponents();
+    connect(m_nameEditor,
+            &QLineEdit::textChanged,
+            this,
+            &FileNameEditor::showParsedPattern);
+    updateComponents();
 
-  // helper buttons
-  m_helperButtons = new StrftimeChooserWidget(this);
-  connect(m_helperButtons,
-          &StrftimeChooserWidget::variableEmitted,
-          this,
-          &FileNameEditor::addToNameEditor);
+    // helper buttons
+    m_helperButtons = new StrftimeChooserWidget(this);
+    connect(m_helperButtons,
+            &StrftimeChooserWidget::variableEmitted,
+            this,
+            &FileNameEditor::addToNameEditor);
 
-  // save
-  m_saveButton = new QPushButton(tr("Save"), this);
-  connect(
-    m_saveButton, &QPushButton::clicked, this, &FileNameEditor::savePattern);
-  m_saveButton->setToolTip(tr("Saves the pattern"));
-  // reset
-  m_resetButton = new QPushButton(tr("Reset"), this);
-  connect(
-    m_resetButton, &QPushButton::clicked, this, &FileNameEditor::resetName);
-  m_resetButton->setToolTip(tr("Restores the saved pattern"));
-  // clear
-  m_clearButton = new QPushButton(tr("Clear"), this);
-  connect(m_clearButton, &QPushButton::clicked, this, [this]() {
-    m_nameEditor->setText(QString());
-  });
-  m_clearButton->setToolTip(tr("Deletes the name"));
+    // save
+    m_saveButton = new QPushButton(tr("Save"), this);
+    connect(
+      m_saveButton, &QPushButton::clicked, this, &FileNameEditor::savePattern);
+    m_saveButton->setToolTip(tr("Saves the pattern"));
+    // reset
+    m_resetButton = new QPushButton(tr("Reset"), this);
+    connect(
+      m_resetButton, &QPushButton::clicked, this, &FileNameEditor::resetName);
+    m_resetButton->setToolTip(tr("Restores the saved pattern"));
+    // clear
+    m_clearButton = new QPushButton(tr("Clear"), this);
+    connect(m_clearButton, &QPushButton::clicked, this, [this]() {
+        m_nameEditor->setText(QString());
+    });
+    m_clearButton->setToolTip(tr("Deletes the name"));
 }
 
-void
-FileNameEditor::savePattern()
+void FileNameEditor::savePattern()
 {
-  QString pattern = m_nameEditor->text();
-  m_nameHandler->setPattern(pattern);
+    QString pattern = m_nameEditor->text();
+    m_nameHandler->setPattern(pattern);
 }
 
-void
-FileNameEditor::showParsedPattern(const QString& p)
+void FileNameEditor::showParsedPattern(const QString& p)
 {
-  QString output = m_nameHandler->parseFilename(p);
-  m_outputLabel->setText(output);
+    QString output = m_nameHandler->parseFilename(p);
+    m_outputLabel->setText(output);
 }
 
-void
-FileNameEditor::resetName()
+void FileNameEditor::resetName()
 {
-  m_nameEditor->setText(ConfigHandler().filenamePatternValue());
+    m_nameEditor->setText(ConfigHandler().filenamePatternValue());
 }
 
-void
-FileNameEditor::addToNameEditor(QString s)
+void FileNameEditor::addToNameEditor(QString s)
 {
-  m_nameEditor->setText(m_nameEditor->text() + s);
-  m_nameEditor->setFocus();
+    m_nameEditor->setText(m_nameEditor->text() + s);
+    m_nameEditor->setFocus();
 }
 
-void
-FileNameEditor::updateComponents()
+void FileNameEditor::updateComponents()
 {
-  m_nameEditor->setText(ConfigHandler().filenamePatternValue());
-  m_outputLabel->setText(m_nameHandler->parsedPattern());
+    m_nameEditor->setText(ConfigHandler().filenamePatternValue());
+    m_outputLabel->setText(m_nameHandler->parsedPattern());
 }
diff --git a/src/config/filenameeditor.h b/src/config/filenameeditor.h
index 6d77ef55..bcaf42fe 100644
--- a/src/config/filenameeditor.h
+++ b/src/config/filenameeditor.h
@@ -28,29 +28,29 @@ class StrftimeChooserWidget;
 
 class FileNameEditor : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit FileNameEditor(QWidget* parent = nullptr);
+    explicit FileNameEditor(QWidget* parent = nullptr);
 
 private:
-  QVBoxLayout* m_layout;
-  QLineEdit* m_outputLabel;
-  QLineEdit* m_nameEditor;
-  FileNameHandler* m_nameHandler;
-  StrftimeChooserWidget* m_helperButtons;
-  QPushButton* m_saveButton;
-  QPushButton* m_resetButton;
-  QPushButton* m_clearButton;
-
-  void initLayout();
-  void initWidgets();
+    QVBoxLayout* m_layout;
+    QLineEdit* m_outputLabel;
+    QLineEdit* m_nameEditor;
+    FileNameHandler* m_nameHandler;
+    StrftimeChooserWidget* m_helperButtons;
+    QPushButton* m_saveButton;
+    QPushButton* m_resetButton;
+    QPushButton* m_clearButton;
+
+    void initLayout();
+    void initWidgets();
 
 public slots:
-  void addToNameEditor(QString s);
-  void updateComponents();
+    void addToNameEditor(QString s);
+    void updateComponents();
 
 private slots:
-  void savePattern();
-  void showParsedPattern(const QString&);
-  void resetName();
+    void savePattern();
+    void showParsedPattern(const QString&);
+    void resetName();
 };
diff --git a/src/config/geneneralconf.cpp b/src/config/geneneralconf.cpp
index d25b17ee..03b7064d 100644
--- a/src/config/geneneralconf.cpp
+++ b/src/config/geneneralconf.cpp
@@ -33,343 +33,326 @@
 GeneneralConf::GeneneralConf(QWidget* parent)
   : QWidget(parent)
 {
-  m_layout = new QVBoxLayout(this);
-  m_layout->setAlignment(Qt::AlignTop);
-  initShowHelp();
-  initShowSidePanelButton();
-  initShowDesktopNotification();
-  initShowTrayIcon();
-  initAutostart();
-  initCloseAfterCapture();
-  initCopyAndCloseAfterUpload();
-  initSaveAfterCopy();
-
-  // this has to be at the end
-  initConfingButtons();
-  updateComponents();
+    m_layout = new QVBoxLayout(this);
+    m_layout->setAlignment(Qt::AlignTop);
+    initShowHelp();
+    initShowSidePanelButton();
+    initShowDesktopNotification();
+    initShowTrayIcon();
+    initAutostart();
+    initCloseAfterCapture();
+    initCopyAndCloseAfterUpload();
+    initSaveAfterCopy();
+
+    // this has to be at the end
+    initConfingButtons();
+    updateComponents();
 }
 
-void
-GeneneralConf::updateComponents()
+void GeneneralConf::updateComponents()
 {
-  ConfigHandler config;
-  m_helpMessage->setChecked(config.showHelpValue());
-  m_sidePanelButton->setChecked(config.showSidePanelButtonValue());
-  m_sysNotifications->setChecked(config.desktopNotificationValue());
-  m_autostart->setChecked(config.startupLaunchValue());
-  m_closeAfterCapture->setChecked(config.closeAfterScreenshotValue());
-  m_copyAndCloseAfterUpload->setChecked(
-    config.copyAndCloseAfterUploadEnabled());
-  m_saveAfterCopy->setChecked(config.saveAfterCopyValue());
-
-  if (!config.saveAfterCopyPathValue().isEmpty()) {
-    m_savePath->setText(config.saveAfterCopyPathValue());
-  } else {
-    ConfigHandler().setSaveAfterCopyPath(
-      QStandardPaths::writableLocation(QStandardPaths::PicturesLocation));
-  }
+    ConfigHandler config;
+    m_helpMessage->setChecked(config.showHelpValue());
+    m_sidePanelButton->setChecked(config.showSidePanelButtonValue());
+    m_sysNotifications->setChecked(config.desktopNotificationValue());
+    m_autostart->setChecked(config.startupLaunchValue());
+    m_closeAfterCapture->setChecked(config.closeAfterScreenshotValue());
+    m_copyAndCloseAfterUpload->setChecked(
+      config.copyAndCloseAfterUploadEnabled());
+    m_saveAfterCopy->setChecked(config.saveAfterCopyValue());
+
+    if (!config.saveAfterCopyPathValue().isEmpty()) {
+        m_savePath->setText(config.saveAfterCopyPathValue());
+    } else {
+        ConfigHandler().setSaveAfterCopyPath(
+          QStandardPaths::writableLocation(QStandardPaths::PicturesLocation));
+    }
 
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  m_showTray->setChecked(!config.disabledTrayIconValue());
+    m_showTray->setChecked(!config.disabledTrayIconValue());
 #endif
 }
 
-void
-GeneneralConf::showHelpChanged(bool checked)
+void GeneneralConf::showHelpChanged(bool checked)
 {
-  ConfigHandler().setShowHelp(checked);
+    ConfigHandler().setShowHelp(checked);
 }
 
-void
-GeneneralConf::showSidePanelButtonChanged(bool checked)
+void GeneneralConf::showSidePanelButtonChanged(bool checked)
 {
-  ConfigHandler().setShowSidePanelButton(checked);
+    ConfigHandler().setShowSidePanelButton(checked);
 }
 
-void
-GeneneralConf::showDesktopNotificationChanged(bool checked)
+void GeneneralConf::showDesktopNotificationChanged(bool checked)
 {
-  ConfigHandler().setDesktopNotification(checked);
+    ConfigHandler().setDesktopNotification(checked);
 }
 
-void
-GeneneralConf::showTrayIconChanged(bool checked)
+void GeneneralConf::showTrayIconChanged(bool checked)
 {
-  auto controller = Controller::getInstance();
-  if (checked) {
-    controller->enableTrayIcon();
-  } else {
-    controller->disableTrayIcon();
-  }
+    auto controller = Controller::getInstance();
+    if (checked) {
+        controller->enableTrayIcon();
+    } else {
+        controller->disableTrayIcon();
+    }
 }
 
-void
-GeneneralConf::autostartChanged(bool checked)
+void GeneneralConf::autostartChanged(bool checked)
 {
-  ConfigHandler().setStartupLaunch(checked);
+    ConfigHandler().setStartupLaunch(checked);
 }
 
-void
-GeneneralConf::closeAfterCaptureChanged(bool checked)
+void GeneneralConf::closeAfterCaptureChanged(bool checked)
 {
-  ConfigHandler().setCloseAfterScreenshot(checked);
+    ConfigHandler().setCloseAfterScreenshot(checked);
 }
 
-void
-GeneneralConf::importConfiguration()
+void GeneneralConf::importConfiguration()
 {
-  QString fileName = QFileDialog::getOpenFileName(this, tr("Import"));
-  if (fileName.isEmpty()) {
-    return;
-  }
-  QFile file(fileName);
-  QTextCodec* codec = QTextCodec::codecForLocale();
-  if (!file.open(QFile::ReadOnly)) {
-    QMessageBox::about(this, tr("Error"), tr("Unable to read file."));
-    return;
-  }
-  QString text = codec->toUnicode(file.readAll());
-  file.close();
-
-  QFile config(ConfigHandler().configFilePath());
-  if (!config.open(QFile::WriteOnly)) {
-    QMessageBox::about(this, tr("Error"), tr("Unable to write file."));
-    return;
-  }
-  config.write(codec->fromUnicode(text));
-  config.close();
+    QString fileName = QFileDialog::getOpenFileName(this, tr("Import"));
+    if (fileName.isEmpty()) {
+        return;
+    }
+    QFile file(fileName);
+    QTextCodec* codec = QTextCodec::codecForLocale();
+    if (!file.open(QFile::ReadOnly)) {
+        QMessageBox::about(this, tr("Error"), tr("Unable to read file."));
+        return;
+    }
+    QString text = codec->toUnicode(file.readAll());
+    file.close();
+
+    QFile config(ConfigHandler().configFilePath());
+    if (!config.open(QFile::WriteOnly)) {
+        QMessageBox::about(this, tr("Error"), tr("Unable to write file."));
+        return;
+    }
+    config.write(codec->fromUnicode(text));
+    config.close();
 }
 
-void
-GeneneralConf::exportFileConfiguration()
+void GeneneralConf::exportFileConfiguration()
 {
-  QString fileName = QFileDialog::getSaveFileName(
-    this, tr("Save File"), QStringLiteral("flameshot.conf"));
-
-  // Cancel button
-  if (fileName.isNull()) {
-    return;
-  }
-
-  QFile targetFile(fileName);
-  if (targetFile.exists()) {
-    targetFile.remove();
-  }
-  bool ok = QFile::copy(ConfigHandler().configFilePath(), fileName);
-  if (!ok) {
-    QMessageBox::about(this, tr("Error"), tr("Unable to write file."));
-  }
+    QString fileName = QFileDialog::getSaveFileName(
+      this, tr("Save File"), QStringLiteral("flameshot.conf"));
+
+    // Cancel button
+    if (fileName.isNull()) {
+        return;
+    }
+
+    QFile targetFile(fileName);
+    if (targetFile.exists()) {
+        targetFile.remove();
+    }
+    bool ok = QFile::copy(ConfigHandler().configFilePath(), fileName);
+    if (!ok) {
+        QMessageBox::about(this, tr("Error"), tr("Unable to write file."));
+    }
 }
 
-void
-GeneneralConf::resetConfiguration()
+void GeneneralConf::resetConfiguration()
 {
-  QMessageBox::StandardButton reply;
-  reply = QMessageBox::question(
-    this,
-    tr("Confirm Reset"),
-    tr("Are you sure you want to reset the configuration?"),
-    QMessageBox::Yes | QMessageBox::No);
-  if (reply == QMessageBox::Yes) {
-    ConfigHandler().setDefaults();
-  }
+    QMessageBox::StandardButton reply;
+    reply = QMessageBox::question(
+      this,
+      tr("Confirm Reset"),
+      tr("Are you sure you want to reset the configuration?"),
+      QMessageBox::Yes | QMessageBox::No);
+    if (reply == QMessageBox::Yes) {
+        ConfigHandler().setDefaults();
+    }
 }
 
-void
-GeneneralConf::initShowHelp()
+void GeneneralConf::initShowHelp()
 {
-  m_helpMessage = new QCheckBox(tr("Show help message"), this);
-  ConfigHandler config;
-  bool checked = config.showHelpValue();
-  m_helpMessage->setChecked(checked);
-  m_helpMessage->setToolTip(tr("Show the help message at the beginning "
-                               "in the capture mode."));
-  m_layout->addWidget(m_helpMessage);
-
-  connect(
-    m_helpMessage, &QCheckBox::clicked, this, &GeneneralConf::showHelpChanged);
+    m_helpMessage = new QCheckBox(tr("Show help message"), this);
+    ConfigHandler config;
+    bool checked = config.showHelpValue();
+    m_helpMessage->setChecked(checked);
+    m_helpMessage->setToolTip(tr("Show the help message at the beginning "
+                                 "in the capture mode."));
+    m_layout->addWidget(m_helpMessage);
+
+    connect(m_helpMessage,
+            &QCheckBox::clicked,
+            this,
+            &GeneneralConf::showHelpChanged);
 }
 
-void
-GeneneralConf::initShowSidePanelButton()
+void GeneneralConf::initShowSidePanelButton()
 {
-  m_sidePanelButton = new QCheckBox(tr("Show the side panel button"), this);
-  m_sidePanelButton->setChecked(ConfigHandler().showSidePanelButtonValue());
-  m_sidePanelButton->setToolTip(
-    tr("Show the side panel toggle button in the capture mode."));
-  m_layout->addWidget(m_sidePanelButton);
-
-  connect(m_sidePanelButton,
-          &QCheckBox::clicked,
-          this,
-          &GeneneralConf::showSidePanelButtonChanged);
+    m_sidePanelButton = new QCheckBox(tr("Show the side panel button"), this);
+    m_sidePanelButton->setChecked(ConfigHandler().showSidePanelButtonValue());
+    m_sidePanelButton->setToolTip(
+      tr("Show the side panel toggle button in the capture mode."));
+    m_layout->addWidget(m_sidePanelButton);
+
+    connect(m_sidePanelButton,
+            &QCheckBox::clicked,
+            this,
+            &GeneneralConf::showSidePanelButtonChanged);
 }
-void
-GeneneralConf::initShowDesktopNotification()
+void GeneneralConf::initShowDesktopNotification()
 {
-  m_sysNotifications = new QCheckBox(tr("Show desktop notifications"), this);
-  ConfigHandler config;
-  bool checked = config.desktopNotificationValue();
-  m_sysNotifications->setChecked(checked);
-  m_sysNotifications->setToolTip(tr("Show desktop notifications"));
-  m_layout->addWidget(m_sysNotifications);
-
-  connect(m_sysNotifications,
-          &QCheckBox::clicked,
-          this,
-          &GeneneralConf::showDesktopNotificationChanged);
+    m_sysNotifications = new QCheckBox(tr("Show desktop notifications"), this);
+    ConfigHandler config;
+    bool checked = config.desktopNotificationValue();
+    m_sysNotifications->setChecked(checked);
+    m_sysNotifications->setToolTip(tr("Show desktop notifications"));
+    m_layout->addWidget(m_sysNotifications);
+
+    connect(m_sysNotifications,
+            &QCheckBox::clicked,
+            this,
+            &GeneneralConf::showDesktopNotificationChanged);
 }
 
-void
-GeneneralConf::initShowTrayIcon()
+void GeneneralConf::initShowTrayIcon()
 {
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  m_showTray = new QCheckBox(tr("Show tray icon"), this);
-  ConfigHandler config;
-  bool checked = !config.disabledTrayIconValue();
-  m_showTray->setChecked(checked);
-  m_showTray->setToolTip(tr("Show the systemtray icon"));
-  m_layout->addWidget(m_showTray);
-
-  connect(m_showTray,
-          &QCheckBox::stateChanged,
-          this,
-          &GeneneralConf::showTrayIconChanged);
+    m_showTray = new QCheckBox(tr("Show tray icon"), this);
+    ConfigHandler config;
+    bool checked = !config.disabledTrayIconValue();
+    m_showTray->setChecked(checked);
+    m_showTray->setToolTip(tr("Show the systemtray icon"));
+    m_layout->addWidget(m_showTray);
+
+    connect(m_showTray,
+            &QCheckBox::stateChanged,
+            this,
+            &GeneneralConf::showTrayIconChanged);
 #endif
 }
 
-void
-GeneneralConf::initConfingButtons()
+void GeneneralConf::initConfingButtons()
 {
-  QHBoxLayout* buttonLayout = new QHBoxLayout();
-  m_layout->addStretch();
-  QGroupBox* box = new QGroupBox(tr("Configuration File"));
-  box->setFlat(true);
-  box->setLayout(buttonLayout);
-  m_layout->addWidget(box);
-
-  m_exportButton = new QPushButton(tr("Export"));
-  buttonLayout->addWidget(m_exportButton);
-  connect(m_exportButton,
-          &QPushButton::clicked,
-          this,
-          &GeneneralConf::exportFileConfiguration);
-
-  m_importButton = new QPushButton(tr("Import"));
-  buttonLayout->addWidget(m_importButton);
-  connect(m_importButton,
-          &QPushButton::clicked,
-          this,
-          &GeneneralConf::importConfiguration);
-
-  m_resetButton = new QPushButton(tr("Reset"));
-  buttonLayout->addWidget(m_resetButton);
-  connect(m_resetButton,
-          &QPushButton::clicked,
-          this,
-          &GeneneralConf::resetConfiguration);
+    QHBoxLayout* buttonLayout = new QHBoxLayout();
+    m_layout->addStretch();
+    QGroupBox* box = new QGroupBox(tr("Configuration File"));
+    box->setFlat(true);
+    box->setLayout(buttonLayout);
+    m_layout->addWidget(box);
+
+    m_exportButton = new QPushButton(tr("Export"));
+    buttonLayout->addWidget(m_exportButton);
+    connect(m_exportButton,
+            &QPushButton::clicked,
+            this,
+            &GeneneralConf::exportFileConfiguration);
+
+    m_importButton = new QPushButton(tr("Import"));
+    buttonLayout->addWidget(m_importButton);
+    connect(m_importButton,
+            &QPushButton::clicked,
+            this,
+            &GeneneralConf::importConfiguration);
+
+    m_resetButton = new QPushButton(tr("Reset"));
+    buttonLayout->addWidget(m_resetButton);
+    connect(m_resetButton,
+            &QPushButton::clicked,
+            this,
+            &GeneneralConf::resetConfiguration);
 }
 
-void
-GeneneralConf::initAutostart()
+void GeneneralConf::initAutostart()
 {
-  m_autostart = new QCheckBox(tr("Launch at startup"), this);
-  ConfigHandler config;
-  bool checked = config.startupLaunchValue();
-  m_autostart->setChecked(checked);
-  m_autostart->setToolTip(tr("Launch Flameshot"));
-  m_layout->addWidget(m_autostart);
-
-  connect(
-    m_autostart, &QCheckBox::clicked, this, &GeneneralConf::autostartChanged);
+    m_autostart = new QCheckBox(tr("Launch at startup"), this);
+    ConfigHandler config;
+    bool checked = config.startupLaunchValue();
+    m_autostart->setChecked(checked);
+    m_autostart->setToolTip(tr("Launch Flameshot"));
+    m_layout->addWidget(m_autostart);
+
+    connect(
+      m_autostart, &QCheckBox::clicked, this, &GeneneralConf::autostartChanged);
 }
 
-void
-GeneneralConf::initCloseAfterCapture()
+void GeneneralConf::initCloseAfterCapture()
 {
-  m_closeAfterCapture = new QCheckBox(tr("Close after capture"), this);
-  ConfigHandler config;
-  bool checked = config.closeAfterScreenshotValue();
-  m_closeAfterCapture->setChecked(checked);
-  m_closeAfterCapture->setToolTip(tr("Close after taking a screenshot"));
-  m_layout->addWidget(m_closeAfterCapture);
-
-  connect(m_closeAfterCapture,
-          &QCheckBox::clicked,
-          this,
-          &GeneneralConf::closeAfterCaptureChanged);
+    m_closeAfterCapture = new QCheckBox(tr("Close after capture"), this);
+    ConfigHandler config;
+    bool checked = config.closeAfterScreenshotValue();
+    m_closeAfterCapture->setChecked(checked);
+    m_closeAfterCapture->setToolTip(tr("Close after taking a screenshot"));
+    m_layout->addWidget(m_closeAfterCapture);
+
+    connect(m_closeAfterCapture,
+            &QCheckBox::clicked,
+            this,
+            &GeneneralConf::closeAfterCaptureChanged);
 }
 
-void
-GeneneralConf::initCopyAndCloseAfterUpload()
+void GeneneralConf::initCopyAndCloseAfterUpload()
 {
-  m_copyAndCloseAfterUpload = new QCheckBox(tr("Copy URL after upload"), this);
-  ConfigHandler config;
-  m_copyAndCloseAfterUpload->setChecked(
-    config.copyAndCloseAfterUploadEnabled());
-  m_copyAndCloseAfterUpload->setToolTip(
-    tr("Copy URL and close window after upload"));
-  m_layout->addWidget(m_copyAndCloseAfterUpload);
-
-  connect(m_copyAndCloseAfterUpload, &QCheckBox::clicked, [](bool checked) {
-    ConfigHandler().setCopyAndCloseAfterUploadEnabled(checked);
-  });
+    m_copyAndCloseAfterUpload =
+      new QCheckBox(tr("Copy URL after upload"), this);
+    ConfigHandler config;
+    m_copyAndCloseAfterUpload->setChecked(
+      config.copyAndCloseAfterUploadEnabled());
+    m_copyAndCloseAfterUpload->setToolTip(
+      tr("Copy URL and close window after upload"));
+    m_layout->addWidget(m_copyAndCloseAfterUpload);
+
+    connect(m_copyAndCloseAfterUpload, &QCheckBox::clicked, [](bool checked) {
+        ConfigHandler().setCopyAndCloseAfterUploadEnabled(checked);
+    });
 }
 
-void
-GeneneralConf::initSaveAfterCopy()
+void GeneneralConf::initSaveAfterCopy()
 {
-  m_saveAfterCopy = new QCheckBox(tr("Save image after copy"), this);
-  m_saveAfterCopy->setToolTip(tr("Save image file after copying it"));
-  m_layout->addWidget(m_saveAfterCopy);
-  connect(m_saveAfterCopy,
-          &QCheckBox::clicked,
-          this,
-          &GeneneralConf::saveAfterCopyChanged);
-
-  QHBoxLayout* pathLayout = new QHBoxLayout();
-  m_layout->addStretch();
-  QGroupBox* box = new QGroupBox(tr("Save Path"));
-  box->setFlat(true);
-  box->setLayout(pathLayout);
-  m_layout->addWidget(box);
-
-  m_savePath = new QLineEdit(
-    QStandardPaths::writableLocation(QStandardPaths::PicturesLocation), this);
-  m_savePath->setDisabled(true);
-  QString foreground = this->palette().foreground().color().name();
-  m_savePath->setStyleSheet(QStringLiteral("color: %1").arg(foreground));
-  pathLayout->addWidget(m_savePath);
-
-  m_changeSaveButton = new QPushButton(tr("Change..."), this);
-  pathLayout->addWidget(m_changeSaveButton);
-  connect(m_changeSaveButton,
-          &QPushButton::clicked,
-          this,
-          &GeneneralConf::changeSavePath);
+    m_saveAfterCopy = new QCheckBox(tr("Save image after copy"), this);
+    m_saveAfterCopy->setToolTip(tr("Save image file after copying it"));
+    m_layout->addWidget(m_saveAfterCopy);
+    connect(m_saveAfterCopy,
+            &QCheckBox::clicked,
+            this,
+            &GeneneralConf::saveAfterCopyChanged);
+
+    QHBoxLayout* pathLayout = new QHBoxLayout();
+    m_layout->addStretch();
+    QGroupBox* box = new QGroupBox(tr("Save Path"));
+    box->setFlat(true);
+    box->setLayout(pathLayout);
+    m_layout->addWidget(box);
+
+    m_savePath = new QLineEdit(
+      QStandardPaths::writableLocation(QStandardPaths::PicturesLocation), this);
+    m_savePath->setDisabled(true);
+    QString foreground = this->palette().foreground().color().name();
+    m_savePath->setStyleSheet(QStringLiteral("color: %1").arg(foreground));
+    pathLayout->addWidget(m_savePath);
+
+    m_changeSaveButton = new QPushButton(tr("Change..."), this);
+    pathLayout->addWidget(m_changeSaveButton);
+    connect(m_changeSaveButton,
+            &QPushButton::clicked,
+            this,
+            &GeneneralConf::changeSavePath);
 }
 
-void
-GeneneralConf::saveAfterCopyChanged(bool checked)
+void GeneneralConf::saveAfterCopyChanged(bool checked)
 {
-  ConfigHandler().setSaveAfterCopy(checked);
+    ConfigHandler().setSaveAfterCopy(checked);
 }
 
-void
-GeneneralConf::changeSavePath()
+void GeneneralConf::changeSavePath()
 {
-  QString path = QFileDialog::getExistingDirectory(
-    this,
-    tr("Choose a Folder"),
-    QStandardPaths::writableLocation(QStandardPaths::PicturesLocation),
-    QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
-  if (path.isEmpty()) {
-    return;
-  }
-  if (!QFileInfo(path).isWritable()) {
-    QMessageBox::about(this, tr("Error"), tr("Unable to write to directory."));
-    return;
-  }
-  m_savePath->setText(path);
-  ConfigHandler().setSaveAfterCopyPath(path);
+    QString path = QFileDialog::getExistingDirectory(
+      this,
+      tr("Choose a Folder"),
+      QStandardPaths::writableLocation(QStandardPaths::PicturesLocation),
+      QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+    if (path.isEmpty()) {
+        return;
+    }
+    if (!QFileInfo(path).isWritable()) {
+        QMessageBox::about(
+          this, tr("Error"), tr("Unable to write to directory."));
+        return;
+    }
+    m_savePath->setText(path);
+    ConfigHandler().setSaveAfterCopyPath(path);
 }
diff --git a/src/config/geneneralconf.h b/src/config/geneneralconf.h
index 527d03af..d6bcbdca 100644
--- a/src/config/geneneralconf.h
+++ b/src/config/geneneralconf.h
@@ -27,49 +27,49 @@ class QLineEdit;
 
 class GeneneralConf : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit GeneneralConf(QWidget* parent = nullptr);
+    explicit GeneneralConf(QWidget* parent = nullptr);
 
 public slots:
-  void updateComponents();
+    void updateComponents();
 
 private slots:
-  void showHelpChanged(bool checked);
-  void showSidePanelButtonChanged(bool checked);
-  void showDesktopNotificationChanged(bool checked);
-  void showTrayIconChanged(bool checked);
-  void autostartChanged(bool checked);
-  void closeAfterCaptureChanged(bool checked);
-  void saveAfterCopyChanged(bool checked);
-  void changeSavePath();
-  void importConfiguration();
-  void exportFileConfiguration();
-  void resetConfiguration();
+    void showHelpChanged(bool checked);
+    void showSidePanelButtonChanged(bool checked);
+    void showDesktopNotificationChanged(bool checked);
+    void showTrayIconChanged(bool checked);
+    void autostartChanged(bool checked);
+    void closeAfterCaptureChanged(bool checked);
+    void saveAfterCopyChanged(bool checked);
+    void changeSavePath();
+    void importConfiguration();
+    void exportFileConfiguration();
+    void resetConfiguration();
 
 private:
-  QVBoxLayout* m_layout;
-  QCheckBox* m_sysNotifications;
-  QCheckBox* m_showTray;
-  QCheckBox* m_helpMessage;
-  QCheckBox* m_sidePanelButton;
-  QCheckBox* m_autostart;
-  QCheckBox* m_closeAfterCapture;
-  QCheckBox* m_copyAndCloseAfterUpload;
-  QPushButton* m_importButton;
-  QPushButton* m_exportButton;
-  QPushButton* m_resetButton;
-  QCheckBox* m_saveAfterCopy;
-  QLineEdit* m_savePath;
-  QPushButton* m_changeSaveButton;
+    QVBoxLayout* m_layout;
+    QCheckBox* m_sysNotifications;
+    QCheckBox* m_showTray;
+    QCheckBox* m_helpMessage;
+    QCheckBox* m_sidePanelButton;
+    QCheckBox* m_autostart;
+    QCheckBox* m_closeAfterCapture;
+    QCheckBox* m_copyAndCloseAfterUpload;
+    QPushButton* m_importButton;
+    QPushButton* m_exportButton;
+    QPushButton* m_resetButton;
+    QCheckBox* m_saveAfterCopy;
+    QLineEdit* m_savePath;
+    QPushButton* m_changeSaveButton;
 
-  void initShowHelp();
-  void initShowSidePanelButton();
-  void initShowDesktopNotification();
-  void initShowTrayIcon();
-  void initConfingButtons();
-  void initAutostart();
-  void initCloseAfterCapture();
-  void initCopyAndCloseAfterUpload();
-  void initSaveAfterCopy();
+    void initShowHelp();
+    void initShowSidePanelButton();
+    void initShowDesktopNotification();
+    void initShowTrayIcon();
+    void initConfingButtons();
+    void initAutostart();
+    void initCloseAfterCapture();
+    void initCopyAndCloseAfterUpload();
+    void initSaveAfterCopy();
 };
diff --git a/src/config/strftimechooserwidget.cpp b/src/config/strftimechooserwidget.cpp
index 47dc9fe6..e415a077 100644
--- a/src/config/strftimechooserwidget.cpp
+++ b/src/config/strftimechooserwidget.cpp
@@ -23,49 +23,50 @@
 StrftimeChooserWidget::StrftimeChooserWidget(QWidget* parent)
   : QWidget(parent)
 {
-  QGridLayout* layout = new QGridLayout(this);
-  auto k = m_buttonData.keys();
-  int middle = k.length() / 2;
-  // add the buttons in 2 columns (they need to be even)
-  for (int i = 0; i < 2; i++) {
-    for (int j = 0; j < middle; j++) {
-      QString key = k.last();
-      k.pop_back();
-      QString variable = m_buttonData.value(key);
-      QPushButton* button = new QPushButton(this);
-      button->setText(tr(key.toStdString().data()));
-      button->setToolTip(variable);
-      button->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-      button->setMinimumHeight(25);
-      layout->addWidget(button, j, i);
-      connect(button, &QPushButton::clicked, this, [variable, this]() {
-        emit variableEmitted(variable);
-      });
+    QGridLayout* layout = new QGridLayout(this);
+    auto k = m_buttonData.keys();
+    int middle = k.length() / 2;
+    // add the buttons in 2 columns (they need to be even)
+    for (int i = 0; i < 2; i++) {
+        for (int j = 0; j < middle; j++) {
+            QString key = k.last();
+            k.pop_back();
+            QString variable = m_buttonData.value(key);
+            QPushButton* button = new QPushButton(this);
+            button->setText(tr(key.toStdString().data()));
+            button->setToolTip(variable);
+            button->setSizePolicy(QSizePolicy::Expanding,
+                                  QSizePolicy::Expanding);
+            button->setMinimumHeight(25);
+            layout->addWidget(button, j, i);
+            connect(button, &QPushButton::clicked, this, [variable, this]() {
+                emit variableEmitted(variable);
+            });
+        }
     }
-  }
-  setLayout(layout);
+    setLayout(layout);
 }
 
 QMap<QString, QString> StrftimeChooserWidget::m_buttonData{
-  { QT_TR_NOOP("Century (00-99)"), "%C" },
-  { QT_TR_NOOP("Year (00-99)"), "%y" },
-  { QT_TR_NOOP("Year (2000)"), "%Y" },
-  { QT_TR_NOOP("Month Name (jan)"), "%b" },
-  { QT_TR_NOOP("Month Name (january)"), "%B" },
-  { QT_TR_NOOP("Month (01-12)"), "%m" },
-  { QT_TR_NOOP("Week Day (1-7)"), "%u" },
-  { QT_TR_NOOP("Week (01-53)"), "%V" },
-  { QT_TR_NOOP("Day Name (mon)"), "%a" },
-  { QT_TR_NOOP("Day Name (monday)"), "%A" },
-  { QT_TR_NOOP("Day (01-31)"), "%d" },
-  { QT_TR_NOOP("Day of Month (1-31)"), "%e" },
-  { QT_TR_NOOP("Day (001-366)"), "%j" },
-  { QT_TR_NOOP("Time (%H-%M-%S)"), "%T" },
-  { QT_TR_NOOP("Time (%H-%M)"), "%R" },
-  { QT_TR_NOOP("Hour (00-23)"), "%H" },
-  { QT_TR_NOOP("Hour (01-12)"), "%I" },
-  { QT_TR_NOOP("Minute (00-59)"), "%M" },
-  { QT_TR_NOOP("Second (00-59)"), "%S" },
-  { QT_TR_NOOP("Full Date (%m/%d/%y)"), "%D" },
-  { QT_TR_NOOP("Full Date (%Y-%m-%d)"), "%F" },
+    { QT_TR_NOOP("Century (00-99)"), "%C" },
+    { QT_TR_NOOP("Year (00-99)"), "%y" },
+    { QT_TR_NOOP("Year (2000)"), "%Y" },
+    { QT_TR_NOOP("Month Name (jan)"), "%b" },
+    { QT_TR_NOOP("Month Name (january)"), "%B" },
+    { QT_TR_NOOP("Month (01-12)"), "%m" },
+    { QT_TR_NOOP("Week Day (1-7)"), "%u" },
+    { QT_TR_NOOP("Week (01-53)"), "%V" },
+    { QT_TR_NOOP("Day Name (mon)"), "%a" },
+    { QT_TR_NOOP("Day Name (monday)"), "%A" },
+    { QT_TR_NOOP("Day (01-31)"), "%d" },
+    { QT_TR_NOOP("Day of Month (1-31)"), "%e" },
+    { QT_TR_NOOP("Day (001-366)"), "%j" },
+    { QT_TR_NOOP("Time (%H-%M-%S)"), "%T" },
+    { QT_TR_NOOP("Time (%H-%M)"), "%R" },
+    { QT_TR_NOOP("Hour (00-23)"), "%H" },
+    { QT_TR_NOOP("Hour (01-12)"), "%I" },
+    { QT_TR_NOOP("Minute (00-59)"), "%M" },
+    { QT_TR_NOOP("Second (00-59)"), "%S" },
+    { QT_TR_NOOP("Full Date (%m/%d/%y)"), "%D" },
+    { QT_TR_NOOP("Full Date (%Y-%m-%d)"), "%F" },
 };
diff --git a/src/config/strftimechooserwidget.h b/src/config/strftimechooserwidget.h
index df014689..10a7dc80 100644
--- a/src/config/strftimechooserwidget.h
+++ b/src/config/strftimechooserwidget.h
@@ -21,13 +21,13 @@
 
 class StrftimeChooserWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit StrftimeChooserWidget(QWidget* parent = nullptr);
+    explicit StrftimeChooserWidget(QWidget* parent = nullptr);
 
 signals:
-  void variableEmitted(const QString&);
+    void variableEmitted(const QString&);
 
 private:
-  static QMap<QString, QString> m_buttonData;
+    static QMap<QString, QString> m_buttonData;
 };
diff --git a/src/config/uicoloreditor.cpp b/src/config/uicoloreditor.cpp
index 8acb0ba1..4761e938 100644
--- a/src/config/uicoloreditor.cpp
+++ b/src/config/uicoloreditor.cpp
@@ -29,162 +29,156 @@
 UIcolorEditor::UIcolorEditor(QWidget* parent)
   : QGroupBox(parent)
 {
-  setTitle(tr("UI Color Editor"));
-  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-  m_hLayout = new QHBoxLayout;
-  m_vLayout = new QVBoxLayout;
-
-  const int space = QApplication::fontMetrics().lineSpacing();
-  m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));
-  m_vLayout->setAlignment(Qt::AlignVCenter);
-
-  initButtons();
-  initColorWheel();
-
-  m_vLayout->addSpacing(space);
-  m_hLayout->addLayout(m_vLayout);
-  m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));
-  setLayout(m_hLayout);
-  updateComponents();
+    setTitle(tr("UI Color Editor"));
+    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    m_hLayout = new QHBoxLayout;
+    m_vLayout = new QVBoxLayout;
+
+    const int space = QApplication::fontMetrics().lineSpacing();
+    m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));
+    m_vLayout->setAlignment(Qt::AlignVCenter);
+
+    initButtons();
+    initColorWheel();
+
+    m_vLayout->addSpacing(space);
+    m_hLayout->addLayout(m_vLayout);
+    m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));
+    setLayout(m_hLayout);
+    updateComponents();
 }
 
-void
-UIcolorEditor::updateComponents()
+void UIcolorEditor::updateComponents()
 {
-  ConfigHandler config;
-  m_uiColor = config.uiMainColorValue();
-  m_contrastColor = config.uiContrastColorValue();
-  m_buttonContrast->setColor(m_contrastColor);
-  m_buttonMainColor->setColor(m_uiColor);
-  if (m_lastButtonPressed == m_buttonMainColor) {
-    m_colorWheel->setColor(m_uiColor);
-  } else {
-    m_colorWheel->setColor(m_contrastColor);
-  }
+    ConfigHandler config;
+    m_uiColor = config.uiMainColorValue();
+    m_contrastColor = config.uiContrastColorValue();
+    m_buttonContrast->setColor(m_contrastColor);
+    m_buttonMainColor->setColor(m_uiColor);
+    if (m_lastButtonPressed == m_buttonMainColor) {
+        m_colorWheel->setColor(m_uiColor);
+    } else {
+        m_colorWheel->setColor(m_contrastColor);
+    }
 }
 
 // updateUIcolor updates the appearance of the buttons
-void
-UIcolorEditor::updateUIcolor()
+void UIcolorEditor::updateUIcolor()
 {
-  ConfigHandler config;
-  if (m_lastButtonPressed == m_buttonMainColor) {
-    config.setUIMainColor(m_uiColor);
-  } else {
-    config.setUIContrastColor(m_contrastColor);
-  }
+    ConfigHandler config;
+    if (m_lastButtonPressed == m_buttonMainColor) {
+        config.setUIMainColor(m_uiColor);
+    } else {
+        config.setUIContrastColor(m_contrastColor);
+    }
 }
 
 // updateLocalColor updates the local button
-void
-UIcolorEditor::updateLocalColor(const QColor c)
+void UIcolorEditor::updateLocalColor(const QColor c)
 {
-  if (m_lastButtonPressed == m_buttonMainColor) {
-    m_uiColor = c;
-  } else {
-    m_contrastColor = c;
-  }
-  m_lastButtonPressed->setColor(c);
+    if (m_lastButtonPressed == m_buttonMainColor) {
+        m_uiColor = c;
+    } else {
+        m_contrastColor = c;
+    }
+    m_lastButtonPressed->setColor(c);
 }
 
-void
-UIcolorEditor::initColorWheel()
+void UIcolorEditor::initColorWheel()
 {
-  m_colorWheel = new color_widgets::ColorWheel(this);
-  connect(m_colorWheel,
-          &color_widgets::ColorWheel::mouseReleaseOnColor,
-          this,
-          &UIcolorEditor::updateUIcolor);
-  connect(m_colorWheel,
-          &color_widgets::ColorWheel::colorChanged,
-          this,
-          &UIcolorEditor::updateLocalColor);
-
-  const int size = GlobalValues::buttonBaseSize() * 3;
-  m_colorWheel->setMinimumSize(size, size);
-  m_colorWheel->setMaximumSize(size * 2, size * 2);
-  m_colorWheel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-  m_colorWheel->setToolTip(tr("Change the color moving the selectors and see"
-                              " the changes in the preview buttons."));
-
-  m_hLayout->addWidget(m_colorWheel);
+    m_colorWheel = new color_widgets::ColorWheel(this);
+    connect(m_colorWheel,
+            &color_widgets::ColorWheel::mouseReleaseOnColor,
+            this,
+            &UIcolorEditor::updateUIcolor);
+    connect(m_colorWheel,
+            &color_widgets::ColorWheel::colorChanged,
+            this,
+            &UIcolorEditor::updateLocalColor);
+
+    const int size = GlobalValues::buttonBaseSize() * 3;
+    m_colorWheel->setMinimumSize(size, size);
+    m_colorWheel->setMaximumSize(size * 2, size * 2);
+    m_colorWheel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    m_colorWheel->setToolTip(tr("Change the color moving the selectors and see"
+                                " the changes in the preview buttons."));
+
+    m_hLayout->addWidget(m_colorWheel);
 }
 
-void
-UIcolorEditor::initButtons()
+void UIcolorEditor::initButtons()
 {
-  const int extraSize = GlobalValues::buttonBaseSize() / 3;
-  int frameSize = GlobalValues::buttonBaseSize() + extraSize;
-
-  m_vLayout->addWidget(new QLabel(tr("Select a Button to modify it"), this));
-
-  QGroupBox* frame = new QGroupBox();
-  frame->setFixedSize(frameSize, frameSize);
-
-  m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame);
-  m_buttonMainColor->move(m_buttonMainColor->x() + extraSize / 2,
-                          m_buttonMainColor->y() + extraSize / 2);
-  QHBoxLayout* h1 = new QHBoxLayout();
-  h1->addWidget(frame);
-  m_labelMain = new ClickableLabel(tr("Main Color"), this);
-  h1->addWidget(m_labelMain);
-  m_vLayout->addLayout(h1);
-
-  m_buttonMainColor->setToolTip(tr("Click on this button to set the edition"
-                                   " mode of the main color."));
-
-  QGroupBox* frame2 = new QGroupBox();
-  m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2);
-  m_buttonContrast->move(m_buttonContrast->x() + extraSize / 2,
-                         m_buttonContrast->y() + extraSize / 2);
-
-  QHBoxLayout* h2 = new QHBoxLayout();
-  h2->addWidget(frame2);
-  frame2->setFixedSize(frameSize, frameSize);
-  m_labelContrast = new ClickableLabel(tr("Contrast Color"), this);
-  m_labelContrast->setStyleSheet(QStringLiteral("color : gray"));
-  h2->addWidget(m_labelContrast);
-  m_vLayout->addLayout(h2);
-
-  m_buttonContrast->setToolTip(tr("Click on this button to set the edition"
-                                  " mode of the contrast color."));
-
-  connect(m_buttonMainColor,
-          &CaptureToolButton::pressedButton,
-          this,
-          &UIcolorEditor::changeLastButton);
-  connect(m_buttonContrast,
-          &CaptureToolButton::pressedButton,
-          this,
-          &UIcolorEditor::changeLastButton);
-  // clicking the labels changes the button too
-  connect(m_labelMain, &ClickableLabel::clicked, this, [this] {
-    changeLastButton(m_buttonMainColor);
-  });
-  connect(m_labelContrast, &ClickableLabel::clicked, this, [this] {
-    changeLastButton(m_buttonContrast);
-  });
-  m_lastButtonPressed = m_buttonMainColor;
+    const int extraSize = GlobalValues::buttonBaseSize() / 3;
+    int frameSize = GlobalValues::buttonBaseSize() + extraSize;
+
+    m_vLayout->addWidget(new QLabel(tr("Select a Button to modify it"), this));
+
+    QGroupBox* frame = new QGroupBox();
+    frame->setFixedSize(frameSize, frameSize);
+
+    m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame);
+    m_buttonMainColor->move(m_buttonMainColor->x() + extraSize / 2,
+                            m_buttonMainColor->y() + extraSize / 2);
+    QHBoxLayout* h1 = new QHBoxLayout();
+    h1->addWidget(frame);
+    m_labelMain = new ClickableLabel(tr("Main Color"), this);
+    h1->addWidget(m_labelMain);
+    m_vLayout->addLayout(h1);
+
+    m_buttonMainColor->setToolTip(tr("Click on this button to set the edition"
+                                     " mode of the main color."));
+
+    QGroupBox* frame2 = new QGroupBox();
+    m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2);
+    m_buttonContrast->move(m_buttonContrast->x() + extraSize / 2,
+                           m_buttonContrast->y() + extraSize / 2);
+
+    QHBoxLayout* h2 = new QHBoxLayout();
+    h2->addWidget(frame2);
+    frame2->setFixedSize(frameSize, frameSize);
+    m_labelContrast = new ClickableLabel(tr("Contrast Color"), this);
+    m_labelContrast->setStyleSheet(QStringLiteral("color : gray"));
+    h2->addWidget(m_labelContrast);
+    m_vLayout->addLayout(h2);
+
+    m_buttonContrast->setToolTip(tr("Click on this button to set the edition"
+                                    " mode of the contrast color."));
+
+    connect(m_buttonMainColor,
+            &CaptureToolButton::pressedButton,
+            this,
+            &UIcolorEditor::changeLastButton);
+    connect(m_buttonContrast,
+            &CaptureToolButton::pressedButton,
+            this,
+            &UIcolorEditor::changeLastButton);
+    // clicking the labels changes the button too
+    connect(m_labelMain, &ClickableLabel::clicked, this, [this] {
+        changeLastButton(m_buttonMainColor);
+    });
+    connect(m_labelContrast, &ClickableLabel::clicked, this, [this] {
+        changeLastButton(m_buttonContrast);
+    });
+    m_lastButtonPressed = m_buttonMainColor;
 }
 
 // visual update for the selected button
-void
-UIcolorEditor::changeLastButton(CaptureToolButton* b)
+void UIcolorEditor::changeLastButton(CaptureToolButton* b)
 {
-  if (m_lastButtonPressed != b) {
-    m_lastButtonPressed = b;
-
-    QString offStyle(QStringLiteral("QLabel { color : gray; }"));
-
-    if (b == m_buttonMainColor) {
-      m_colorWheel->setColor(m_uiColor);
-      m_labelContrast->setStyleSheet(offStyle);
-      m_labelMain->setStyleSheet(styleSheet());
-    } else {
-      m_colorWheel->setColor(m_contrastColor);
-      m_labelContrast->setStyleSheet(styleSheet());
-      m_labelMain->setStyleSheet(offStyle);
+    if (m_lastButtonPressed != b) {
+        m_lastButtonPressed = b;
+
+        QString offStyle(QStringLiteral("QLabel { color : gray; }"));
+
+        if (b == m_buttonMainColor) {
+            m_colorWheel->setColor(m_uiColor);
+            m_labelContrast->setStyleSheet(offStyle);
+            m_labelMain->setStyleSheet(styleSheet());
+        } else {
+            m_colorWheel->setColor(m_contrastColor);
+            m_labelContrast->setStyleSheet(styleSheet());
+            m_labelMain->setStyleSheet(offStyle);
+        }
+        b->setIcon(b->icon());
     }
-    b->setIcon(b->icon());
-  }
 }
diff --git a/src/config/uicoloreditor.h b/src/config/uicoloreditor.h
index 46e38239..bc57f881 100644
--- a/src/config/uicoloreditor.h
+++ b/src/config/uicoloreditor.h
@@ -28,33 +28,33 @@ class ClickableLabel;
 
 class UIcolorEditor : public QGroupBox
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit UIcolorEditor(QWidget* parent = nullptr);
+    explicit UIcolorEditor(QWidget* parent = nullptr);
 
 public slots:
-  void updateComponents();
+    void updateComponents();
 
 private slots:
-  void updateUIcolor();
-  void updateLocalColor(const QColor);
-  void changeLastButton(CaptureToolButton*);
+    void updateUIcolor();
+    void updateLocalColor(const QColor);
+    void changeLastButton(CaptureToolButton*);
 
 private:
-  QColor m_uiColor, m_contrastColor;
-  CaptureToolButton* m_buttonMainColor;
-  ClickableLabel* m_labelMain;
-  CaptureToolButton* m_buttonContrast;
-  ClickableLabel* m_labelContrast;
-  CaptureToolButton* m_lastButtonPressed;
-  color_widgets::ColorWheel* m_colorWheel;
-
-  static const CaptureToolButton::ButtonType m_buttonIconType =
-    CaptureToolButton::TYPE_CIRCLE;
-
-  QHBoxLayout* m_hLayout;
-  QVBoxLayout* m_vLayout;
-
-  void initColorWheel();
-  void initButtons();
+    QColor m_uiColor, m_contrastColor;
+    CaptureToolButton* m_buttonMainColor;
+    ClickableLabel* m_labelMain;
+    CaptureToolButton* m_buttonContrast;
+    ClickableLabel* m_labelContrast;
+    CaptureToolButton* m_lastButtonPressed;
+    color_widgets::ColorWheel* m_colorWheel;
+
+    static const CaptureToolButton::ButtonType m_buttonIconType =
+      CaptureToolButton::TYPE_CIRCLE;
+
+    QHBoxLayout* m_hLayout;
+    QVBoxLayout* m_vLayout;
+
+    void initColorWheel();
+    void initButtons();
 };
diff --git a/src/config/visualseditor.cpp b/src/config/visualseditor.cpp
index 6e702955..7a587e81 100644
--- a/src/config/visualseditor.cpp
+++ b/src/config/visualseditor.cpp
@@ -27,75 +27,71 @@
 VisualsEditor::VisualsEditor(QWidget* parent)
   : QWidget(parent)
 {
-  m_layout = new QVBoxLayout();
-  setLayout(m_layout);
-  initWidgets();
+    m_layout = new QVBoxLayout();
+    setLayout(m_layout);
+    initWidgets();
 }
 
-void
-VisualsEditor::updateComponents()
+void VisualsEditor::updateComponents()
 {
-  m_buttonList->updateComponents();
-  m_colorEditor->updateComponents();
-  int opacity = ConfigHandler().contrastOpacityValue();
-  m_opacitySlider->setMapedValue(0, opacity, 255);
+    m_buttonList->updateComponents();
+    m_colorEditor->updateComponents();
+    int opacity = ConfigHandler().contrastOpacityValue();
+    m_opacitySlider->setMapedValue(0, opacity, 255);
 }
 
-void
-VisualsEditor::initOpacitySlider()
+void VisualsEditor::initOpacitySlider()
 {
-  m_opacitySlider = new ExtendedSlider();
-  m_opacitySlider->setFocusPolicy(Qt::NoFocus);
-  m_opacitySlider->setOrientation(Qt::Horizontal);
-  m_opacitySlider->setRange(0, 100);
-  connect(m_opacitySlider,
-          &ExtendedSlider::modificationsEnded,
-          this,
-          &VisualsEditor::saveOpacity);
-  QHBoxLayout* localLayout = new QHBoxLayout();
-  localLayout->addWidget(new QLabel(QStringLiteral("0%")));
-  localLayout->addWidget(m_opacitySlider);
-  localLayout->addWidget(new QLabel(QStringLiteral("100%")));
+    m_opacitySlider = new ExtendedSlider();
+    m_opacitySlider->setFocusPolicy(Qt::NoFocus);
+    m_opacitySlider->setOrientation(Qt::Horizontal);
+    m_opacitySlider->setRange(0, 100);
+    connect(m_opacitySlider,
+            &ExtendedSlider::modificationsEnded,
+            this,
+            &VisualsEditor::saveOpacity);
+    QHBoxLayout* localLayout = new QHBoxLayout();
+    localLayout->addWidget(new QLabel(QStringLiteral("0%")));
+    localLayout->addWidget(m_opacitySlider);
+    localLayout->addWidget(new QLabel(QStringLiteral("100%")));
 
-  QLabel* label = new QLabel();
-  QString labelMsg = tr("Opacity of area outside selection:") + " %1%";
-  connect(m_opacitySlider,
-          &ExtendedSlider::valueChanged,
-          this,
-          [labelMsg, label](int val) { label->setText(labelMsg.arg(val)); });
-  m_layout->addWidget(label);
-  m_layout->addLayout(localLayout);
+    QLabel* label = new QLabel();
+    QString labelMsg = tr("Opacity of area outside selection:") + " %1%";
+    connect(m_opacitySlider,
+            &ExtendedSlider::valueChanged,
+            this,
+            [labelMsg, label](int val) { label->setText(labelMsg.arg(val)); });
+    m_layout->addWidget(label);
+    m_layout->addLayout(localLayout);
 
-  int opacity = ConfigHandler().contrastOpacityValue();
-  m_opacitySlider->setMapedValue(0, opacity, 255);
+    int opacity = ConfigHandler().contrastOpacityValue();
+    m_opacitySlider->setMapedValue(0, opacity, 255);
 }
 
-void
-VisualsEditor::saveOpacity()
+void VisualsEditor::saveOpacity()
 {
-  int value = m_opacitySlider->mappedValue(0, 255);
-  ConfigHandler().setContrastOpacity(value);
+    int value = m_opacitySlider->mappedValue(0, 255);
+    ConfigHandler().setContrastOpacity(value);
 }
 
-void
-VisualsEditor::initWidgets()
+void VisualsEditor::initWidgets()
 {
-  m_colorEditor = new UIcolorEditor();
-  m_layout->addWidget(m_colorEditor);
+    m_colorEditor = new UIcolorEditor();
+    m_layout->addWidget(m_colorEditor);
 
-  initOpacitySlider();
+    initOpacitySlider();
 
-  auto boxButtons = new QGroupBox();
-  boxButtons->setTitle(tr("Button Selection"));
-  auto listLayout = new QVBoxLayout(boxButtons);
-  m_buttonList = new ButtonListView();
-  m_layout->addWidget(boxButtons);
-  listLayout->addWidget(m_buttonList);
+    auto boxButtons = new QGroupBox();
+    boxButtons->setTitle(tr("Button Selection"));
+    auto listLayout = new QVBoxLayout(boxButtons);
+    m_buttonList = new ButtonListView();
+    m_layout->addWidget(boxButtons);
+    listLayout->addWidget(m_buttonList);
 
-  QPushButton* setAllButtons = new QPushButton(tr("Select All"));
-  connect(setAllButtons,
-          &QPushButton::clicked,
-          m_buttonList,
-          &ButtonListView::selectAll);
-  listLayout->addWidget(setAllButtons);
+    QPushButton* setAllButtons = new QPushButton(tr("Select All"));
+    connect(setAllButtons,
+            &QPushButton::clicked,
+            m_buttonList,
+            &ButtonListView::selectAll);
+    listLayout->addWidget(setAllButtons);
 }
diff --git a/src/config/visualseditor.h b/src/config/visualseditor.h
index 9acbd119..2458e973 100644
--- a/src/config/visualseditor.h
+++ b/src/config/visualseditor.h
@@ -26,22 +26,22 @@ class UIcolorEditor;
 
 class VisualsEditor : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit VisualsEditor(QWidget* parent = nullptr);
+    explicit VisualsEditor(QWidget* parent = nullptr);
 
 public slots:
-  void updateComponents();
+    void updateComponents();
 
 private slots:
-  void saveOpacity();
+    void saveOpacity();
 
 private:
-  QVBoxLayout* m_layout;
-  ButtonListView* m_buttonList;
-  UIcolorEditor* m_colorEditor;
-  ExtendedSlider* m_opacitySlider;
+    QVBoxLayout* m_layout;
+    ButtonListView* m_buttonList;
+    UIcolorEditor* m_colorEditor;
+    ExtendedSlider* m_opacitySlider;
 
-  void initWidgets();
-  void initOpacitySlider();
+    void initWidgets();
+    void initOpacitySlider();
 };
diff --git a/src/core/capturerequest.cpp b/src/core/capturerequest.cpp
index e493cb77..dfefac83 100644
--- a/src/core/capturerequest.cpp
+++ b/src/core/capturerequest.cpp
@@ -34,72 +34,64 @@ CaptureRequest::CaptureRequest(CaptureRequest::CaptureMode mode,
   , m_id(0)
 {}
 
-void
-CaptureRequest::setStaticID(uint id)
+void CaptureRequest::setStaticID(uint id)
 {
-  m_forcedID = true;
-  m_id = id;
+    m_forcedID = true;
+    m_id = id;
 }
 
-uint
-CaptureRequest::id() const
+uint CaptureRequest::id() const
 {
-  if (m_forcedID) {
-    return m_id;
-  }
+    if (m_forcedID) {
+        return m_id;
+    }
 
-  uint id = 0;
-  QVector<uint> v;
-  v << qHash(m_mode) << qHash(m_delay * QDateTime::currentMSecsSinceEpoch())
-    << qHash(m_path) << qHash(m_tasks) << m_data.toInt();
-  for (uint i : v) {
-    id ^= i + 0x9e3779b9 + (id << 6) + (id >> 2);
-  }
-  return id;
+    uint id = 0;
+    QVector<uint> v;
+    v << qHash(m_mode) << qHash(m_delay * QDateTime::currentMSecsSinceEpoch())
+      << qHash(m_path) << qHash(m_tasks) << m_data.toInt();
+    for (uint i : v) {
+        id ^= i + 0x9e3779b9 + (id << 6) + (id >> 2);
+    }
+    return id;
 }
 
-CaptureRequest::CaptureMode
-CaptureRequest::captureMode() const
+CaptureRequest::CaptureMode CaptureRequest::captureMode() const
 {
-  return m_mode;
+    return m_mode;
 }
 
-uint
-CaptureRequest::delay() const
+uint CaptureRequest::delay() const
 {
-  return m_delay;
+    return m_delay;
 }
 
-QString
-CaptureRequest::path() const
+QString CaptureRequest::path() const
 {
-  return m_path;
+    return m_path;
 }
 
-QVariant
-CaptureRequest::data() const
+QVariant CaptureRequest::data() const
 {
-  return m_data;
+    return m_data;
 }
 
-void
-CaptureRequest::addTask(CaptureRequest::ExportTask task)
+void CaptureRequest::addTask(CaptureRequest::ExportTask task)
 {
-  m_tasks |= task;
+    m_tasks |= task;
 }
 
-void
-CaptureRequest::exportCapture(const QPixmap& p)
+void CaptureRequest::exportCapture(const QPixmap& p)
 {
-  if ((m_tasks & ExportTask::FILESYSTEM_SAVE_TASK) != ExportTask::NO_TASK) {
-    if (m_path.isEmpty()) {
-      ScreenshotSaver().saveToFilesystemGUI(p);
-    } else {
-      ScreenshotSaver().saveToFilesystem(p, m_path, "");
+    if ((m_tasks & ExportTask::FILESYSTEM_SAVE_TASK) != ExportTask::NO_TASK) {
+        if (m_path.isEmpty()) {
+            ScreenshotSaver().saveToFilesystemGUI(p);
+        } else {
+            ScreenshotSaver().saveToFilesystem(p, m_path, "");
+        }
     }
-  }
 
-  if ((m_tasks & ExportTask::CLIPBOARD_SAVE_TASK) != ExportTask::NO_TASK) {
-    ScreenshotSaver().saveToClipboard(p);
-  }
+    if ((m_tasks & ExportTask::CLIPBOARD_SAVE_TASK) != ExportTask::NO_TASK) {
+        ScreenshotSaver().saveToClipboard(p);
+    }
 }
diff --git a/src/core/capturerequest.h b/src/core/capturerequest.h
index 4adf3c45..649c5a86 100644
--- a/src/core/capturerequest.h
+++ b/src/core/capturerequest.h
@@ -24,65 +24,62 @@
 class CaptureRequest
 {
 public:
-  enum CaptureMode
-  {
-    FULLSCREEN_MODE,
-    GRAPHICAL_MODE,
-    SCREEN_MODE,
-  };
+    enum CaptureMode
+    {
+        FULLSCREEN_MODE,
+        GRAPHICAL_MODE,
+        SCREEN_MODE,
+    };
 
-  enum ExportTask
-  {
-    NO_TASK = 0,
-    CLIPBOARD_SAVE_TASK = 1,
-    FILESYSTEM_SAVE_TASK = 2,
-  };
+    enum ExportTask
+    {
+        NO_TASK = 0,
+        CLIPBOARD_SAVE_TASK = 1,
+        FILESYSTEM_SAVE_TASK = 2,
+    };
 
-  CaptureRequest(CaptureMode mode,
-                 const uint delay = 0,
-                 const QString& path = QLatin1String(""),
-                 const QVariant& data = QVariant(),
-                 ExportTask tasks = NO_TASK);
+    CaptureRequest(CaptureMode mode,
+                   const uint delay = 0,
+                   const QString& path = QLatin1String(""),
+                   const QVariant& data = QVariant(),
+                   ExportTask tasks = NO_TASK);
 
-  void setStaticID(uint id);
+    void setStaticID(uint id);
 
-  uint id() const;
-  uint delay() const;
-  QString path() const;
-  QVariant data() const;
-  CaptureMode captureMode() const;
+    uint id() const;
+    uint delay() const;
+    QString path() const;
+    QVariant data() const;
+    CaptureMode captureMode() const;
 
-  void addTask(ExportTask task);
-  void exportCapture(const QPixmap& p);
+    void addTask(ExportTask task);
+    void exportCapture(const QPixmap& p);
 
 private:
-  CaptureMode m_mode;
-  uint m_delay;
-  QString m_path;
-  ExportTask m_tasks;
-  QVariant m_data;
+    CaptureMode m_mode;
+    uint m_delay;
+    QString m_path;
+    ExportTask m_tasks;
+    QVariant m_data;
 
-  bool m_forcedID;
-  uint m_id;
+    bool m_forcedID;
+    uint m_id;
 };
 
 using eTask = CaptureRequest::ExportTask;
 
-inline eTask
-operator|(const eTask& a, const eTask& b)
+inline eTask operator|(const eTask& a, const eTask& b)
 {
-  return static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b));
+    return static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b));
 }
 
-inline eTask
-operator&(const eTask& a, const eTask& b)
+inline eTask operator&(const eTask& a, const eTask& b)
 {
-  return static_cast<eTask>(static_cast<int>(a) & static_cast<int>(b));
+    return static_cast<eTask>(static_cast<int>(a) & static_cast<int>(b));
 }
 
-inline eTask&
-operator|=(eTask& a, const eTask& b)
+inline eTask& operator|=(eTask& a, const eTask& b)
 {
-  a = static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b));
-  return a;
+    a = static_cast<eTask>(static_cast<int>(a) | static_cast<int>(b));
+    return a;
 }
diff --git a/src/core/controller.cpp b/src/core/controller.cpp
index b2756ee0..f26d0473 100644
--- a/src/core/controller.cpp
+++ b/src/core/controller.cpp
@@ -41,279 +41,268 @@
 Controller::Controller()
   : m_captureWindow(nullptr)
 {
-  qApp->setQuitOnLastWindowClosed(false);
+    qApp->setQuitOnLastWindowClosed(false);
 
-  // init tray icon
+    // init tray icon
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  if (!ConfigHandler().disabledTrayIconValue()) {
-    enableTrayIcon();
-  }
+    if (!ConfigHandler().disabledTrayIconValue()) {
+        enableTrayIcon();
+    }
 #elif defined(Q_OS_WIN)
-  enableTrayIcon();
+    enableTrayIcon();
 
-  GlobalShortcutFilter* nativeFilter = new GlobalShortcutFilter(this);
-  qApp->installNativeEventFilter(nativeFilter);
-  connect(nativeFilter, &GlobalShortcutFilter::printPressed, this, [this]() {
-    this->requestCapture(CaptureRequest(CaptureRequest::GRAPHICAL_MODE));
-  });
+    GlobalShortcutFilter* nativeFilter = new GlobalShortcutFilter(this);
+    qApp->installNativeEventFilter(nativeFilter);
+    connect(nativeFilter, &GlobalShortcutFilter::printPressed, this, [this]() {
+        this->requestCapture(CaptureRequest(CaptureRequest::GRAPHICAL_MODE));
+    });
 #endif
 
-  QString StyleSheet = CaptureButton::globalStyleSheet();
-  qApp->setStyleSheet(StyleSheet);
+    QString StyleSheet = CaptureButton::globalStyleSheet();
+    qApp->setStyleSheet(StyleSheet);
 }
 
-Controller*
-Controller::getInstance()
+Controller* Controller::getInstance()
 {
-  static Controller c;
-  return &c;
+    static Controller c;
+    return &c;
 }
 
-void
-Controller::enableExports()
+void Controller::enableExports()
 {
-  connect(
-    this, &Controller::captureTaken, this, &Controller::handleCaptureTaken);
-  connect(
-    this, &Controller::captureFailed, this, &Controller::handleCaptureFailed);
+    connect(
+      this, &Controller::captureTaken, this, &Controller::handleCaptureTaken);
+    connect(
+      this, &Controller::captureFailed, this, &Controller::handleCaptureFailed);
 }
 
-void
-Controller::requestCapture(const CaptureRequest& request)
+void Controller::requestCapture(const CaptureRequest& request)
 {
-  uint id = request.id();
-  m_requestMap.insert(id, request);
+    uint id = request.id();
+    m_requestMap.insert(id, request);
 
-  switch (request.captureMode()) {
-    case CaptureRequest::FULLSCREEN_MODE:
-      doLater(request.delay(), this, [this, id]() {
-        this->startFullscreenCapture(id);
-      });
-      break;
-    // TODO: Figure out the code path that gets here so the deprated warning can
-    // be fixed
-    case CaptureRequest::SCREEN_MODE: {
-      int&& number = request.data().toInt();
-      doLater(request.delay(), this, [this, id, number]() {
-        this->startScreenGrab(id, number);
-      });
-      break;
+    switch (request.captureMode()) {
+        case CaptureRequest::FULLSCREEN_MODE:
+            doLater(request.delay(), this, [this, id]() {
+                this->startFullscreenCapture(id);
+            });
+            break;
+        // TODO: Figure out the code path that gets here so the deprated warning
+        // can be fixed
+        case CaptureRequest::SCREEN_MODE: {
+            int&& number = request.data().toInt();
+            doLater(request.delay(), this, [this, id, number]() {
+                this->startScreenGrab(id, number);
+            });
+            break;
+        }
+        case CaptureRequest::GRAPHICAL_MODE: {
+            QString&& path = request.path();
+            doLater(request.delay(), this, [this, id, path]() {
+                this->startVisualCapture(id, path);
+            });
+            break;
+        }
+        default:
+            emit captureFailed(id);
+            break;
     }
-    case CaptureRequest::GRAPHICAL_MODE: {
-      QString&& path = request.path();
-      doLater(request.delay(), this, [this, id, path]() {
-        this->startVisualCapture(id, path);
-      });
-      break;
-    }
-    default:
-      emit captureFailed(id);
-      break;
-  }
 }
 
 // creation of a new capture in GUI mode
-void
-Controller::startVisualCapture(const uint id, const QString& forcedSavePath)
+void Controller::startVisualCapture(const uint id,
+                                    const QString& forcedSavePath)
 {
-  if (!m_captureWindow) {
-    QWidget* modalWidget = nullptr;
-    do {
-      modalWidget = qApp->activeModalWidget();
-      if (modalWidget) {
-        modalWidget->close();
-        modalWidget->deleteLater();
-      }
-    } while (modalWidget);
+    if (!m_captureWindow) {
+        QWidget* modalWidget = nullptr;
+        do {
+            modalWidget = qApp->activeModalWidget();
+            if (modalWidget) {
+                modalWidget->close();
+                modalWidget->deleteLater();
+            }
+        } while (modalWidget);
 
-    m_captureWindow = new CaptureWidget(id, forcedSavePath);
-    // m_captureWindow = new CaptureWidget(id, forcedSavePath, false); // debug
-    connect(m_captureWindow,
-            &CaptureWidget::captureFailed,
-            this,
-            &Controller::captureFailed);
-    connect(m_captureWindow,
-            &CaptureWidget::captureTaken,
-            this,
-            &Controller::captureTaken);
+        m_captureWindow = new CaptureWidget(id, forcedSavePath);
+        // m_captureWindow = new CaptureWidget(id, forcedSavePath, false); //
+        // debug
+        connect(m_captureWindow,
+                &CaptureWidget::captureFailed,
+                this,
+                &Controller::captureFailed);
+        connect(m_captureWindow,
+                &CaptureWidget::captureTaken,
+                this,
+                &Controller::captureTaken);
 
 #ifdef Q_OS_WIN
-    m_captureWindow->show();
+        m_captureWindow->show();
 #else
-    m_captureWindow->showFullScreen();
-    // m_captureWindow->show(); // Debug
+        m_captureWindow->showFullScreen();
+        // m_captureWindow->show(); // Debug
 #endif
-  } else {
-    emit captureFailed(id);
-  }
+    } else {
+        emit captureFailed(id);
+    }
 }
 
-void
-Controller::startScreenGrab(const uint id, const int screenNumber)
+void Controller::startScreenGrab(const uint id, const int screenNumber)
 {
-  bool ok = true;
-  int n = screenNumber;
+    bool ok = true;
+    int n = screenNumber;
 
-  if (n < 0) {
-    QPoint globalCursorPos = QCursor::pos();
-    n = qApp->desktop()->screenNumber(globalCursorPos);
-  }
-  QPixmap p(ScreenGrabber().grabScreen(n, ok));
-  if (ok) {
-    emit captureTaken(id, p);
-  } else {
-    emit captureFailed(id);
-  }
+    if (n < 0) {
+        QPoint globalCursorPos = QCursor::pos();
+        n = qApp->desktop()->screenNumber(globalCursorPos);
+    }
+    QPixmap p(ScreenGrabber().grabScreen(n, ok));
+    if (ok) {
+        emit captureTaken(id, p);
+    } else {
+        emit captureFailed(id);
+    }
 }
 
 // creation of the configuration window
-void
-Controller::openConfigWindow()
+void Controller::openConfigWindow()
 {
-  if (!m_configWindow) {
-    m_configWindow = new ConfigWindow();
-    m_configWindow->show();
-  }
+    if (!m_configWindow) {
+        m_configWindow = new ConfigWindow();
+        m_configWindow->show();
+    }
 }
 
 // creation of the window of information
-void
-Controller::openInfoWindow()
+void Controller::openInfoWindow()
 {
-  if (!m_infoWindow) {
-    m_infoWindow = new InfoWindow();
-  }
+    if (!m_infoWindow) {
+        m_infoWindow = new InfoWindow();
+    }
 }
 
-void
-Controller::openLauncherWindow()
+void Controller::openLauncherWindow()
 {
-  if (!m_launcherWindow) {
-    m_launcherWindow = new CaptureLauncher();
-  }
-  m_launcherWindow->show();
+    if (!m_launcherWindow) {
+        m_launcherWindow = new CaptureLauncher();
+    }
+    m_launcherWindow->show();
 }
 
-void
-Controller::enableTrayIcon()
+void Controller::enableTrayIcon()
 {
-  if (m_trayIcon) {
-    return;
-  }
-  ConfigHandler().setDisabledTrayIcon(false);
-  QAction* captureAction = new QAction(tr("&Take Screenshot"), this);
-  connect(captureAction, &QAction::triggered, this, [this]() {
-    // Wait 400 ms to hide the QMenu
-    doLater(400, this, [this]() { this->startVisualCapture(); });
-  });
-  QAction* launcherAction = new QAction(tr("&Open Launcher"), this);
-  connect(
-    launcherAction, &QAction::triggered, this, &Controller::openLauncherWindow);
-  QAction* configAction = new QAction(tr("&Configuration"), this);
-  connect(
-    configAction, &QAction::triggered, this, &Controller::openConfigWindow);
-  QAction* infoAction = new QAction(tr("&About"), this);
-  connect(infoAction, &QAction::triggered, this, &Controller::openInfoWindow);
-  QAction* quitAction = new QAction(tr("&Quit"), this);
-  connect(quitAction, &QAction::triggered, qApp, &QCoreApplication::quit);
+    if (m_trayIcon) {
+        return;
+    }
+    ConfigHandler().setDisabledTrayIcon(false);
+    QAction* captureAction = new QAction(tr("&Take Screenshot"), this);
+    connect(captureAction, &QAction::triggered, this, [this]() {
+        // Wait 400 ms to hide the QMenu
+        doLater(400, this, [this]() { this->startVisualCapture(); });
+    });
+    QAction* launcherAction = new QAction(tr("&Open Launcher"), this);
+    connect(launcherAction,
+            &QAction::triggered,
+            this,
+            &Controller::openLauncherWindow);
+    QAction* configAction = new QAction(tr("&Configuration"), this);
+    connect(
+      configAction, &QAction::triggered, this, &Controller::openConfigWindow);
+    QAction* infoAction = new QAction(tr("&About"), this);
+    connect(infoAction, &QAction::triggered, this, &Controller::openInfoWindow);
+    QAction* quitAction = new QAction(tr("&Quit"), this);
+    connect(quitAction, &QAction::triggered, qApp, &QCoreApplication::quit);
 
-  QMenu* trayIconMenu = new QMenu();
-  trayIconMenu->addAction(captureAction);
-  trayIconMenu->addAction(launcherAction);
-  trayIconMenu->addSeparator();
-  trayIconMenu->addAction(configAction);
-  trayIconMenu->addAction(infoAction);
-  trayIconMenu->addSeparator();
-  trayIconMenu->addAction(quitAction);
+    QMenu* trayIconMenu = new QMenu();
+    trayIconMenu->addAction(captureAction);
+    trayIconMenu->addAction(launcherAction);
+    trayIconMenu->addSeparator();
+    trayIconMenu->addAction(configAction);
+    trayIconMenu->addAction(infoAction);
+    trayIconMenu->addSeparator();
+    trayIconMenu->addAction(quitAction);
 
-  m_trayIcon = new QSystemTrayIcon();
-  m_trayIcon->setToolTip(QStringLiteral("Flameshot"));
-  m_trayIcon->setContextMenu(trayIconMenu);
-  QIcon trayicon =
-    QIcon::fromTheme("flameshot-tray", QIcon(":img/app/flameshot.png"));
-  m_trayIcon->setIcon(trayicon);
+    m_trayIcon = new QSystemTrayIcon();
+    m_trayIcon->setToolTip(QStringLiteral("Flameshot"));
+    m_trayIcon->setContextMenu(trayIconMenu);
+    QIcon trayicon =
+      QIcon::fromTheme("flameshot-tray", QIcon(":img/app/flameshot.png"));
+    m_trayIcon->setIcon(trayicon);
 
-  auto trayIconActivated = [this](QSystemTrayIcon::ActivationReason r) {
-    if (r == QSystemTrayIcon::Trigger) {
-      startVisualCapture();
-    }
-  };
-  connect(m_trayIcon, &QSystemTrayIcon::activated, this, trayIconActivated);
-  m_trayIcon->show();
+    auto trayIconActivated = [this](QSystemTrayIcon::ActivationReason r) {
+        if (r == QSystemTrayIcon::Trigger) {
+            startVisualCapture();
+        }
+    };
+    connect(m_trayIcon, &QSystemTrayIcon::activated, this, trayIconActivated);
+    m_trayIcon->show();
 }
 
-void
-Controller::disableTrayIcon()
+void Controller::disableTrayIcon()
 {
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  if (m_trayIcon) {
-    m_trayIcon->deleteLater();
-  }
-  ConfigHandler().setDisabledTrayIcon(true);
+    if (m_trayIcon) {
+        m_trayIcon->deleteLater();
+    }
+    ConfigHandler().setDisabledTrayIcon(true);
 #endif
 }
 
-void
-Controller::sendTrayNotification(const QString& text,
-                                 const QString& title,
-                                 const int timeout)
+void Controller::sendTrayNotification(const QString& text,
+                                      const QString& title,
+                                      const int timeout)
 {
-  if (m_trayIcon) {
-    m_trayIcon->showMessage(title, text, QSystemTrayIcon::Information, timeout);
-  }
+    if (m_trayIcon) {
+        m_trayIcon->showMessage(
+          title, text, QSystemTrayIcon::Information, timeout);
+    }
 }
 
-void
-Controller::updateConfigComponents()
+void Controller::updateConfigComponents()
 {
-  if (m_configWindow) {
-    m_configWindow->updateChildren();
-  }
+    if (m_configWindow) {
+        m_configWindow->updateChildren();
+    }
 }
 
-void
-Controller::startFullscreenCapture(const uint id)
+void Controller::startFullscreenCapture(const uint id)
 {
-  bool ok = true;
-  QPixmap p(ScreenGrabber().grabEntireDesktop(ok));
-  if (ok) {
-    emit captureTaken(id, p);
-  } else {
-    emit captureFailed(id);
-  }
+    bool ok = true;
+    QPixmap p(ScreenGrabber().grabEntireDesktop(ok));
+    if (ok) {
+        emit captureTaken(id, p);
+    } else {
+        emit captureFailed(id);
+    }
 }
 
-void
-Controller::handleCaptureTaken(uint id, QPixmap p)
+void Controller::handleCaptureTaken(uint id, QPixmap p)
 {
-  auto it = m_requestMap.find(id);
-  if (it != m_requestMap.end()) {
-    it.value().exportCapture(p);
-    m_requestMap.erase(it);
-  }
-  if (ConfigHandler().closeAfterScreenshotValue()) {
-    QApplication::quit();
-  }
+    auto it = m_requestMap.find(id);
+    if (it != m_requestMap.end()) {
+        it.value().exportCapture(p);
+        m_requestMap.erase(it);
+    }
+    if (ConfigHandler().closeAfterScreenshotValue()) {
+        QApplication::quit();
+    }
 }
 
-void
-Controller::handleCaptureFailed(uint id)
+void Controller::handleCaptureFailed(uint id)
 {
-  m_requestMap.remove(id);
+    m_requestMap.remove(id);
 
-  if (ConfigHandler().closeAfterScreenshotValue()) {
-    QApplication::quit();
-  }
+    if (ConfigHandler().closeAfterScreenshotValue()) {
+        QApplication::quit();
+    }
 }
 
-void
-Controller::doLater(int msec, QObject* receiver, lambda func)
+void Controller::doLater(int msec, QObject* receiver, lambda func)
 {
-  QTimer* timer = new QTimer(receiver);
-  QObject::connect(timer, &QTimer::timeout, receiver, [timer, func]() {
-    func();
-    timer->deleteLater();
-  });
-  timer->setInterval(msec);
-  timer->start();
+    QTimer* timer = new QTimer(receiver);
+    QObject::connect(timer, &QTimer::timeout, receiver, [timer, func]() {
+        func();
+        timer->deleteLater();
+    });
+    timer->setInterval(msec);
+    timer->start();
 }
diff --git a/src/core/controller.h b/src/core/controller.h
index 86ccdfc6..dabe5130 100644
--- a/src/core/controller.h
+++ b/src/core/controller.h
@@ -34,55 +34,55 @@ using lambda = std::function<void(void)>;
 
 class Controller : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  static Controller* getInstance();
+    static Controller* getInstance();
 
-  Controller(const Controller&) = delete;
-  void operator=(const Controller&) = delete;
+    Controller(const Controller&) = delete;
+    void operator=(const Controller&) = delete;
 
-  void enableExports();
+    void enableExports();
 
 signals:
-  void captureTaken(uint id, QPixmap p);
-  void captureFailed(uint id);
+    void captureTaken(uint id, QPixmap p);
+    void captureFailed(uint id);
 
 public slots:
-  void requestCapture(const CaptureRequest& request);
+    void requestCapture(const CaptureRequest& request);
 
-  void openConfigWindow();
-  void openInfoWindow();
-  void openLauncherWindow();
-  void enableTrayIcon();
-  void disableTrayIcon();
-  void sendTrayNotification(
-    const QString& text,
-    const QString& title = QStringLiteral("Flameshot Info"),
-    const int timeout = 5000);
+    void openConfigWindow();
+    void openInfoWindow();
+    void openLauncherWindow();
+    void enableTrayIcon();
+    void disableTrayIcon();
+    void sendTrayNotification(
+      const QString& text,
+      const QString& title = QStringLiteral("Flameshot Info"),
+      const int timeout = 5000);
 
-  void updateConfigComponents();
+    void updateConfigComponents();
 
 private slots:
-  void startFullscreenCapture(const uint id = 0);
-  void startVisualCapture(const uint id = 0,
-                          const QString& forcedSavePath = QString());
-  void startScreenGrab(const uint id = 0, const int screenNumber = -1);
+    void startFullscreenCapture(const uint id = 0);
+    void startVisualCapture(const uint id = 0,
+                            const QString& forcedSavePath = QString());
+    void startScreenGrab(const uint id = 0, const int screenNumber = -1);
 
-  void handleCaptureTaken(uint id, QPixmap p);
-  void handleCaptureFailed(uint id);
+    void handleCaptureTaken(uint id, QPixmap p);
+    void handleCaptureFailed(uint id);
 
 private:
-  Controller();
-
-  // replace QTimer::singleShot introduced in Qt 5.4
-  // the actual target Qt version is 5.3
-  void doLater(int msec, QObject* receiver, lambda func);
-
-  QMap<uint, CaptureRequest> m_requestMap;
-  QPointer<CaptureWidget> m_captureWindow;
-  QPointer<InfoWindow> m_infoWindow;
-  QPointer<CaptureLauncher> m_launcherWindow;
-  QPointer<ConfigWindow> m_configWindow;
-  QPointer<QSystemTrayIcon> m_trayIcon;
+    Controller();
+
+    // replace QTimer::singleShot introduced in Qt 5.4
+    // the actual target Qt version is 5.3
+    void doLater(int msec, QObject* receiver, lambda func);
+
+    QMap<uint, CaptureRequest> m_requestMap;
+    QPointer<CaptureWidget> m_captureWindow;
+    QPointer<InfoWindow> m_infoWindow;
+    QPointer<CaptureLauncher> m_launcherWindow;
+    QPointer<ConfigWindow> m_configWindow;
+    QPointer<QSystemTrayIcon> m_trayIcon;
 };
diff --git a/src/core/flameshotdbusadapter.cpp b/src/core/flameshotdbusadapter.cpp
index b3ecb8b0..ff494c03 100644
--- a/src/core/flameshotdbusadapter.cpp
+++ b/src/core/flameshotdbusadapter.cpp
@@ -25,102 +25,94 @@
 FlameshotDBusAdapter::FlameshotDBusAdapter(QObject* parent)
   : QDBusAbstractAdaptor(parent)
 {
-  auto controller = Controller::getInstance();
-  connect(controller,
-          &Controller::captureFailed,
-          this,
-          &FlameshotDBusAdapter::captureFailed);
-  connect(controller,
-          &Controller::captureTaken,
-          this,
-          &FlameshotDBusAdapter::handleCaptureTaken);
+    auto controller = Controller::getInstance();
+    connect(controller,
+            &Controller::captureFailed,
+            this,
+            &FlameshotDBusAdapter::captureFailed);
+    connect(controller,
+            &Controller::captureTaken,
+            this,
+            &FlameshotDBusAdapter::handleCaptureTaken);
 }
 
 FlameshotDBusAdapter::~FlameshotDBusAdapter() {}
 
-void
-FlameshotDBusAdapter::graphicCapture(QString path, int delay, uint id)
+void FlameshotDBusAdapter::graphicCapture(QString path, int delay, uint id)
 {
-  CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, path);
-  //    if (toClipboard) {
-  //        req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
-  //    }
-  req.setStaticID(id);
-  Controller::getInstance()->requestCapture(req);
+    CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, path);
+    //    if (toClipboard) {
+    //        req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
+    //    }
+    req.setStaticID(id);
+    Controller::getInstance()->requestCapture(req);
 }
 
-void
-FlameshotDBusAdapter::fullScreen(QString path,
-                                 bool toClipboard,
-                                 int delay,
-                                 uint id)
+void FlameshotDBusAdapter::fullScreen(QString path,
+                                      bool toClipboard,
+                                      int delay,
+                                      uint id)
 {
-  CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay, path);
-  if (toClipboard) {
-    req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
-  }
-  if (!path.isEmpty()) {
-    req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
-  }
-  req.setStaticID(id);
-  Controller::getInstance()->requestCapture(req);
+    CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay, path);
+    if (toClipboard) {
+        req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
+    }
+    if (!path.isEmpty()) {
+        req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
+    }
+    req.setStaticID(id);
+    Controller::getInstance()->requestCapture(req);
 }
 
-void
-FlameshotDBusAdapter::openLauncher()
+void FlameshotDBusAdapter::openLauncher()
 {
-  Controller::getInstance()->openLauncherWindow();
+    Controller::getInstance()->openLauncherWindow();
 }
 
-void
-FlameshotDBusAdapter::captureScreen(int number,
-                                    QString path,
-                                    bool toClipboard,
-                                    int delay,
-                                    uint id)
+void FlameshotDBusAdapter::captureScreen(int number,
+                                         QString path,
+                                         bool toClipboard,
+                                         int delay,
+                                         uint id)
 {
-  CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, path, number);
-  if (toClipboard) {
-    req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
-  }
-  if (!path.isEmpty()) {
-    req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
-  }
-  req.setStaticID(id);
-  Controller::getInstance()->requestCapture(req);
+    CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, path, number);
+    if (toClipboard) {
+        req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
+    }
+    if (!path.isEmpty()) {
+        req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
+    }
+    req.setStaticID(id);
+    Controller::getInstance()->requestCapture(req);
 }
 
-void
-FlameshotDBusAdapter::openConfig()
+void FlameshotDBusAdapter::openConfig()
 {
-  Controller::getInstance()->openConfigWindow();
+    Controller::getInstance()->openConfigWindow();
 }
 
-void
-FlameshotDBusAdapter::trayIconEnabled(bool enabled)
+void FlameshotDBusAdapter::trayIconEnabled(bool enabled)
 {
-  auto controller = Controller::getInstance();
-  if (enabled) {
-    controller->enableTrayIcon();
-  } else {
-    controller->disableTrayIcon();
-  }
+    auto controller = Controller::getInstance();
+    if (enabled) {
+        controller->enableTrayIcon();
+    } else {
+        controller->disableTrayIcon();
+    }
 }
 
-void
-FlameshotDBusAdapter::autostartEnabled(bool enabled)
+void FlameshotDBusAdapter::autostartEnabled(bool enabled)
 {
-  ConfigHandler().setStartupLaunch(enabled);
-  auto controller = Controller::getInstance();
-  // Autostart is not saved in a .ini file, requires manual update
-  controller->updateConfigComponents();
+    ConfigHandler().setStartupLaunch(enabled);
+    auto controller = Controller::getInstance();
+    // Autostart is not saved in a .ini file, requires manual update
+    controller->updateConfigComponents();
 }
 
-void
-FlameshotDBusAdapter::handleCaptureTaken(uint id, const QPixmap& p)
+void FlameshotDBusAdapter::handleCaptureTaken(uint id, const QPixmap& p)
 {
-  QByteArray byteArray;
-  QBuffer buffer(&byteArray);
-  p.save(&buffer, "PNG");
-  emit captureTaken(id, byteArray);
+    QByteArray byteArray;
+    QBuffer buffer(&byteArray);
+    p.save(&buffer, "PNG");
+    emit captureTaken(id, byteArray);
 }
diff --git a/src/core/flameshotdbusadapter.h b/src/core/flameshotdbusadapter.h
index cadc6d4f..12b9152f 100644
--- a/src/core/flameshotdbusadapter.h
+++ b/src/core/flameshotdbusadapter.h
@@ -22,30 +22,33 @@
 
 class FlameshotDBusAdapter : public QDBusAbstractAdaptor
 {
-  Q_OBJECT
-  Q_CLASSINFO("D-Bus Interface", "org.flameshot.Flameshot")
+    Q_OBJECT
+    Q_CLASSINFO("D-Bus Interface", "org.flameshot.Flameshot")
 
 public:
-  explicit FlameshotDBusAdapter(QObject* parent = nullptr);
-  virtual ~FlameshotDBusAdapter();
+    explicit FlameshotDBusAdapter(QObject* parent = nullptr);
+    virtual ~FlameshotDBusAdapter();
 
 signals:
-  void captureTaken(uint id, QByteArray rawImage);
-  void captureFailed(uint id);
+    void captureTaken(uint id, QByteArray rawImage);
+    void captureFailed(uint id);
 
 public slots:
-  Q_NOREPLY void graphicCapture(QString path, int delay, uint id);
-  Q_NOREPLY void fullScreen(QString path, bool toClipboard, int delay, uint id);
-  Q_NOREPLY void captureScreen(int number,
-                               QString path,
-                               bool toClipboard,
-                               int delay,
-                               uint id);
-  Q_NOREPLY void openLauncher();
-  Q_NOREPLY void openConfig();
-  Q_NOREPLY void trayIconEnabled(bool enabled);
-  Q_NOREPLY void autostartEnabled(bool enabled);
+    Q_NOREPLY void graphicCapture(QString path, int delay, uint id);
+    Q_NOREPLY void fullScreen(QString path,
+                              bool toClipboard,
+                              int delay,
+                              uint id);
+    Q_NOREPLY void captureScreen(int number,
+                                 QString path,
+                                 bool toClipboard,
+                                 int delay,
+                                 uint id);
+    Q_NOREPLY void openLauncher();
+    Q_NOREPLY void openConfig();
+    Q_NOREPLY void trayIconEnabled(bool enabled);
+    Q_NOREPLY void autostartEnabled(bool enabled);
 
 private slots:
-  void handleCaptureTaken(uint id, const QPixmap& p);
+    void handleCaptureTaken(uint id, const QPixmap& p);
 };
diff --git a/src/core/globalshortcutfilter.cpp b/src/core/globalshortcutfilter.cpp
index c23a6316..16b4cbf1 100644
--- a/src/core/globalshortcutfilter.cpp
+++ b/src/core/globalshortcutfilter.cpp
@@ -22,30 +22,29 @@
 GlobalShortcutFilter::GlobalShortcutFilter(QObject* parent)
   : QObject(parent)
 {
-  // Forced Print Screen
-  if (RegisterHotKey(NULL, 1, 0, VK_SNAPSHOT)) {
-    // ok
-  }
+    // Forced Print Screen
+    if (RegisterHotKey(NULL, 1, 0, VK_SNAPSHOT)) {
+        // ok
+    }
 }
 
-bool
-GlobalShortcutFilter::nativeEventFilter(const QByteArray& eventType,
-                                        void* message,
-                                        long* result)
+bool GlobalShortcutFilter::nativeEventFilter(const QByteArray& eventType,
+                                             void* message,
+                                             long* result)
 {
-  Q_UNUSED(eventType);
-  Q_UNUSED(result);
+    Q_UNUSED(eventType);
+    Q_UNUSED(result);
 
-  MSG* msg = static_cast<MSG*>(message);
-  if (msg->message == WM_HOTKEY) {
-    // const quint32 keycode = HIWORD(msg->lParam);
-    // const quint32 modifiers = LOWORD(msg->lParam);
+    MSG* msg = static_cast<MSG*>(message);
+    if (msg->message == WM_HOTKEY) {
+        // const quint32 keycode = HIWORD(msg->lParam);
+        // const quint32 modifiers = LOWORD(msg->lParam);
 
-    // TODO: this is just a temporal workwrround, proper global
-    // support would need custom shortcuts defined by the user.
-    Controller::getInstance()->requestCapture(
-      CaptureRequest(CaptureRequest::GRAPHICAL_MODE));
-    return true;
-  }
-  return false;
+        // TODO: this is just a temporal workwrround, proper global
+        // support would need custom shortcuts defined by the user.
+        Controller::getInstance()->requestCapture(
+          CaptureRequest(CaptureRequest::GRAPHICAL_MODE));
+        return true;
+    }
+    return false;
 }
diff --git a/src/core/globalshortcutfilter.h b/src/core/globalshortcutfilter.h
index 11d77213..3ed8f10d 100644
--- a/src/core/globalshortcutfilter.h
+++ b/src/core/globalshortcutfilter.h
@@ -24,20 +24,20 @@ class GlobalShortcutFilter
   : public QObject
   , public QAbstractNativeEventFilter
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit GlobalShortcutFilter(QObject* parent = nullptr);
+    explicit GlobalShortcutFilter(QObject* parent = nullptr);
 
-  bool nativeEventFilter(const QByteArray& eventType,
-                         void* message,
-                         long* result);
+    bool nativeEventFilter(const QByteArray& eventType,
+                           void* message,
+                           long* result);
 
 signals:
-  void printPressed();
+    void printPressed();
 
 private:
-  quint32 getNativeModifier(Qt::KeyboardModifiers modifiers);
-  quint32 nativeKeycode(Qt::Key key);
-  bool registerShortcut(quint32 nativeKey, quint32 nativeMods);
-  bool unregisterShortcut(quint32 nativeKey, quint32 nativeMods);
+    quint32 getNativeModifier(Qt::KeyboardModifiers modifiers);
+    quint32 nativeKeycode(Qt::Key key);
+    bool registerShortcut(quint32 nativeKey, quint32 nativeMods);
+    bool unregisterShortcut(quint32 nativeKey, quint32 nativeMods);
 };
diff --git a/src/main.cpp b/src/main.cpp
index ea1e4055..417f584d 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -37,431 +37,448 @@
 #include <QDBusMessage>
 #endif
 
-int
-main(int argc, char* argv[])
+int main(int argc, char* argv[])
 {
-  // required for the button serialization
-  // TODO: change to QVector in v1.0
-  qRegisterMetaTypeStreamOperators<QList<int>>("QList<int>");
-  qApp->setApplicationVersion(static_cast<QString>(APP_VERSION));
+    // required for the button serialization
+    // TODO: change to QVector in v1.0
+    qRegisterMetaTypeStreamOperators<QList<int>>("QList<int>");
+    qApp->setApplicationVersion(static_cast<QString>(APP_VERSION));
 
-  // no arguments, just launch Flameshot
-  if (argc == 1) {
-    SingleApplication app(argc, argv);
+    // no arguments, just launch Flameshot
+    if (argc == 1) {
+        SingleApplication app(argc, argv);
 
-    QTranslator translator, qtTranslator;
-    QStringList trPaths = PathInfo::translationsPaths();
+        QTranslator translator, qtTranslator;
+        QStringList trPaths = PathInfo::translationsPaths();
 
-    for (const QString& path : trPaths) {
-      bool match = translator.load(QLocale(),
-                                   QStringLiteral("Internationalization"),
-                                   QStringLiteral("_"),
-                                   path);
-      if (match) {
-        break;
-      }
-    }
+        for (const QString& path : trPaths) {
+            bool match = translator.load(QLocale(),
+                                         QStringLiteral("Internationalization"),
+                                         QStringLiteral("_"),
+                                         path);
+            if (match) {
+                break;
+            }
+        }
 
-    qtTranslator.load(QLocale::system(),
-                      "qt",
-                      "_",
-                      QLibraryInfo::location(QLibraryInfo::TranslationsPath));
+        qtTranslator.load(
+          QLocale::system(),
+          "qt",
+          "_",
+          QLibraryInfo::location(QLibraryInfo::TranslationsPath));
 
-    app.installTranslator(&translator);
-    app.installTranslator(&qtTranslator);
-    app.setAttribute(Qt::AA_DontCreateNativeWidgetSiblings, true);
-    app.setApplicationName(QStringLiteral("flameshot"));
-    app.setOrganizationName(QStringLiteral("flameshot"));
+        app.installTranslator(&translator);
+        app.installTranslator(&qtTranslator);
+        app.setAttribute(Qt::AA_DontCreateNativeWidgetSiblings, true);
+        app.setApplicationName(QStringLiteral("flameshot"));
+        app.setOrganizationName(QStringLiteral("flameshot"));
 
-    auto c = Controller::getInstance();
+        auto c = Controller::getInstance();
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-    new FlameshotDBusAdapter(c);
-    QDBusConnection dbus = QDBusConnection::sessionBus();
-    if (!dbus.isConnected()) {
-      SystemNotification().sendMessage(
-        QObject::tr("Unable to connect via DBus"));
-    }
-    dbus.registerObject(QStringLiteral("/"), c);
-    dbus.registerService(QStringLiteral("org.flameshot.Flameshot"));
+        new FlameshotDBusAdapter(c);
+        QDBusConnection dbus = QDBusConnection::sessionBus();
+        if (!dbus.isConnected()) {
+            SystemNotification().sendMessage(
+              QObject::tr("Unable to connect via DBus"));
+        }
+        dbus.registerObject(QStringLiteral("/"), c);
+        dbus.registerService(QStringLiteral("org.flameshot.Flameshot"));
 #endif
-    // Exporting captures must be connected after the dbus interface
-    // or the dbus signal gets blocked until we end the exports.
-    c->enableExports();
-    return app.exec();
-  }
+        // Exporting captures must be connected after the dbus interface
+        // or the dbus signal gets blocked until we end the exports.
+        c->enableExports();
+        return app.exec();
+    }
 
 #ifndef Q_OS_WIN
-  /*--------------|
-   * CLI parsing  |
-   * ------------*/
-  QCoreApplication app(argc, argv);
-  app.setApplicationName(QStringLiteral("flameshot"));
-  app.setOrganizationName(QStringLiteral("flameshot"));
-  app.setApplicationVersion(qApp->applicationVersion());
-  CommandLineParser parser;
-  // Add description
-  parser.setDescription(
-    QObject::tr("Powerful yet simple to use screenshot software."));
-  parser.setGeneralErrorMessage(QObject::tr("See") + " flameshot --help.");
-  // Arguments
-  CommandArgument fullArgument(QStringLiteral("full"),
-                               QObject::tr("Capture the entire desktop."));
-  CommandArgument launcherArgument(QStringLiteral("launcher"),
-                                   QObject::tr("Open the capture launcher."));
-  CommandArgument guiArgument(
-    QStringLiteral("gui"), QObject::tr("Start a manual capture in GUI mode."));
-  CommandArgument configArgument(QStringLiteral("config"),
-                                 QObject::tr("Configure") + " flameshot.");
-  CommandArgument screenArgument(QStringLiteral("screen"),
-                                 QObject::tr("Capture a single screen."));
-
-  // Options
-  CommandOption pathOption({ "p", "path" },
-                           QObject::tr("Path where the capture will be saved"),
-                           QStringLiteral("path"));
-  CommandOption clipboardOption(
-    { "c", "clipboard" }, QObject::tr("Save the capture to the clipboard"));
-  CommandOption delayOption({ "d", "delay" },
-                            QObject::tr("Delay time in milliseconds"),
-                            QStringLiteral("milliseconds"));
-  CommandOption filenameOption({ "f", "filename" },
-                               QObject::tr("Set the filename pattern"),
-                               QStringLiteral("pattern"));
-  CommandOption trayOption({ "t", "trayicon" },
-                           QObject::tr("Enable or disable the trayicon"),
-                           QStringLiteral("bool"));
-  CommandOption autostartOption({ "a", "autostart" },
-                                QObject::tr("Enable or disable run at startup"),
-                                QStringLiteral("bool"));
-  CommandOption showHelpOption(
-    { "s", "showhelp" },
-    QObject::tr("Show the help message in the capture mode"),
-    QStringLiteral("bool"));
-  CommandOption mainColorOption({ "m", "maincolor" },
-                                QObject::tr("Define the main UI color"),
-                                QStringLiteral("color-code"));
-  CommandOption contrastColorOption({ "k", "contrastcolor" },
-                                    QObject::tr("Define the contrast UI color"),
-                                    QStringLiteral("color-code"));
-  CommandOption rawImageOption({ "r", "raw" },
-                               QObject::tr("Print raw PNG capture"));
-  CommandOption screenNumberOption(
-    { "n", "number" },
-    QObject::tr("Define the screen to capture") + ",\n" +
-      QObject::tr("default: screen containing the cursor"),
-    QObject::tr("Screen number"),
-    QStringLiteral("-1"));
+    /*--------------|
+     * CLI parsing  |
+     * ------------*/
+    QCoreApplication app(argc, argv);
+    app.setApplicationName(QStringLiteral("flameshot"));
+    app.setOrganizationName(QStringLiteral("flameshot"));
+    app.setApplicationVersion(qApp->applicationVersion());
+    CommandLineParser parser;
+    // Add description
+    parser.setDescription(
+      QObject::tr("Powerful yet simple to use screenshot software."));
+    parser.setGeneralErrorMessage(QObject::tr("See") + " flameshot --help.");
+    // Arguments
+    CommandArgument fullArgument(QStringLiteral("full"),
+                                 QObject::tr("Capture the entire desktop."));
+    CommandArgument launcherArgument(QStringLiteral("launcher"),
+                                     QObject::tr("Open the capture launcher."));
+    CommandArgument guiArgument(
+      QStringLiteral("gui"),
+      QObject::tr("Start a manual capture in GUI mode."));
+    CommandArgument configArgument(QStringLiteral("config"),
+                                   QObject::tr("Configure") + " flameshot.");
+    CommandArgument screenArgument(QStringLiteral("screen"),
+                                   QObject::tr("Capture a single screen."));
 
-  // Add checkers
-  auto colorChecker = [](const QString& colorCode) -> bool {
-    QColor parsedColor(colorCode);
-    return parsedColor.isValid() && parsedColor.alphaF() == 1.0;
-  };
-  QString colorErr =
-    QObject::tr("Invalid color, "
-                "this flag supports the following formats:\n"
-                "- #RGB (each of R, G, and B is a single hex digit)\n"
-                "- #RRGGBB\n- #RRRGGGBBB\n"
-                "- #RRRRGGGGBBBB\n"
-                "- Named colors like 'blue' or 'red'\n"
-                "You may need to escape the '#' sign as in '\\#FFF'");
+    // Options
+    CommandOption pathOption(
+      { "p", "path" },
+      QObject::tr("Path where the capture will be saved"),
+      QStringLiteral("path"));
+    CommandOption clipboardOption(
+      { "c", "clipboard" }, QObject::tr("Save the capture to the clipboard"));
+    CommandOption delayOption({ "d", "delay" },
+                              QObject::tr("Delay time in milliseconds"),
+                              QStringLiteral("milliseconds"));
+    CommandOption filenameOption({ "f", "filename" },
+                                 QObject::tr("Set the filename pattern"),
+                                 QStringLiteral("pattern"));
+    CommandOption trayOption({ "t", "trayicon" },
+                             QObject::tr("Enable or disable the trayicon"),
+                             QStringLiteral("bool"));
+    CommandOption autostartOption(
+      { "a", "autostart" },
+      QObject::tr("Enable or disable run at startup"),
+      QStringLiteral("bool"));
+    CommandOption showHelpOption(
+      { "s", "showhelp" },
+      QObject::tr("Show the help message in the capture mode"),
+      QStringLiteral("bool"));
+    CommandOption mainColorOption({ "m", "maincolor" },
+                                  QObject::tr("Define the main UI color"),
+                                  QStringLiteral("color-code"));
+    CommandOption contrastColorOption(
+      { "k", "contrastcolor" },
+      QObject::tr("Define the contrast UI color"),
+      QStringLiteral("color-code"));
+    CommandOption rawImageOption({ "r", "raw" },
+                                 QObject::tr("Print raw PNG capture"));
+    CommandOption screenNumberOption(
+      { "n", "number" },
+      QObject::tr("Define the screen to capture") + ",\n" +
+        QObject::tr("default: screen containing the cursor"),
+      QObject::tr("Screen number"),
+      QStringLiteral("-1"));
 
-  const QString delayErr =
-    QObject::tr("Invalid delay, it must be higher than 0");
-  const QString numberErr =
-    QObject::tr("Invalid screen number, it must be non negative");
-  auto numericChecker = [](const QString& delayValue) -> bool {
-    int value = delayValue.toInt();
-    return value >= 0;
-  };
+    // Add checkers
+    auto colorChecker = [](const QString& colorCode) -> bool {
+        QColor parsedColor(colorCode);
+        return parsedColor.isValid() && parsedColor.alphaF() == 1.0;
+    };
+    QString colorErr =
+      QObject::tr("Invalid color, "
+                  "this flag supports the following formats:\n"
+                  "- #RGB (each of R, G, and B is a single hex digit)\n"
+                  "- #RRGGBB\n- #RRRGGGBBB\n"
+                  "- #RRRRGGGGBBBB\n"
+                  "- Named colors like 'blue' or 'red'\n"
+                  "You may need to escape the '#' sign as in '\\#FFF'");
 
-  const QString pathErr =
-    QObject::tr("Invalid path, it must be a real path in the system");
-  auto pathChecker = [pathErr](const QString& pathValue) -> bool {
-    bool res = QDir(pathValue).exists();
-    if (!res) {
-      SystemNotification().sendMessage(QObject::tr(pathErr.toLatin1().data()));
-    }
-    return res;
-  };
+    const QString delayErr =
+      QObject::tr("Invalid delay, it must be higher than 0");
+    const QString numberErr =
+      QObject::tr("Invalid screen number, it must be non negative");
+    auto numericChecker = [](const QString& delayValue) -> bool {
+        int value = delayValue.toInt();
+        return value >= 0;
+    };
 
-  const QString booleanErr =
-    QObject::tr("Invalid value, it must be defined as 'true' or 'false'");
-  auto booleanChecker = [](const QString& value) -> bool {
-    return value == QLatin1String("true") || value == QLatin1String("false");
-  };
+    const QString pathErr =
+      QObject::tr("Invalid path, it must be a real path in the system");
+    auto pathChecker = [pathErr](const QString& pathValue) -> bool {
+        bool res = QDir(pathValue).exists();
+        if (!res) {
+            SystemNotification().sendMessage(
+              QObject::tr(pathErr.toLatin1().data()));
+        }
+        return res;
+    };
 
-  contrastColorOption.addChecker(colorChecker, colorErr);
-  mainColorOption.addChecker(colorChecker, colorErr);
-  delayOption.addChecker(numericChecker, delayErr);
-  pathOption.addChecker(pathChecker, pathErr);
-  trayOption.addChecker(booleanChecker, booleanErr);
-  autostartOption.addChecker(booleanChecker, booleanErr);
-  showHelpOption.addChecker(booleanChecker, booleanErr);
-  screenNumberOption.addChecker(numericChecker, numberErr);
+    const QString booleanErr =
+      QObject::tr("Invalid value, it must be defined as 'true' or 'false'");
+    auto booleanChecker = [](const QString& value) -> bool {
+        return value == QLatin1String("true") ||
+               value == QLatin1String("false");
+    };
 
-  // Relationships
-  parser.AddArgument(guiArgument);
-  parser.AddArgument(screenArgument);
-  parser.AddArgument(fullArgument);
-  parser.AddArgument(launcherArgument);
-  parser.AddArgument(configArgument);
-  auto helpOption = parser.addHelpOption();
-  auto versionOption = parser.addVersionOption();
-  parser.AddOptions({ pathOption, delayOption, rawImageOption }, guiArgument);
-  parser.AddOptions({ screenNumberOption,
-                      clipboardOption,
-                      pathOption,
-                      delayOption,
-                      rawImageOption },
-                    screenArgument);
-  parser.AddOptions(
-    { pathOption, clipboardOption, delayOption, rawImageOption }, fullArgument);
-  parser.AddOptions({ autostartOption,
-                      filenameOption,
-                      trayOption,
-                      showHelpOption,
-                      mainColorOption,
-                      contrastColorOption },
-                    configArgument);
-  // Parse
-  if (!parser.parse(app.arguments())) {
-    goto finish;
-  }
+    contrastColorOption.addChecker(colorChecker, colorErr);
+    mainColorOption.addChecker(colorChecker, colorErr);
+    delayOption.addChecker(numericChecker, delayErr);
+    pathOption.addChecker(pathChecker, pathErr);
+    trayOption.addChecker(booleanChecker, booleanErr);
+    autostartOption.addChecker(booleanChecker, booleanErr);
+    showHelpOption.addChecker(booleanChecker, booleanErr);
+    screenNumberOption.addChecker(numericChecker, numberErr);
 
-  // PROCESS DATA
-  //--------------
-  if (parser.isSet(helpOption) || parser.isSet(versionOption)) {
-  } else if (parser.isSet(launcherArgument)) { // LAUNCHER
-    QDBusMessage m =
-      QDBusMessage::createMethodCall(QStringLiteral("org.flameshot.Flameshot"),
-                                     QStringLiteral("/"),
-                                     QLatin1String(""),
-                                     QStringLiteral("openLauncher"));
-    QDBusConnection sessionBus = QDBusConnection::sessionBus();
-    if (!sessionBus.isConnected()) {
-      SystemNotification().sendMessage(
-        QObject::tr("Unable to connect via DBus"));
+    // Relationships
+    parser.AddArgument(guiArgument);
+    parser.AddArgument(screenArgument);
+    parser.AddArgument(fullArgument);
+    parser.AddArgument(launcherArgument);
+    parser.AddArgument(configArgument);
+    auto helpOption = parser.addHelpOption();
+    auto versionOption = parser.addVersionOption();
+    parser.AddOptions({ pathOption, delayOption, rawImageOption }, guiArgument);
+    parser.AddOptions({ screenNumberOption,
+                        clipboardOption,
+                        pathOption,
+                        delayOption,
+                        rawImageOption },
+                      screenArgument);
+    parser.AddOptions(
+      { pathOption, clipboardOption, delayOption, rawImageOption },
+      fullArgument);
+    parser.AddOptions({ autostartOption,
+                        filenameOption,
+                        trayOption,
+                        showHelpOption,
+                        mainColorOption,
+                        contrastColorOption },
+                      configArgument);
+    // Parse
+    if (!parser.parse(app.arguments())) {
+        goto finish;
     }
-    sessionBus.call(m);
-  } else if (parser.isSet(guiArgument)) { // GUI
-    QString pathValue = parser.value(pathOption);
-    int delay = parser.value(delayOption).toInt();
-    bool isRaw = parser.isSet(rawImageOption);
-    DBusUtils dbusUtils;
-    CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, pathValue);
-    uint id = req.id();
 
-    // Send message
-    QDBusMessage m =
-      QDBusMessage::createMethodCall(QStringLiteral("org.flameshot.Flameshot"),
-                                     QStringLiteral("/"),
-                                     QLatin1String(""),
-                                     QStringLiteral("graphicCapture"));
-    m << pathValue << delay << id;
-    QDBusConnection sessionBus = QDBusConnection::sessionBus();
-    dbusUtils.checkDBusConnection(sessionBus);
-    sessionBus.call(m);
+    // PROCESS DATA
+    //--------------
+    if (parser.isSet(helpOption) || parser.isSet(versionOption)) {
+    } else if (parser.isSet(launcherArgument)) { // LAUNCHER
+        QDBusMessage m = QDBusMessage::createMethodCall(
+          QStringLiteral("org.flameshot.Flameshot"),
+          QStringLiteral("/"),
+          QLatin1String(""),
+          QStringLiteral("openLauncher"));
+        QDBusConnection sessionBus = QDBusConnection::sessionBus();
+        if (!sessionBus.isConnected()) {
+            SystemNotification().sendMessage(
+              QObject::tr("Unable to connect via DBus"));
+        }
+        sessionBus.call(m);
+    } else if (parser.isSet(guiArgument)) { // GUI
+        QString pathValue = parser.value(pathOption);
+        int delay = parser.value(delayOption).toInt();
+        bool isRaw = parser.isSet(rawImageOption);
+        DBusUtils dbusUtils;
+        CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, pathValue);
+        uint id = req.id();
 
-    if (isRaw) {
-      dbusUtils.connectPrintCapture(sessionBus, id);
-      QTimer t;
-      t.setInterval(delay + 1000 * 60 * 15); // 15 minutes timeout
-      QObject::connect(&t, &QTimer::timeout, qApp, &QCoreApplication::quit);
-      t.start();
-      // wait
-      return app.exec();
-    }
-  } else if (parser.isSet(fullArgument)) { // FULL
-    QString pathValue = parser.value(pathOption);
-    int delay = parser.value(delayOption).toInt();
-    bool toClipboard = parser.isSet(clipboardOption);
-    bool isRaw = parser.isSet(rawImageOption);
-    // Not a valid command
-    if (!isRaw && !toClipboard && pathValue.isEmpty()) {
-      QTextStream out(stdout);
-      out << "Invalid format, set where to save the content with one of "
-          << "the following flags:\n "
-          << pathOption.dashedNames().join(QStringLiteral(", ")) << "\n "
-          << rawImageOption.dashedNames().join(QStringLiteral(", ")) << "\n "
-          << clipboardOption.dashedNames().join(QStringLiteral(", ")) << "\n\n";
-      parser.parse(QStringList() << argv[0] << QStringLiteral("full")
-                                 << QStringLiteral("-h"));
-      goto finish;
-    }
+        // Send message
+        QDBusMessage m = QDBusMessage::createMethodCall(
+          QStringLiteral("org.flameshot.Flameshot"),
+          QStringLiteral("/"),
+          QLatin1String(""),
+          QStringLiteral("graphicCapture"));
+        m << pathValue << delay << id;
+        QDBusConnection sessionBus = QDBusConnection::sessionBus();
+        dbusUtils.checkDBusConnection(sessionBus);
+        sessionBus.call(m);
 
-    CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay, pathValue);
-    if (toClipboard) {
-      req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
-    }
-    if (!pathValue.isEmpty()) {
-      req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
-    }
-    uint id = req.id();
-    DBusUtils dbusUtils;
+        if (isRaw) {
+            dbusUtils.connectPrintCapture(sessionBus, id);
+            QTimer t;
+            t.setInterval(delay + 1000 * 60 * 15); // 15 minutes timeout
+            QObject::connect(
+              &t, &QTimer::timeout, qApp, &QCoreApplication::quit);
+            t.start();
+            // wait
+            return app.exec();
+        }
+    } else if (parser.isSet(fullArgument)) { // FULL
+        QString pathValue = parser.value(pathOption);
+        int delay = parser.value(delayOption).toInt();
+        bool toClipboard = parser.isSet(clipboardOption);
+        bool isRaw = parser.isSet(rawImageOption);
+        // Not a valid command
+        if (!isRaw && !toClipboard && pathValue.isEmpty()) {
+            QTextStream out(stdout);
+            out << "Invalid format, set where to save the content with one of "
+                << "the following flags:\n "
+                << pathOption.dashedNames().join(QStringLiteral(", ")) << "\n "
+                << rawImageOption.dashedNames().join(QStringLiteral(", "))
+                << "\n "
+                << clipboardOption.dashedNames().join(QStringLiteral(", "))
+                << "\n\n";
+            parser.parse(QStringList() << argv[0] << QStringLiteral("full")
+                                       << QStringLiteral("-h"));
+            goto finish;
+        }
 
-    // Send message
-    QDBusMessage m =
-      QDBusMessage::createMethodCall(QStringLiteral("org.flameshot.Flameshot"),
-                                     QStringLiteral("/"),
-                                     QLatin1String(""),
-                                     QStringLiteral("fullScreen"));
-    m << pathValue << toClipboard << delay << id;
-    QDBusConnection sessionBus = QDBusConnection::sessionBus();
-    dbusUtils.checkDBusConnection(sessionBus);
-    sessionBus.call(m);
+        CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay, pathValue);
+        if (toClipboard) {
+            req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
+        }
+        if (!pathValue.isEmpty()) {
+            req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
+        }
+        uint id = req.id();
+        DBusUtils dbusUtils;
 
-    if (isRaw) {
-      dbusUtils.connectPrintCapture(sessionBus, id);
-      // timeout just in case
-      QTimer t;
-      t.setInterval(delay + 2000);
-      QObject::connect(&t, &QTimer::timeout, qApp, &QCoreApplication::quit);
-      t.start();
-      // wait
-      return app.exec();
-    }
-  } else if (parser.isSet(screenArgument)) { // SCREEN
-    QString numberStr = parser.value(screenNumberOption);
-    int number =
-      numberStr.startsWith(QLatin1String("-")) ? -1 : numberStr.toInt();
-    QString pathValue = parser.value(pathOption);
-    int delay = parser.value(delayOption).toInt();
-    bool toClipboard = parser.isSet(clipboardOption);
-    bool isRaw = parser.isSet(rawImageOption);
-    // Not a valid command
-    if (!isRaw && !toClipboard && pathValue.isEmpty()) {
-      QTextStream out(stdout);
-      out << "Invalid format, set where to save the content with one of "
-          << "the following flags:\n "
-          << pathOption.dashedNames().join(QStringLiteral(", ")) << "\n "
-          << rawImageOption.dashedNames().join(QStringLiteral(", ")) << "\n "
-          << clipboardOption.dashedNames().join(QStringLiteral(", ")) << "\n\n";
-      parser.parse(QStringList() << argv[0] << QStringLiteral("screen")
-                                 << QStringLiteral("-h"));
-      goto finish;
-    }
+        // Send message
+        QDBusMessage m = QDBusMessage::createMethodCall(
+          QStringLiteral("org.flameshot.Flameshot"),
+          QStringLiteral("/"),
+          QLatin1String(""),
+          QStringLiteral("fullScreen"));
+        m << pathValue << toClipboard << delay << id;
+        QDBusConnection sessionBus = QDBusConnection::sessionBus();
+        dbusUtils.checkDBusConnection(sessionBus);
+        sessionBus.call(m);
 
-    CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, pathValue, number);
-    if (toClipboard) {
-      req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
-    }
-    if (!pathValue.isEmpty()) {
-      req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
-    }
-    uint id = req.id();
-    DBusUtils dbusUtils;
+        if (isRaw) {
+            dbusUtils.connectPrintCapture(sessionBus, id);
+            // timeout just in case
+            QTimer t;
+            t.setInterval(delay + 2000);
+            QObject::connect(
+              &t, &QTimer::timeout, qApp, &QCoreApplication::quit);
+            t.start();
+            // wait
+            return app.exec();
+        }
+    } else if (parser.isSet(screenArgument)) { // SCREEN
+        QString numberStr = parser.value(screenNumberOption);
+        int number =
+          numberStr.startsWith(QLatin1String("-")) ? -1 : numberStr.toInt();
+        QString pathValue = parser.value(pathOption);
+        int delay = parser.value(delayOption).toInt();
+        bool toClipboard = parser.isSet(clipboardOption);
+        bool isRaw = parser.isSet(rawImageOption);
+        // Not a valid command
+        if (!isRaw && !toClipboard && pathValue.isEmpty()) {
+            QTextStream out(stdout);
+            out << "Invalid format, set where to save the content with one of "
+                << "the following flags:\n "
+                << pathOption.dashedNames().join(QStringLiteral(", ")) << "\n "
+                << rawImageOption.dashedNames().join(QStringLiteral(", "))
+                << "\n "
+                << clipboardOption.dashedNames().join(QStringLiteral(", "))
+                << "\n\n";
+            parser.parse(QStringList() << argv[0] << QStringLiteral("screen")
+                                       << QStringLiteral("-h"));
+            goto finish;
+        }
 
-    // Send message
-    QDBusMessage m =
-      QDBusMessage::createMethodCall(QStringLiteral("org.flameshot.Flameshot"),
-                                     QStringLiteral("/"),
-                                     QLatin1String(""),
-                                     QStringLiteral("captureScreen"));
-    m << number << pathValue << toClipboard << delay << id;
-    QDBusConnection sessionBus = QDBusConnection::sessionBus();
-    dbusUtils.checkDBusConnection(sessionBus);
-    sessionBus.call(m);
+        CaptureRequest req(
+          CaptureRequest::SCREEN_MODE, delay, pathValue, number);
+        if (toClipboard) {
+            req.addTask(CaptureRequest::CLIPBOARD_SAVE_TASK);
+        }
+        if (!pathValue.isEmpty()) {
+            req.addTask(CaptureRequest::FILESYSTEM_SAVE_TASK);
+        }
+        uint id = req.id();
+        DBusUtils dbusUtils;
 
-    if (isRaw) {
-      dbusUtils.connectPrintCapture(sessionBus, id);
-      // timeout just in case
-      QTimer t;
-      t.setInterval(delay + 2000);
-      QObject::connect(&t, &QTimer::timeout, qApp, &QCoreApplication::quit);
-      t.start();
-      // wait
-      return app.exec();
-    }
-  } else if (parser.isSet(configArgument)) { // CONFIG
-    bool autostart = parser.isSet(autostartOption);
-    bool filename = parser.isSet(filenameOption);
-    bool tray = parser.isSet(trayOption);
-    bool help = parser.isSet(showHelpOption);
-    bool mainColor = parser.isSet(mainColorOption);
-    bool contrastColor = parser.isSet(contrastColorOption);
-    bool someFlagSet = (filename || tray || help || mainColor || contrastColor);
-    ConfigHandler config;
-    if (autostart) {
-      QDBusMessage m = QDBusMessage::createMethodCall(
-        QStringLiteral("org.flameshot.Flameshot"),
-        QStringLiteral("/"),
-        QLatin1String(""),
-        QStringLiteral("autostartEnabled"));
-      if (parser.value(autostartOption) == QLatin1String("false")) {
-        m << false;
-      } else if (parser.value(autostartOption) == QLatin1String("true")) {
-        m << true;
-      }
-      QDBusConnection sessionBus = QDBusConnection::sessionBus();
-      if (!sessionBus.isConnected()) {
-        SystemNotification().sendMessage(
-          QObject::tr("Unable to connect via DBus"));
-      }
-      sessionBus.call(m);
-    }
-    if (filename) {
-      QString newFilename(parser.value(filenameOption));
-      config.setFilenamePattern(newFilename);
-      FileNameHandler fh;
-      QTextStream(stdout) << QStringLiteral("The new pattern is '%1'\n"
-                                            "Parsed pattern example: %2\n")
-                               .arg(newFilename)
-                               .arg(fh.parsedPattern());
-    }
-    if (tray) {
-      QDBusMessage m = QDBusMessage::createMethodCall(
-        QStringLiteral("org.flameshot.Flameshot"),
-        QStringLiteral("/"),
-        QLatin1String(""),
-        QStringLiteral("trayIconEnabled"));
-      if (parser.value(trayOption) == QLatin1String("false")) {
-        m << false;
-      } else if (parser.value(trayOption) == QLatin1String("true")) {
-        m << true;
-      }
-      QDBusConnection sessionBus = QDBusConnection::sessionBus();
-      if (!sessionBus.isConnected()) {
-        SystemNotification().sendMessage(
-          QObject::tr("Unable to connect via DBus"));
-      }
-      sessionBus.call(m);
-    }
-    if (help) {
-      if (parser.value(showHelpOption) == QLatin1String("false")) {
-        config.setShowHelp(false);
-      } else if (parser.value(showHelpOption) == QLatin1String("true")) {
-        config.setShowHelp(true);
-      }
-    }
-    if (mainColor) {
-      QString colorCode = parser.value(mainColorOption);
-      QColor parsedColor(colorCode);
-      config.setUIMainColor(parsedColor);
-    }
-    if (contrastColor) {
-      QString colorCode = parser.value(contrastColorOption);
-      QColor parsedColor(colorCode);
-      config.setUIContrastColor(parsedColor);
-    }
+        // Send message
+        QDBusMessage m = QDBusMessage::createMethodCall(
+          QStringLiteral("org.flameshot.Flameshot"),
+          QStringLiteral("/"),
+          QLatin1String(""),
+          QStringLiteral("captureScreen"));
+        m << number << pathValue << toClipboard << delay << id;
+        QDBusConnection sessionBus = QDBusConnection::sessionBus();
+        dbusUtils.checkDBusConnection(sessionBus);
+        sessionBus.call(m);
+
+        if (isRaw) {
+            dbusUtils.connectPrintCapture(sessionBus, id);
+            // timeout just in case
+            QTimer t;
+            t.setInterval(delay + 2000);
+            QObject::connect(
+              &t, &QTimer::timeout, qApp, &QCoreApplication::quit);
+            t.start();
+            // wait
+            return app.exec();
+        }
+    } else if (parser.isSet(configArgument)) { // CONFIG
+        bool autostart = parser.isSet(autostartOption);
+        bool filename = parser.isSet(filenameOption);
+        bool tray = parser.isSet(trayOption);
+        bool help = parser.isSet(showHelpOption);
+        bool mainColor = parser.isSet(mainColorOption);
+        bool contrastColor = parser.isSet(contrastColorOption);
+        bool someFlagSet =
+          (filename || tray || help || mainColor || contrastColor);
+        ConfigHandler config;
+        if (autostart) {
+            QDBusMessage m = QDBusMessage::createMethodCall(
+              QStringLiteral("org.flameshot.Flameshot"),
+              QStringLiteral("/"),
+              QLatin1String(""),
+              QStringLiteral("autostartEnabled"));
+            if (parser.value(autostartOption) == QLatin1String("false")) {
+                m << false;
+            } else if (parser.value(autostartOption) == QLatin1String("true")) {
+                m << true;
+            }
+            QDBusConnection sessionBus = QDBusConnection::sessionBus();
+            if (!sessionBus.isConnected()) {
+                SystemNotification().sendMessage(
+                  QObject::tr("Unable to connect via DBus"));
+            }
+            sessionBus.call(m);
+        }
+        if (filename) {
+            QString newFilename(parser.value(filenameOption));
+            config.setFilenamePattern(newFilename);
+            FileNameHandler fh;
+            QTextStream(stdout)
+              << QStringLiteral("The new pattern is '%1'\n"
+                                "Parsed pattern example: %2\n")
+                   .arg(newFilename)
+                   .arg(fh.parsedPattern());
+        }
+        if (tray) {
+            QDBusMessage m = QDBusMessage::createMethodCall(
+              QStringLiteral("org.flameshot.Flameshot"),
+              QStringLiteral("/"),
+              QLatin1String(""),
+              QStringLiteral("trayIconEnabled"));
+            if (parser.value(trayOption) == QLatin1String("false")) {
+                m << false;
+            } else if (parser.value(trayOption) == QLatin1String("true")) {
+                m << true;
+            }
+            QDBusConnection sessionBus = QDBusConnection::sessionBus();
+            if (!sessionBus.isConnected()) {
+                SystemNotification().sendMessage(
+                  QObject::tr("Unable to connect via DBus"));
+            }
+            sessionBus.call(m);
+        }
+        if (help) {
+            if (parser.value(showHelpOption) == QLatin1String("false")) {
+                config.setShowHelp(false);
+            } else if (parser.value(showHelpOption) == QLatin1String("true")) {
+                config.setShowHelp(true);
+            }
+        }
+        if (mainColor) {
+            QString colorCode = parser.value(mainColorOption);
+            QColor parsedColor(colorCode);
+            config.setUIMainColor(parsedColor);
+        }
+        if (contrastColor) {
+            QString colorCode = parser.value(contrastColorOption);
+            QColor parsedColor(colorCode);
+            config.setUIContrastColor(parsedColor);
+        }
 
-    // Open gui when no options
-    if (!someFlagSet) {
-      QDBusMessage m = QDBusMessage::createMethodCall(
-        QStringLiteral("org.flameshot.Flameshot"),
-        QStringLiteral("/"),
-        QLatin1String(""),
-        QStringLiteral("openConfig"));
-      QDBusConnection sessionBus = QDBusConnection::sessionBus();
-      if (!sessionBus.isConnected()) {
-        SystemNotification().sendMessage(
-          QObject::tr("Unable to connect via DBus"));
-      }
-      sessionBus.call(m);
+        // Open gui when no options
+        if (!someFlagSet) {
+            QDBusMessage m = QDBusMessage::createMethodCall(
+              QStringLiteral("org.flameshot.Flameshot"),
+              QStringLiteral("/"),
+              QLatin1String(""),
+              QStringLiteral("openConfig"));
+            QDBusConnection sessionBus = QDBusConnection::sessionBus();
+            if (!sessionBus.isConnected()) {
+                SystemNotification().sendMessage(
+                  QObject::tr("Unable to connect via DBus"));
+            }
+            sessionBus.call(m);
+        }
     }
-  }
 finish:
 
 #endif
-  return 0;
+    return 0;
 }
diff --git a/src/tools/abstractactiontool.cpp b/src/tools/abstractactiontool.cpp
index 2ea69dc3..bc5dc391 100644
--- a/src/tools/abstractactiontool.cpp
+++ b/src/tools/abstractactiontool.cpp
@@ -21,74 +21,63 @@ AbstractActionTool::AbstractActionTool(QObject* parent)
   : CaptureTool(parent)
 {}
 
-bool
-AbstractActionTool::isValid() const
+bool AbstractActionTool::isValid() const
 {
-  return true;
+    return true;
 }
 
-bool
-AbstractActionTool::isSelectable() const
+bool AbstractActionTool::isSelectable() const
 {
-  return false;
+    return false;
 }
 
-bool
-AbstractActionTool::showMousePreview() const
+bool AbstractActionTool::showMousePreview() const
 {
-  return false;
+    return false;
 }
 
-void
-AbstractActionTool::undo(QPixmap& pixmap)
+void AbstractActionTool::undo(QPixmap& pixmap)
 {
-  Q_UNUSED(pixmap);
+    Q_UNUSED(pixmap);
 }
 
-void
-AbstractActionTool::process(QPainter& painter,
-                            const QPixmap& pixmap,
-                            bool recordUndo)
+void AbstractActionTool::process(QPainter& painter,
+                                 const QPixmap& pixmap,
+                                 bool recordUndo)
 {
-  Q_UNUSED(painter);
-  Q_UNUSED(pixmap);
-  Q_UNUSED(recordUndo);
+    Q_UNUSED(painter);
+    Q_UNUSED(pixmap);
+    Q_UNUSED(recordUndo);
 }
 
-void
-AbstractActionTool::paintMousePreview(QPainter& painter,
-                                      const CaptureContext& context)
+void AbstractActionTool::paintMousePreview(QPainter& painter,
+                                           const CaptureContext& context)
 {
-  Q_UNUSED(painter);
-  Q_UNUSED(context);
+    Q_UNUSED(painter);
+    Q_UNUSED(context);
 }
 
-void
-AbstractActionTool::drawEnd(const QPoint& p)
+void AbstractActionTool::drawEnd(const QPoint& p)
 {
-  Q_UNUSED(p);
+    Q_UNUSED(p);
 }
 
-void
-AbstractActionTool::drawMove(const QPoint& p)
+void AbstractActionTool::drawMove(const QPoint& p)
 {
-  Q_UNUSED(p);
+    Q_UNUSED(p);
 }
 
-void
-AbstractActionTool::drawStart(const CaptureContext& context)
+void AbstractActionTool::drawStart(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
 
-void
-AbstractActionTool::colorChanged(const QColor& c)
+void AbstractActionTool::colorChanged(const QColor& c)
 {
-  Q_UNUSED(c);
+    Q_UNUSED(c);
 }
 
-void
-AbstractActionTool::thicknessChanged(const int th)
+void AbstractActionTool::thicknessChanged(const int th)
 {
-  Q_UNUSED(th);
+    Q_UNUSED(th);
 }
diff --git a/src/tools/abstractactiontool.h b/src/tools/abstractactiontool.h
index d8144adb..0c973c91 100644
--- a/src/tools/abstractactiontool.h
+++ b/src/tools/abstractactiontool.h
@@ -21,28 +21,28 @@
 
 class AbstractActionTool : public CaptureTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit AbstractActionTool(QObject* parent = nullptr);
+    explicit AbstractActionTool(QObject* parent = nullptr);
 
-  bool isValid() const override;
-  bool isSelectable() const override;
-  bool showMousePreview() const override;
+    bool isValid() const override;
+    bool isSelectable() const override;
+    bool showMousePreview() const override;
 
-  void undo(QPixmap& pixmap) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    void undo(QPixmap& pixmap) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  virtual ToolType nameID() const = 0;
+    virtual ToolType nameID() const = 0;
 
 public slots:
-  void drawEnd(const QPoint& p) override;
-  void drawMove(const QPoint& p) override;
-  void drawStart(const CaptureContext& context) override;
-  void colorChanged(const QColor& c) override;
-  void thicknessChanged(const int th) override;
+    void drawEnd(const QPoint& p) override;
+    void drawMove(const QPoint& p) override;
+    void drawStart(const CaptureContext& context) override;
+    void colorChanged(const QColor& c) override;
+    void thicknessChanged(const int th) override;
 };
diff --git a/src/tools/abstractpathtool.cpp b/src/tools/abstractpathtool.cpp
index 2ea55b3a..67a8b6d2 100644
--- a/src/tools/abstractpathtool.cpp
+++ b/src/tools/abstractpathtool.cpp
@@ -23,83 +23,72 @@ AbstractPathTool::AbstractPathTool(QObject* parent)
   , m_padding(0)
 {}
 
-bool
-AbstractPathTool::isValid() const
+bool AbstractPathTool::isValid() const
 {
-  return m_points.length() > 1;
+    return m_points.length() > 1;
 }
 
-bool
-AbstractPathTool::closeOnButtonPressed() const
+bool AbstractPathTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-bool
-AbstractPathTool::isSelectable() const
+bool AbstractPathTool::isSelectable() const
 {
-  return true;
+    return true;
 }
 
-bool
-AbstractPathTool::showMousePreview() const
+bool AbstractPathTool::showMousePreview() const
 {
-  return true;
+    return true;
 }
 
-void
-AbstractPathTool::undo(QPixmap& pixmap)
+void AbstractPathTool::undo(QPixmap& pixmap)
 {
-  QPainter p(&pixmap);
-  const int val = m_thickness + m_padding;
-  QRect area = m_backupArea + QMargins(val, val, val, val);
-  p.drawPixmap(area.intersected(pixmap.rect()).topLeft(), m_pixmapBackup);
+    QPainter p(&pixmap);
+    const int val = m_thickness + m_padding;
+    QRect area = m_backupArea + QMargins(val, val, val, val);
+    p.drawPixmap(area.intersected(pixmap.rect()).topLeft(), m_pixmapBackup);
 }
 
-void
-AbstractPathTool::drawEnd(const QPoint& p)
+void AbstractPathTool::drawEnd(const QPoint& p)
 {
-  Q_UNUSED(p);
+    Q_UNUSED(p);
 }
 
-void
-AbstractPathTool::drawMove(const QPoint& p)
+void AbstractPathTool::drawMove(const QPoint& p)
 {
-  addPoint(p);
+    addPoint(p);
 }
 
-void
-AbstractPathTool::colorChanged(const QColor& c)
+void AbstractPathTool::colorChanged(const QColor& c)
 {
-  m_color = c;
+    m_color = c;
 }
 
-void
-AbstractPathTool::thicknessChanged(const int th)
+void AbstractPathTool::thicknessChanged(const int th)
 {
-  m_thickness = th;
+    m_thickness = th;
 }
 
-void
-AbstractPathTool::updateBackup(const QPixmap& pixmap)
+void AbstractPathTool::updateBackup(const QPixmap& pixmap)
 {
-  const int val = m_thickness + m_padding;
-  QRect area = m_backupArea.normalized() + QMargins(val, val, val, val);
-  m_pixmapBackup = pixmap.copy(area);
+    const int val = m_thickness + m_padding;
+    QRect area = m_backupArea.normalized() + QMargins(val, val, val, val);
+    m_pixmapBackup = pixmap.copy(area);
 }
 
-void
-AbstractPathTool::addPoint(const QPoint& point)
+void AbstractPathTool::addPoint(const QPoint& point)
 {
-  if (m_backupArea.left() > point.x()) {
-    m_backupArea.setLeft(point.x());
-  } else if (m_backupArea.right() < point.x()) {
-    m_backupArea.setRight(point.x());
-  }
-  if (m_backupArea.top() > point.y()) {
-    m_backupArea.setTop(point.y());
-  } else if (m_backupArea.bottom() < point.y()) {
-    m_backupArea.setBottom(point.y());
-  }
-  m_points.append(point);
+    if (m_backupArea.left() > point.x()) {
+        m_backupArea.setLeft(point.x());
+    } else if (m_backupArea.right() < point.x()) {
+        m_backupArea.setRight(point.x());
+    }
+    if (m_backupArea.top() > point.y()) {
+        m_backupArea.setTop(point.y());
+    } else if (m_backupArea.bottom() < point.y()) {
+        m_backupArea.setBottom(point.y());
+    }
+    m_points.append(point);
 }
diff --git a/src/tools/abstractpathtool.h b/src/tools/abstractpathtool.h
index a5c7a58c..f1f4cfe3 100644
--- a/src/tools/abstractpathtool.h
+++ b/src/tools/abstractpathtool.h
@@ -21,34 +21,34 @@
 
 class AbstractPathTool : public CaptureTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit AbstractPathTool(QObject* parent = nullptr);
+    explicit AbstractPathTool(QObject* parent = nullptr);
 
-  bool isValid() const override;
-  bool closeOnButtonPressed() const override;
-  bool isSelectable() const override;
-  bool showMousePreview() const override;
+    bool isValid() const override;
+    bool closeOnButtonPressed() const override;
+    bool isSelectable() const override;
+    bool showMousePreview() const override;
 
-  void undo(QPixmap& pixmap) override;
+    void undo(QPixmap& pixmap) override;
 
 public slots:
-  void drawEnd(const QPoint& p) override;
-  void drawMove(const QPoint& p) override;
-  void colorChanged(const QColor& c) override;
-  void thicknessChanged(const int th) override;
+    void drawEnd(const QPoint& p) override;
+    void drawMove(const QPoint& p) override;
+    void colorChanged(const QColor& c) override;
+    void thicknessChanged(const int th) override;
 
 protected:
-  void updateBackup(const QPixmap& pixmap);
-  void addPoint(const QPoint& point);
-
-  virtual ToolType nameID() const = 0;
-
-  QPixmap m_pixmapBackup;
-  QRect m_backupArea;
-  QColor m_color;
-  QVector<QPoint> m_points;
-  int m_thickness;
-  // use m_padding to extend the area of the backup
-  int m_padding;
+    void updateBackup(const QPixmap& pixmap);
+    void addPoint(const QPoint& point);
+
+    virtual ToolType nameID() const = 0;
+
+    QPixmap m_pixmapBackup;
+    QRect m_backupArea;
+    QColor m_color;
+    QVector<QPoint> m_points;
+    int m_thickness;
+    // use m_padding to extend the area of the backup
+    int m_padding;
 };
diff --git a/src/tools/abstracttwopointtool.cpp b/src/tools/abstracttwopointtool.cpp
index 7a4463b1..ab54291a 100644
--- a/src/tools/abstracttwopointtool.cpp
+++ b/src/tools/abstracttwopointtool.cpp
@@ -25,10 +25,10 @@ const int DIRS_NUMBER = 4;
 
 enum UNIT
 {
-  HORIZ_DIR = 0,
-  DIAG1_DIR = 1,
-  VERT_DIR = 2,
-  DIAG2_DIR = 3
+    HORIZ_DIR = 0,
+    DIAG1_DIR = 1,
+    VERT_DIR = 2,
+    DIAG2_DIR = 3
 };
 
 const double ADJ_DIAG_UNIT = 2 * ADJ_UNIT;
@@ -36,8 +36,8 @@ const int DIAG_DIRS_NUMBER = 2;
 
 enum DIAG_UNIT
 {
-  DIR1 = 0,
-  DIR2 = 1
+    DIR1 = 0,
+    DIR2 = 1
 };
 
 }
@@ -48,123 +48,111 @@ AbstractTwoPointTool::AbstractTwoPointTool(QObject* parent)
   , m_padding(0)
 {}
 
-bool
-AbstractTwoPointTool::isValid() const
+bool AbstractTwoPointTool::isValid() const
 {
-  return (m_points.first != m_points.second);
+    return (m_points.first != m_points.second);
 }
 
-bool
-AbstractTwoPointTool::closeOnButtonPressed() const
+bool AbstractTwoPointTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-bool
-AbstractTwoPointTool::isSelectable() const
+bool AbstractTwoPointTool::isSelectable() const
 {
-  return true;
+    return true;
 }
 
-bool
-AbstractTwoPointTool::showMousePreview() const
+bool AbstractTwoPointTool::showMousePreview() const
 {
-  return true;
+    return true;
 }
 
-void
-AbstractTwoPointTool::undo(QPixmap& pixmap)
+void AbstractTwoPointTool::undo(QPixmap& pixmap)
 {
-  QPainter p(&pixmap);
-  p.drawPixmap(backupRect(pixmap.rect()).topLeft(), m_pixmapBackup);
-  if (this->nameID() == ToolType::CIRCLECOUNT) {
-    emit requestAction(REQ_DECREMENT_CIRCLE_COUNT);
-  }
+    QPainter p(&pixmap);
+    p.drawPixmap(backupRect(pixmap.rect()).topLeft(), m_pixmapBackup);
+    if (this->nameID() == ToolType::CIRCLECOUNT) {
+        emit requestAction(REQ_DECREMENT_CIRCLE_COUNT);
+    }
 }
 
-void
-AbstractTwoPointTool::drawEnd(const QPoint& p)
+void AbstractTwoPointTool::drawEnd(const QPoint& p)
 {
-  Q_UNUSED(p);
+    Q_UNUSED(p);
 }
 
-void
-AbstractTwoPointTool::drawMove(const QPoint& p)
+void AbstractTwoPointTool::drawMove(const QPoint& p)
 {
-  m_points.second = p;
+    m_points.second = p;
 }
 
-void
-AbstractTwoPointTool::drawMoveWithAdjustment(const QPoint& p)
+void AbstractTwoPointTool::drawMoveWithAdjustment(const QPoint& p)
 {
-  m_points.second = m_points.first + adjustedVector(p - m_points.first);
+    m_points.second = m_points.first + adjustedVector(p - m_points.first);
 }
 
-void
-AbstractTwoPointTool::colorChanged(const QColor& c)
+void AbstractTwoPointTool::colorChanged(const QColor& c)
 {
-  m_color = c;
+    m_color = c;
 }
 
-void
-AbstractTwoPointTool::thicknessChanged(const int th)
+void AbstractTwoPointTool::thicknessChanged(const int th)
 {
-  m_thickness = th;
+    m_thickness = th;
 }
 
-void
-AbstractTwoPointTool::updateBackup(const QPixmap& pixmap)
+void AbstractTwoPointTool::updateBackup(const QPixmap& pixmap)
 {
-  m_pixmapBackup = pixmap.copy(backupRect(pixmap.rect()));
+    m_pixmapBackup = pixmap.copy(backupRect(pixmap.rect()));
 }
 
-QRect
-AbstractTwoPointTool::backupRect(const QRect& limits) const
+QRect AbstractTwoPointTool::backupRect(const QRect& limits) const
 {
-  QRect r = QRect(m_points.first, m_points.second).normalized();
-  const int val = m_thickness + m_padding;
-  r += QMargins(val, val, val, val);
-  return r.intersected(limits);
+    QRect r = QRect(m_points.first, m_points.second).normalized();
+    const int val = m_thickness + m_padding;
+    r += QMargins(val, val, val, val);
+    return r.intersected(limits);
 }
 
-QPoint
-AbstractTwoPointTool::adjustedVector(QPoint v) const
+QPoint AbstractTwoPointTool::adjustedVector(QPoint v) const
 {
-  if (m_supportsOrthogonalAdj && m_supportsDiagonalAdj) {
-    int dir =
-      (static_cast<int>(round(atan2(-v.y(), v.x()) / ADJ_UNIT)) + DIRS_NUMBER) %
-      DIRS_NUMBER;
-    if (dir == UNIT::HORIZ_DIR) {
-      v.setY(0);
-    } else if (dir == UNIT::VERT_DIR) {
-      v.setX(0);
-    } else if (dir == UNIT::DIAG1_DIR) {
-      int newX = (v.x() - v.y()) / 2;
-      int newY = -newX;
-      v.setX(newX);
-      v.setY(newY);
-    } else {
-      int newX = (v.x() + v.y()) / 2;
-      int newY = newX;
-      v.setX(newX);
-      v.setY(newY);
-    }
-  } else if (m_supportsDiagonalAdj) {
-    int dir = (static_cast<int>(round(
-                 (atan2(-v.y(), v.x()) - ADJ_DIAG_UNIT / 2) / ADJ_DIAG_UNIT)) +
-               DIAG_DIRS_NUMBER) %
-              DIAG_DIRS_NUMBER;
-    if (dir == DIAG_UNIT::DIR1) {
-      int newX = (v.x() - v.y()) / 2;
-      int newY = -newX;
-      v.setX(newX);
-      v.setY(newY);
-    } else {
-      int newX = (v.x() + v.y()) / 2;
-      int newY = newX;
-      v.setX(newX);
-      v.setY(newY);
+    if (m_supportsOrthogonalAdj && m_supportsDiagonalAdj) {
+        int dir = (static_cast<int>(round(atan2(-v.y(), v.x()) / ADJ_UNIT)) +
+                   DIRS_NUMBER) %
+                  DIRS_NUMBER;
+        if (dir == UNIT::HORIZ_DIR) {
+            v.setY(0);
+        } else if (dir == UNIT::VERT_DIR) {
+            v.setX(0);
+        } else if (dir == UNIT::DIAG1_DIR) {
+            int newX = (v.x() - v.y()) / 2;
+            int newY = -newX;
+            v.setX(newX);
+            v.setY(newY);
+        } else {
+            int newX = (v.x() + v.y()) / 2;
+            int newY = newX;
+            v.setX(newX);
+            v.setY(newY);
+        }
+    } else if (m_supportsDiagonalAdj) {
+        int dir =
+          (static_cast<int>(round((atan2(-v.y(), v.x()) - ADJ_DIAG_UNIT / 2) /
+                                  ADJ_DIAG_UNIT)) +
+           DIAG_DIRS_NUMBER) %
+          DIAG_DIRS_NUMBER;
+        if (dir == DIAG_UNIT::DIR1) {
+            int newX = (v.x() - v.y()) / 2;
+            int newY = -newX;
+            v.setX(newX);
+            v.setY(newY);
+        } else {
+            int newX = (v.x() + v.y()) / 2;
+            int newY = newX;
+            v.setX(newX);
+            v.setY(newY);
+        }
     }
-  }
-  return v;
+    return v;
 }
diff --git a/src/tools/abstracttwopointtool.h b/src/tools/abstracttwopointtool.h
index f6200ea9..061807a9 100644
--- a/src/tools/abstracttwopointtool.h
+++ b/src/tools/abstracttwopointtool.h
@@ -21,40 +21,40 @@
 
 class AbstractTwoPointTool : public CaptureTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit AbstractTwoPointTool(QObject* parent = nullptr);
+    explicit AbstractTwoPointTool(QObject* parent = nullptr);
 
-  bool isValid() const override;
-  bool closeOnButtonPressed() const override;
-  bool isSelectable() const override;
-  bool showMousePreview() const override;
+    bool isValid() const override;
+    bool closeOnButtonPressed() const override;
+    bool isSelectable() const override;
+    bool showMousePreview() const override;
 
-  void undo(QPixmap& pixmap) override;
+    void undo(QPixmap& pixmap) override;
 
 public slots:
-  void drawEnd(const QPoint& p) override;
-  void drawMove(const QPoint& p) override;
-  void drawMoveWithAdjustment(const QPoint& p) override;
-  void colorChanged(const QColor& c) override;
-  void thicknessChanged(const int th) override;
+    void drawEnd(const QPoint& p) override;
+    void drawMove(const QPoint& p) override;
+    void drawMoveWithAdjustment(const QPoint& p) override;
+    void colorChanged(const QColor& c) override;
+    void thicknessChanged(const int th) override;
 
 protected:
-  void updateBackup(const QPixmap& pixmap);
-  QRect backupRect(const QRect& limits) const;
+    void updateBackup(const QPixmap& pixmap);
+    QRect backupRect(const QRect& limits) const;
 
-  QPixmap m_pixmapBackup;
-  QPair<QPoint, QPoint> m_points;
-  QColor m_color;
-  int m_thickness;
-  // use m_padding to extend the area of the backup
-  int m_padding;
+    QPixmap m_pixmapBackup;
+    QPair<QPoint, QPoint> m_points;
+    QColor m_color;
+    int m_thickness;
+    // use m_padding to extend the area of the backup
+    int m_padding;
 
-  bool m_supportsOrthogonalAdj = false;
-  bool m_supportsDiagonalAdj = false;
+    bool m_supportsOrthogonalAdj = false;
+    bool m_supportsDiagonalAdj = false;
 
-  virtual ToolType nameID() const = 0;
+    virtual ToolType nameID() const = 0;
 
 private:
-  QPoint adjustedVector(QPoint v) const;
+    QPoint adjustedVector(QPoint v) const;
 };
diff --git a/src/tools/arrow/arrowtool.cpp b/src/tools/arrow/arrowtool.cpp
index bf2a859a..7c31f131 100644
--- a/src/tools/arrow/arrowtool.cpp
+++ b/src/tools/arrow/arrowtool.cpp
@@ -24,50 +24,48 @@ namespace {
 const int ArrowWidth = 10;
 const int ArrowHeight = 18;
 
-QPainterPath
-getArrowHead(QPoint p1, QPoint p2, const int thickness)
+QPainterPath getArrowHead(QPoint p1, QPoint p2, const int thickness)
 {
-  QLineF base(p1, p2);
-  // Create the vector for the position of the base  of the arrowhead
-  QLineF temp(QPoint(0, 0), p2 - p1);
-  int val = ArrowHeight + thickness * 4;
-  if (base.length() < val) {
-    val = (base.length() + thickness * 2);
-  }
-  temp.setLength(base.length() + thickness * 2 - val);
-  // Move across the line up to the head
-  QPointF bottonTranslation(temp.p2());
-
-  // Rotate base of the arrowhead
-  base.setLength(ArrowWidth + thickness * 2);
-  base.setAngle(base.angle() + 90);
-  // Move to the correct point
-  QPointF temp2 = p1 - base.p2();
-  // Center it
-  QPointF centerTranslation((temp2.x() / 2), (temp2.y() / 2));
-
-  base.translate(bottonTranslation);
-  base.translate(centerTranslation);
-
-  QPainterPath path;
-  path.moveTo(p2);
-  path.lineTo(base.p1());
-  path.lineTo(base.p2());
-  path.lineTo(p2);
-  return path;
+    QLineF base(p1, p2);
+    // Create the vector for the position of the base  of the arrowhead
+    QLineF temp(QPoint(0, 0), p2 - p1);
+    int val = ArrowHeight + thickness * 4;
+    if (base.length() < val) {
+        val = (base.length() + thickness * 2);
+    }
+    temp.setLength(base.length() + thickness * 2 - val);
+    // Move across the line up to the head
+    QPointF bottonTranslation(temp.p2());
+
+    // Rotate base of the arrowhead
+    base.setLength(ArrowWidth + thickness * 2);
+    base.setAngle(base.angle() + 90);
+    // Move to the correct point
+    QPointF temp2 = p1 - base.p2();
+    // Center it
+    QPointF centerTranslation((temp2.x() / 2), (temp2.y() / 2));
+
+    base.translate(bottonTranslation);
+    base.translate(centerTranslation);
+
+    QPainterPath path;
+    path.moveTo(p2);
+    path.lineTo(base.p1());
+    path.lineTo(base.p2());
+    path.lineTo(p2);
+    return path;
 }
 
 // gets a shorter line to prevent overlap in the point of the arrow
-QLine
-getShorterLine(QPoint p1, QPoint p2, const int thickness)
+QLine getShorterLine(QPoint p1, QPoint p2, const int thickness)
 {
-  QLineF l(p1, p2);
-  int val = ArrowHeight + thickness * 4;
-  if (l.length() < val) {
-    val = (l.length() + thickness * 2);
-  }
-  l.setLength(l.length() + thickness * 2 - val);
-  return l.toLine();
+    QLineF l(p1, p2);
+    int val = ArrowHeight + thickness * 4;
+    if (l.length() < val) {
+        val = (l.length() + thickness * 2);
+    }
+    l.setLength(l.length() + thickness * 2 - val);
+    return l.toLine();
 }
 
 } // unnamed namespace
@@ -75,72 +73,66 @@ getShorterLine(QPoint p1, QPoint p2, const int thickness)
 ArrowTool::ArrowTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_padding = ArrowWidth / 2;
-  m_supportsOrthogonalAdj = true;
-  m_supportsDiagonalAdj = true;
+    m_padding = ArrowWidth / 2;
+    m_supportsOrthogonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-QIcon
-ArrowTool::icon(const QColor& background, bool inEditor) const
+QIcon ArrowTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "arrow-bottom-left.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "arrow-bottom-left.svg");
 }
-QString
-ArrowTool::name() const
+QString ArrowTool::name() const
 {
-  return tr("Arrow");
+    return tr("Arrow");
 }
 
-ToolType
-ArrowTool::nameID() const
+ToolType ArrowTool::nameID() const
 {
-  return ToolType::ARROW;
+    return ToolType::ARROW;
 }
 
-QString
-ArrowTool::description() const
+QString ArrowTool::description() const
 {
-  return tr("Set the Arrow as the paint tool");
+    return tr("Set the Arrow as the paint tool");
 }
 
-CaptureTool*
-ArrowTool::copy(QObject* parent)
+CaptureTool* ArrowTool::copy(QObject* parent)
 {
-  return new ArrowTool(parent);
+    return new ArrowTool(parent);
 }
 
-void
-ArrowTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void ArrowTool::process(QPainter& painter,
+                        const QPixmap& pixmap,
+                        bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawLine(
-    getShorterLine(m_points.first, m_points.second, m_thickness));
-  painter.fillPath(getArrowHead(m_points.first, m_points.second, m_thickness),
-                   QBrush(m_color));
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawLine(
+      getShorterLine(m_points.first, m_points.second, m_thickness));
+    painter.fillPath(getArrowHead(m_points.first, m_points.second, m_thickness),
+                     QBrush(m_color));
 }
 
-void
-ArrowTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void ArrowTool::paintMousePreview(QPainter& painter,
+                                  const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-ArrowTool::drawStart(const CaptureContext& context)
+void ArrowTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-ArrowTool::pressed(const CaptureContext& context)
+void ArrowTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/arrow/arrowtool.h b/src/tools/arrow/arrowtool.h
index 0b747cdd..c947c9ec 100644
--- a/src/tools/arrow/arrowtool.h
+++ b/src/tools/arrow/arrowtool.h
@@ -23,25 +23,25 @@
 
 class ArrowTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ArrowTool(QObject* parent = nullptr);
+    explicit ArrowTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/capturecontext.cpp b/src/tools/capturecontext.cpp
index 01f41cbc..4b0ebc32 100644
--- a/src/tools/capturecontext.cpp
+++ b/src/tools/capturecontext.cpp
@@ -17,12 +17,11 @@
 
 #include "capturecontext.h"
 
-QPixmap
-CaptureContext::selectedScreenshotArea() const
+QPixmap CaptureContext::selectedScreenshotArea() const
 {
-  if (selection.isNull()) {
-    return screenshot;
-  } else {
-    return screenshot.copy(selection);
-  }
+    if (selection.isNull()) {
+        return screenshot;
+    } else {
+        return screenshot.copy(selection);
+    }
 }
diff --git a/src/tools/capturecontext.h b/src/tools/capturecontext.h
index c4153a1f..498509bb 100644
--- a/src/tools/capturecontext.h
+++ b/src/tools/capturecontext.h
@@ -24,27 +24,27 @@
 
 struct CaptureContext
 {
-  // screenshot with modifications
-  QPixmap screenshot;
-  // unmodified screenshot
-  QPixmap origScreenshot;
-  // Selection area
-  QRect selection;
-  // Widget dimensions
-  QRect widgetDimensions;
-  // Selected tool color
-  QColor color;
-  // Path where the content has to be saved
-  QString savePath;
-  // Ofset of the capture widget based on the system's screen (top-left)
-  QPoint widgetOffset;
-  // Mouse position inside the widget
-  QPoint mousePos;
-  // Value of the desired thickness
-  int thickness;
-  int circleCount;
-  // Mode of the capture widget
-  bool fullscreen;
+    // screenshot with modifications
+    QPixmap screenshot;
+    // unmodified screenshot
+    QPixmap origScreenshot;
+    // Selection area
+    QRect selection;
+    // Widget dimensions
+    QRect widgetDimensions;
+    // Selected tool color
+    QColor color;
+    // Path where the content has to be saved
+    QString savePath;
+    // Ofset of the capture widget based on the system's screen (top-left)
+    QPoint widgetOffset;
+    // Mouse position inside the widget
+    QPoint mousePos;
+    // Value of the desired thickness
+    int thickness;
+    int circleCount;
+    // Mode of the capture widget
+    bool fullscreen;
 
-  QPixmap selectedScreenshotArea() const;
+    QPixmap selectedScreenshotArea() const;
 };
diff --git a/src/tools/capturetool.h b/src/tools/capturetool.h
index 9186f5ab..d7338954 100644
--- a/src/tools/capturetool.h
+++ b/src/tools/capturetool.h
@@ -25,152 +25,152 @@
 
 enum class ToolType
 {
-  ARROW,
-  CIRCLE,
-  CIRCLECOUNT,
-  COPY,
-  EXIT,
-  IMGUR,
-  LAUNCHER,
-  LINE,
-  MARKER,
-  MOVE,
-  PENCIL,
-  PIN,
-  PIXELATE,
-  RECTANGLE,
-  REDO,
-  SAVE,
-  SELECTION,
-  SIZEINDICATOR,
-  TEXT,
-  UNDO
+    ARROW,
+    CIRCLE,
+    CIRCLECOUNT,
+    COPY,
+    EXIT,
+    IMGUR,
+    LAUNCHER,
+    LINE,
+    MARKER,
+    MOVE,
+    PENCIL,
+    PIN,
+    PIXELATE,
+    RECTANGLE,
+    REDO,
+    SAVE,
+    SELECTION,
+    SIZEINDICATOR,
+    TEXT,
+    UNDO
 };
 
 class CaptureTool : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  // Request actions on the main widget
-  enum Request
-  {
-    // Call close() in the editor.
-    REQ_CLOSE_GUI,
-    // Call hide() in the editor.
-    REQ_HIDE_GUI,
-    // Select the whole screen.
-    REQ_SELECT_ALL,
-    // Disable the selection.
-    REQ_HIDE_SELECTION,
-    // Undo the last active modification in the stack.
-    REQ_UNDO_MODIFICATION,
-    // Redo the next modification in the stack.
-    REQ_REDO_MODIFICATION,
-    // Remove all the modifications.
-    REQ_CLEAR_MODIFICATIONS,
-    // Disable the active tool.
-    REQ_MOVE_MODE,
-    // Open the color picker under the mouse.
-    REQ_SHOW_COLOR_PICKER,
-    // Open/Close the side-panel.
-    REQ_TOGGLE_SIDEBAR,
-    // Call update() in the editor.
-    REQ_REDRAW,
-    // Append this tool to the undo/redo stack
-    REQ_APPEND_TO_STACK,
-    // Notify is the screenshot has been saved.
-    REQ_CAPTURE_DONE_OK,
-    // Instance this->widget()'s widget inside the editor under the mouse.
-    REQ_ADD_CHILD_WIDGET,
-    // Instance this->widget()'s widget as a window which closes after
-    // closing the editor.
-    REQ_ADD_CHILD_WINDOW,
-    // Instance this->widget()'s widget which handles its own lifetime.
-    REQ_ADD_EXTERNAL_WIDGETS,
+    // Request actions on the main widget
+    enum Request
+    {
+        // Call close() in the editor.
+        REQ_CLOSE_GUI,
+        // Call hide() in the editor.
+        REQ_HIDE_GUI,
+        // Select the whole screen.
+        REQ_SELECT_ALL,
+        // Disable the selection.
+        REQ_HIDE_SELECTION,
+        // Undo the last active modification in the stack.
+        REQ_UNDO_MODIFICATION,
+        // Redo the next modification in the stack.
+        REQ_REDO_MODIFICATION,
+        // Remove all the modifications.
+        REQ_CLEAR_MODIFICATIONS,
+        // Disable the active tool.
+        REQ_MOVE_MODE,
+        // Open the color picker under the mouse.
+        REQ_SHOW_COLOR_PICKER,
+        // Open/Close the side-panel.
+        REQ_TOGGLE_SIDEBAR,
+        // Call update() in the editor.
+        REQ_REDRAW,
+        // Append this tool to the undo/redo stack
+        REQ_APPEND_TO_STACK,
+        // Notify is the screenshot has been saved.
+        REQ_CAPTURE_DONE_OK,
+        // Instance this->widget()'s widget inside the editor under the mouse.
+        REQ_ADD_CHILD_WIDGET,
+        // Instance this->widget()'s widget as a window which closes after
+        // closing the editor.
+        REQ_ADD_CHILD_WINDOW,
+        // Instance this->widget()'s widget which handles its own lifetime.
+        REQ_ADD_EXTERNAL_WIDGETS,
 
-    REQ_INCREMENT_CIRCLE_COUNT,
+        REQ_INCREMENT_CIRCLE_COUNT,
 
-    REQ_DECREMENT_CIRCLE_COUNT,
-  };
+        REQ_DECREMENT_CIRCLE_COUNT,
+    };
 
-  explicit CaptureTool(QObject* parent = nullptr)
-    : QObject(parent)
-  {}
+    explicit CaptureTool(QObject* parent = nullptr)
+      : QObject(parent)
+    {}
 
-  // Returns false when the tool is in an inconsistent state and shouldn't
-  // be included in the tool undo/redo stack.
-  virtual bool isValid() const = 0;
-  // Close the capture after the process() call if the tool was activated
-  // from a button press.
-  virtual bool closeOnButtonPressed() const = 0;
-  // If the tool keeps active after the selection.
-  virtual bool isSelectable() const = 0;
-  // Enable mouse preview.
-  virtual bool showMousePreview() const = 0;
+    // Returns false when the tool is in an inconsistent state and shouldn't
+    // be included in the tool undo/redo stack.
+    virtual bool isValid() const = 0;
+    // Close the capture after the process() call if the tool was activated
+    // from a button press.
+    virtual bool closeOnButtonPressed() const = 0;
+    // If the tool keeps active after the selection.
+    virtual bool isSelectable() const = 0;
+    // Enable mouse preview.
+    virtual bool showMousePreview() const = 0;
 
-  // The icon of the tool.
-  // inEditor is true when the icon is requested inside the editor
-  // and false otherwise.
-  virtual QIcon icon(const QColor& background, bool inEditor) const = 0;
-  // Name displayed for the tool, this could be translated with tr()
-  virtual QString name() const = 0;
-  // Codename for the tool, this hsouldn't change as it is used as ID
-  // for the tool in the internals of Flameshot
-  virtual ToolType nameID() const = 0;
-  // Short description of the tool.
-  virtual QString description() const = 0;
+    // The icon of the tool.
+    // inEditor is true when the icon is requested inside the editor
+    // and false otherwise.
+    virtual QIcon icon(const QColor& background, bool inEditor) const = 0;
+    // Name displayed for the tool, this could be translated with tr()
+    virtual QString name() const = 0;
+    // Codename for the tool, this hsouldn't change as it is used as ID
+    // for the tool in the internals of Flameshot
+    virtual ToolType nameID() const = 0;
+    // Short description of the tool.
+    virtual QString description() const = 0;
 
-  // if the type is TYPE_WIDGET the widget is loaded in the main widget.
-  // If the type is TYPE_EXTERNAL_WIDGET it is created outside as an
-  // individual widget.
-  virtual QWidget* widget() { return nullptr; }
-  // When the tool is selected this method is called and the widget is added
-  // to the configuration panel inside the main widget.
-  virtual QWidget* configurationWidget() { return nullptr; }
-  // Permanent configuration used in the configuration outside of the
-  // capture.
-  virtual QWidget* permanentConfigurationWidget() { return nullptr; }
-  // Return a copy of the tool
-  virtual CaptureTool* copy(QObject* parent = nullptr) = 0;
+    // if the type is TYPE_WIDGET the widget is loaded in the main widget.
+    // If the type is TYPE_EXTERNAL_WIDGET it is created outside as an
+    // individual widget.
+    virtual QWidget* widget() { return nullptr; }
+    // When the tool is selected this method is called and the widget is added
+    // to the configuration panel inside the main widget.
+    virtual QWidget* configurationWidget() { return nullptr; }
+    // Permanent configuration used in the configuration outside of the
+    // capture.
+    virtual QWidget* permanentConfigurationWidget() { return nullptr; }
+    // Return a copy of the tool
+    virtual CaptureTool* copy(QObject* parent = nullptr) = 0;
 
-  // revert changes
-  virtual void undo(QPixmap& pixmap) = 0;
-  // Called every time the tool has to draw
-  // recordUndo indicates when the tool should save the information
-  // for the undo(), if the value is false calling undo() after
-  // that process should not modify revert the changes.
-  virtual void process(QPainter& painter,
-                       const QPixmap& pixmap,
-                       bool recordUndo = false) = 0;
-  // When the tool is selected, this is called when the mouse moves
-  virtual void paintMousePreview(QPainter& painter,
-                                 const CaptureContext& context) = 0;
+    // revert changes
+    virtual void undo(QPixmap& pixmap) = 0;
+    // Called every time the tool has to draw
+    // recordUndo indicates when the tool should save the information
+    // for the undo(), if the value is false calling undo() after
+    // that process should not modify revert the changes.
+    virtual void process(QPainter& painter,
+                         const QPixmap& pixmap,
+                         bool recordUndo = false) = 0;
+    // When the tool is selected, this is called when the mouse moves
+    virtual void paintMousePreview(QPainter& painter,
+                                   const CaptureContext& context) = 0;
 
 signals:
-  void requestAction(Request r);
+    void requestAction(Request r);
 
 protected:
-  QString iconPath(const QColor& c) const
-  {
-    return ColorUtils::colorIsDark(c) ? PathInfo::whiteIconPath()
-                                      : PathInfo::blackIconPath();
-  }
+    QString iconPath(const QColor& c) const
+    {
+        return ColorUtils::colorIsDark(c) ? PathInfo::whiteIconPath()
+                                          : PathInfo::blackIconPath();
+    }
 
 public slots:
-  // On mouse release.
-  virtual void drawEnd(const QPoint& p) = 0;
-  // Mouse pressed and moving, called once a pixel.
-  virtual void drawMove(const QPoint& p) = 0;
-  // Called when drawMove is needed with an adjustment;
-  // should be overridden in case an adjustment is applicable.
-  virtual void drawMoveWithAdjustment(const QPoint& p) { drawMove(p); }
-  // Called when the tool is activated.
-  virtual void drawStart(const CaptureContext& context) = 0;
-  // Called right after pressign the button which activates the tool.
-  virtual void pressed(const CaptureContext& context) = 0;
-  // Called when the color is changed in the editor.
-  virtual void colorChanged(const QColor& c) = 0;
-  // Called when the thickness of the tool is updated in the editor.
-  virtual void thicknessChanged(const int th) = 0;
+    // On mouse release.
+    virtual void drawEnd(const QPoint& p) = 0;
+    // Mouse pressed and moving, called once a pixel.
+    virtual void drawMove(const QPoint& p) = 0;
+    // Called when drawMove is needed with an adjustment;
+    // should be overridden in case an adjustment is applicable.
+    virtual void drawMoveWithAdjustment(const QPoint& p) { drawMove(p); }
+    // Called when the tool is activated.
+    virtual void drawStart(const CaptureContext& context) = 0;
+    // Called right after pressign the button which activates the tool.
+    virtual void pressed(const CaptureContext& context) = 0;
+    // Called when the color is changed in the editor.
+    virtual void colorChanged(const QColor& c) = 0;
+    // Called when the thickness of the tool is updated in the editor.
+    virtual void thicknessChanged(const int th) = 0;
 };
diff --git a/src/tools/circle/circletool.cpp b/src/tools/circle/circletool.cpp
index 539f5293..243b0645 100644
--- a/src/tools/circle/circletool.cpp
+++ b/src/tools/circle/circletool.cpp
@@ -25,67 +25,61 @@ namespace {
 CircleTool::CircleTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_supportsDiagonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-QIcon
-CircleTool::icon(const QColor& background, bool inEditor) const
+QIcon CircleTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "circle-outline.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "circle-outline.svg");
 }
-QString
-CircleTool::name() const
+QString CircleTool::name() const
 {
-  return tr("Circle");
+    return tr("Circle");
 }
 
-ToolType
-CircleTool::nameID() const
+ToolType CircleTool::nameID() const
 {
-  return ToolType::CIRCLE;
+    return ToolType::CIRCLE;
 }
 
-QString
-CircleTool::description() const
+QString CircleTool::description() const
 {
-  return tr("Set the Circle as the paint tool");
+    return tr("Set the Circle as the paint tool");
 }
 
-CaptureTool*
-CircleTool::copy(QObject* parent)
+CaptureTool* CircleTool::copy(QObject* parent)
 {
-  return new CircleTool(parent);
+    return new CircleTool(parent);
 }
 
-void
-CircleTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void CircleTool::process(QPainter& painter,
+                         const QPixmap& pixmap,
+                         bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawEllipse(QRect(m_points.first, m_points.second));
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawEllipse(QRect(m_points.first, m_points.second));
 }
 
-void
-CircleTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void CircleTool::paintMousePreview(QPainter& painter,
+                                   const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-CircleTool::drawStart(const CaptureContext& context)
+void CircleTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-CircleTool::pressed(const CaptureContext& context)
+void CircleTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/circle/circletool.h b/src/tools/circle/circletool.h
index 9d6f610c..886ee209 100644
--- a/src/tools/circle/circletool.h
+++ b/src/tools/circle/circletool.h
@@ -21,25 +21,25 @@
 
 class CircleTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit CircleTool(QObject* parent = nullptr);
+    explicit CircleTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/circlecount/circlecounttool.cpp b/src/tools/circlecount/circlecounttool.cpp
index 10ac7065..3b9ca65c 100644
--- a/src/tools/circlecount/circlecounttool.cpp
+++ b/src/tools/circlecount/circlecounttool.cpp
@@ -24,120 +24,111 @@ namespace {
 CircleCountTool::CircleCountTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_count = 0;
+    m_count = 0;
 }
 
-QIcon
-CircleCountTool::icon(const QColor& background, bool inEditor) const
+QIcon CircleCountTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "circlecount-outline.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "circlecount-outline.svg");
 }
-QString
-CircleCountTool::name() const
+QString CircleCountTool::name() const
 {
-  return tr("Circle Counter");
+    return tr("Circle Counter");
 }
 
-ToolType
-CircleCountTool::nameID() const
+ToolType CircleCountTool::nameID() const
 {
-  return ToolType::CIRCLECOUNT;
+    return ToolType::CIRCLECOUNT;
 }
 
-QString
-CircleCountTool::description() const
+QString CircleCountTool::description() const
 {
-  return tr("Add an autoincrementing counter bubble");
+    return tr("Add an autoincrementing counter bubble");
 }
 
-CaptureTool*
-CircleCountTool::copy(QObject* parent)
+CaptureTool* CircleCountTool::copy(QObject* parent)
 {
-  return new CircleCountTool(parent);
+    return new CircleCountTool(parent);
 }
 
-void
-CircleCountTool::process(QPainter& painter,
-                         const QPixmap& pixmap,
-                         bool recordUndo)
+void CircleCountTool::process(QPainter& painter,
+                              const QPixmap& pixmap,
+                              bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setBrush(m_color);
-
-  int bubble_size = m_thickness;
-  // Decrease by 1px so the border is properly ereased when doing undo
-  painter.drawEllipse(m_points.first, bubble_size - 1, bubble_size - 1);
-  QRect textRect = QRect(m_points.first.x() - bubble_size / 2,
-                         m_points.first.y() - bubble_size / 2,
-                         bubble_size,
-                         bubble_size);
-  auto orig_font = painter.font();
-  auto new_font = orig_font;
-  auto fontSize = bubble_size;
-  new_font.setPixelSize(fontSize);
-  painter.setFont(new_font);
-
-  QRect bRect =
-    painter.boundingRect(textRect, Qt::AlignCenter, QString::number(m_count));
-
-  while (bRect.width() > textRect.width()) {
-    fontSize--;
-    if (fontSize == 0) {
-      break;
+    if (recordUndo) {
+        updateBackup(pixmap);
     }
+    painter.setBrush(m_color);
+
+    int bubble_size = m_thickness;
+    // Decrease by 1px so the border is properly ereased when doing undo
+    painter.drawEllipse(m_points.first, bubble_size - 1, bubble_size - 1);
+    QRect textRect = QRect(m_points.first.x() - bubble_size / 2,
+                           m_points.first.y() - bubble_size / 2,
+                           bubble_size,
+                           bubble_size);
+    auto orig_font = painter.font();
+    auto new_font = orig_font;
+    auto fontSize = bubble_size;
     new_font.setPixelSize(fontSize);
     painter.setFont(new_font);
 
-    bRect =
+    QRect bRect =
       painter.boundingRect(textRect, Qt::AlignCenter, QString::number(m_count));
-  }
 
-  // Lightness value ranges from 0-255, we split at 75 as this looks best
-  if (m_color.lightness() <= 75) {
-    painter.setPen(Qt::white);
-  } else {
-    painter.setPen(Qt::black);
-  }
+    while (bRect.width() > textRect.width()) {
+        fontSize--;
+        if (fontSize == 0) {
+            break;
+        }
+        new_font.setPixelSize(fontSize);
+        painter.setFont(new_font);
 
-  painter.drawText(textRect, Qt::AlignCenter, QString::number(m_count));
-  painter.setFont(orig_font);
+        bRect = painter.boundingRect(
+          textRect, Qt::AlignCenter, QString::number(m_count));
+    }
+
+    // Lightness value ranges from 0-255, we split at 75 as this looks best
+    if (m_color.lightness() <= 75) {
+        painter.setPen(Qt::white);
+    } else {
+        painter.setPen(Qt::black);
+    }
+
+    painter.drawText(textRect, Qt::AlignCenter, QString::number(m_count));
+    painter.setFont(orig_font);
 }
 
-void
-CircleCountTool::paintMousePreview(QPainter& painter,
-                                   const CaptureContext& context)
+void CircleCountTool::paintMousePreview(QPainter& painter,
+                                        const CaptureContext& context)
 {
-  m_thickness = context.thickness + PADDING_VALUE;
-  if (m_thickness < 15) {
-    m_thickness = 15;
-  }
-
-  // Thickness for pen is *2 to range from radius to diameter to match the
-  // ellipse draw function
-  painter.setPen(
-    QPen(context.color, m_thickness * 2, Qt::SolidLine, Qt::RoundCap));
-  painter.drawLine(context.mousePos,
-                   { context.mousePos.x() + 1, context.mousePos.y() + 1 });
+    m_thickness = context.thickness + PADDING_VALUE;
+    if (m_thickness < 15) {
+        m_thickness = 15;
+    }
+
+    // Thickness for pen is *2 to range from radius to diameter to match the
+    // ellipse draw function
+    painter.setPen(
+      QPen(context.color, m_thickness * 2, Qt::SolidLine, Qt::RoundCap));
+    painter.drawLine(context.mousePos,
+                     { context.mousePos.x() + 1, context.mousePos.y() + 1 });
 }
 
-void
-CircleCountTool::drawStart(const CaptureContext& context)
+void CircleCountTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  if (m_thickness < 15) {
-    m_thickness = 15;
-  }
-  m_points.first = context.mousePos;
-  m_count = context.circleCount;
-  emit requestAction(REQ_INCREMENT_CIRCLE_COUNT);
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    if (m_thickness < 15) {
+        m_thickness = 15;
+    }
+    m_points.first = context.mousePos;
+    m_count = context.circleCount;
+    emit requestAction(REQ_INCREMENT_CIRCLE_COUNT);
 }
 
-void
-CircleCountTool::pressed(const CaptureContext& context)
+void CircleCountTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/circlecount/circlecounttool.h b/src/tools/circlecount/circlecounttool.h
index ed51fcc4..68415da8 100644
--- a/src/tools/circlecount/circlecounttool.h
+++ b/src/tools/circlecount/circlecounttool.h
@@ -21,27 +21,27 @@
 
 class CircleCountTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit CircleCountTool(QObject* parent = nullptr);
+    explicit CircleCountTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 private:
-  unsigned int m_count;
+    unsigned int m_count;
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/copy/copytool.cpp b/src/tools/copy/copytool.cpp
index 88829532..ffa528d6 100644
--- a/src/tools/copy/copytool.cpp
+++ b/src/tools/copy/copytool.cpp
@@ -23,45 +23,38 @@ CopyTool::CopyTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-CopyTool::closeOnButtonPressed() const
+bool CopyTool::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-CopyTool::icon(const QColor& background, bool inEditor) const
+QIcon CopyTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "content-copy.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "content-copy.svg");
 }
-QString
-CopyTool::name() const
+QString CopyTool::name() const
 {
-  return tr("Copy");
+    return tr("Copy");
 }
 
-ToolType
-CopyTool::nameID() const
+ToolType CopyTool::nameID() const
 {
-  return ToolType::COPY;
+    return ToolType::COPY;
 }
 
-QString
-CopyTool::description() const
+QString CopyTool::description() const
 {
-  return tr("Copy the selection into the clipboard");
+    return tr("Copy the selection into the clipboard");
 }
 
-CaptureTool*
-CopyTool::copy(QObject* parent)
+CaptureTool* CopyTool::copy(QObject* parent)
 {
-  return new CopyTool(parent);
+    return new CopyTool(parent);
 }
 
-void
-CopyTool::pressed(const CaptureContext& context)
+void CopyTool::pressed(const CaptureContext& context)
 {
-  emit requestAction(REQ_CAPTURE_DONE_OK);
-  ScreenshotSaver().saveToClipboard(context.selectedScreenshotArea());
+    emit requestAction(REQ_CAPTURE_DONE_OK);
+    ScreenshotSaver().saveToClipboard(context.selectedScreenshotArea());
 }
diff --git a/src/tools/copy/copytool.h b/src/tools/copy/copytool.h
index b6fd3b62..f8fe081b 100644
--- a/src/tools/copy/copytool.h
+++ b/src/tools/copy/copytool.h
@@ -21,21 +21,21 @@
 
 class CopyTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit CopyTool(QObject* parent = nullptr);
+    explicit CopyTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/exit/exittool.cpp b/src/tools/exit/exittool.cpp
index 00557158..f794c6f1 100644
--- a/src/tools/exit/exittool.cpp
+++ b/src/tools/exit/exittool.cpp
@@ -22,45 +22,38 @@ ExitTool::ExitTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-ExitTool::closeOnButtonPressed() const
+bool ExitTool::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-ExitTool::icon(const QColor& background, bool inEditor) const
+QIcon ExitTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "close.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "close.svg");
 }
-QString
-ExitTool::name() const
+QString ExitTool::name() const
 {
-  return tr("Exit");
+    return tr("Exit");
 }
 
-ToolType
-ExitTool::nameID() const
+ToolType ExitTool::nameID() const
 {
-  return ToolType::EXIT;
+    return ToolType::EXIT;
 }
 
-QString
-ExitTool::description() const
+QString ExitTool::description() const
 {
-  return tr("Leave the capture screen");
+    return tr("Leave the capture screen");
 }
 
-CaptureTool*
-ExitTool::copy(QObject* parent)
+CaptureTool* ExitTool::copy(QObject* parent)
 {
-  return new ExitTool(parent);
+    return new ExitTool(parent);
 }
 
-void
-ExitTool::pressed(const CaptureContext& context)
+void ExitTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
-  emit requestAction(REQ_CLOSE_GUI);
+    Q_UNUSED(context);
+    emit requestAction(REQ_CLOSE_GUI);
 }
diff --git a/src/tools/exit/exittool.h b/src/tools/exit/exittool.h
index af77c43f..109b3e32 100644
--- a/src/tools/exit/exittool.h
+++ b/src/tools/exit/exittool.h
@@ -21,21 +21,21 @@
 
 class ExitTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ExitTool(QObject* parent = nullptr);
+    explicit ExitTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/imgur/imguruploader.cpp b/src/tools/imgur/imguruploader.cpp
index 5cc11edb..ae11d863 100644
--- a/src/tools/imgur/imguruploader.cpp
+++ b/src/tools/imgur/imguruploader.cpp
@@ -45,165 +45,158 @@ ImgurUploader::ImgurUploader(const QPixmap& capture, QWidget* parent)
   : QWidget(parent)
   , m_pixmap(capture)
 {
-  setWindowTitle(tr("Upload to Imgur"));
-  setWindowIcon(QIcon(":img/app/flameshot.svg"));
+    setWindowTitle(tr("Upload to Imgur"));
+    setWindowIcon(QIcon(":img/app/flameshot.svg"));
 
-  m_spinner = new LoadSpinner(this);
-  m_spinner->setColor(ConfigHandler().uiMainColorValue());
-  m_spinner->start();
+    m_spinner = new LoadSpinner(this);
+    m_spinner->setColor(ConfigHandler().uiMainColorValue());
+    m_spinner->start();
 
-  m_infoLabel = new QLabel(tr("Uploading Image"));
+    m_infoLabel = new QLabel(tr("Uploading Image"));
 
-  m_vLayout = new QVBoxLayout();
-  setLayout(m_vLayout);
-  m_vLayout->addWidget(m_spinner, 0, Qt::AlignHCenter);
-  m_vLayout->addWidget(m_infoLabel);
+    m_vLayout = new QVBoxLayout();
+    setLayout(m_vLayout);
+    m_vLayout->addWidget(m_spinner, 0, Qt::AlignHCenter);
+    m_vLayout->addWidget(m_infoLabel);
 
-  m_NetworkAM = new QNetworkAccessManager(this);
-  connect(m_NetworkAM,
-          &QNetworkAccessManager::finished,
-          this,
-          &ImgurUploader::handleReply);
+    m_NetworkAM = new QNetworkAccessManager(this);
+    connect(m_NetworkAM,
+            &QNetworkAccessManager::finished,
+            this,
+            &ImgurUploader::handleReply);
 
-  setAttribute(Qt::WA_DeleteOnClose);
+    setAttribute(Qt::WA_DeleteOnClose);
 
-  upload();
-  // QTimer::singleShot(2000, this, &ImgurUploader::onUploadOk); // testing
+    upload();
+    // QTimer::singleShot(2000, this, &ImgurUploader::onUploadOk); // testing
 }
 
-void
-ImgurUploader::handleReply(QNetworkReply* reply)
+void ImgurUploader::handleReply(QNetworkReply* reply)
 {
-  m_spinner->deleteLater();
-  if (reply->error() == QNetworkReply::NoError) {
-    QJsonDocument response = QJsonDocument::fromJson(reply->readAll());
-    QJsonObject json = response.object();
-    QJsonObject data = json[QStringLiteral("data")].toObject();
-    m_imageURL.setUrl(data[QStringLiteral("link")].toString());
-    m_deleteImageURL.setUrl(
-      QStringLiteral("https://imgur.com/delete/%1")
-        .arg(data[QStringLiteral("deletehash")].toString()));
-    if (ConfigHandler().copyAndCloseAfterUploadEnabled()) {
-      QApplication::clipboard()->setText(m_imageURL.toString());
-      SystemNotification().sendMessage(QObject::tr("URL copied to clipboard."));
-      close();
+    m_spinner->deleteLater();
+    if (reply->error() == QNetworkReply::NoError) {
+        QJsonDocument response = QJsonDocument::fromJson(reply->readAll());
+        QJsonObject json = response.object();
+        QJsonObject data = json[QStringLiteral("data")].toObject();
+        m_imageURL.setUrl(data[QStringLiteral("link")].toString());
+        m_deleteImageURL.setUrl(
+          QStringLiteral("https://imgur.com/delete/%1")
+            .arg(data[QStringLiteral("deletehash")].toString()));
+        if (ConfigHandler().copyAndCloseAfterUploadEnabled()) {
+            QApplication::clipboard()->setText(m_imageURL.toString());
+            SystemNotification().sendMessage(
+              QObject::tr("URL copied to clipboard."));
+            close();
+        } else {
+            onUploadOk();
+        }
     } else {
-      onUploadOk();
+        m_infoLabel->setText(reply->errorString());
     }
-  } else {
-    m_infoLabel->setText(reply->errorString());
-  }
-  new QShortcut(Qt::Key_Escape, this, SLOT(close()));
+    new QShortcut(Qt::Key_Escape, this, SLOT(close()));
 }
 
-void
-ImgurUploader::startDrag()
+void ImgurUploader::startDrag()
 {
-  QMimeData* mimeData = new QMimeData;
-  mimeData->setUrls(QList<QUrl>{ m_imageURL });
-  mimeData->setImageData(m_pixmap);
-
-  QDrag* dragHandler = new QDrag(this);
-  dragHandler->setMimeData(mimeData);
-  dragHandler->setPixmap(m_pixmap.scaled(
-    256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation));
-  dragHandler->exec();
+    QMimeData* mimeData = new QMimeData;
+    mimeData->setUrls(QList<QUrl>{ m_imageURL });
+    mimeData->setImageData(m_pixmap);
+
+    QDrag* dragHandler = new QDrag(this);
+    dragHandler->setMimeData(mimeData);
+    dragHandler->setPixmap(m_pixmap.scaled(
+      256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation));
+    dragHandler->exec();
 }
 
-void
-ImgurUploader::upload()
+void ImgurUploader::upload()
 {
-  QByteArray byteArray;
-  QBuffer buffer(&byteArray);
-  m_pixmap.save(&buffer, "PNG");
-
-  QUrlQuery urlQuery;
-  urlQuery.addQueryItem(QStringLiteral("title"),
-                        QStringLiteral("flameshot_screenshot"));
-  QString description = FileNameHandler().parsedPattern();
-  urlQuery.addQueryItem(QStringLiteral("description"), description);
-
-  QUrl url(QStringLiteral("https://api.imgur.com/3/image"));
-  url.setQuery(urlQuery);
-  QNetworkRequest request(url);
-  request.setHeader(QNetworkRequest::ContentTypeHeader,
-                    "application/application/x-www-form-urlencoded");
-  request.setRawHeader(
-    "Authorization",
-    QStringLiteral("Client-ID %1").arg(IMGUR_CLIENT_ID).toUtf8());
-
-  m_NetworkAM->post(request, byteArray);
+    QByteArray byteArray;
+    QBuffer buffer(&byteArray);
+    m_pixmap.save(&buffer, "PNG");
+
+    QUrlQuery urlQuery;
+    urlQuery.addQueryItem(QStringLiteral("title"),
+                          QStringLiteral("flameshot_screenshot"));
+    QString description = FileNameHandler().parsedPattern();
+    urlQuery.addQueryItem(QStringLiteral("description"), description);
+
+    QUrl url(QStringLiteral("https://api.imgur.com/3/image"));
+    url.setQuery(urlQuery);
+    QNetworkRequest request(url);
+    request.setHeader(QNetworkRequest::ContentTypeHeader,
+                      "application/application/x-www-form-urlencoded");
+    request.setRawHeader(
+      "Authorization",
+      QStringLiteral("Client-ID %1").arg(IMGUR_CLIENT_ID).toUtf8());
+
+    m_NetworkAM->post(request, byteArray);
 }
 
-void
-ImgurUploader::onUploadOk()
+void ImgurUploader::onUploadOk()
 {
-  m_infoLabel->deleteLater();
-
-  m_notification = new NotificationWidget();
-  m_vLayout->addWidget(m_notification);
-
-  ImageLabel* imageLabel = new ImageLabel();
-  imageLabel->setScreenshot(m_pixmap);
-  imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-  connect(
-    imageLabel, &ImageLabel::dragInitiated, this, &ImgurUploader::startDrag);
-  m_vLayout->addWidget(imageLabel);
-
-  m_hLayout = new QHBoxLayout();
-  m_vLayout->addLayout(m_hLayout);
-
-  m_copyUrlButton = new QPushButton(tr("Copy URL"));
-  m_openUrlButton = new QPushButton(tr("Open URL"));
-  m_openDeleteUrlButton = new QPushButton(tr("Delete image"));
-  m_toClipboardButton = new QPushButton(tr("Image to Clipboard."));
-  m_hLayout->addWidget(m_copyUrlButton);
-  m_hLayout->addWidget(m_openUrlButton);
-  m_hLayout->addWidget(m_openDeleteUrlButton);
-  m_hLayout->addWidget(m_toClipboardButton);
-
-  connect(
-    m_copyUrlButton, &QPushButton::clicked, this, &ImgurUploader::copyURL);
-  connect(
-    m_openUrlButton, &QPushButton::clicked, this, &ImgurUploader::openURL);
-  connect(m_openDeleteUrlButton,
-          &QPushButton::clicked,
-          this,
-          &ImgurUploader::openDeleteURL);
-  connect(m_toClipboardButton,
-          &QPushButton::clicked,
-          this,
-          &ImgurUploader::copyImage);
+    m_infoLabel->deleteLater();
+
+    m_notification = new NotificationWidget();
+    m_vLayout->addWidget(m_notification);
+
+    ImageLabel* imageLabel = new ImageLabel();
+    imageLabel->setScreenshot(m_pixmap);
+    imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    connect(
+      imageLabel, &ImageLabel::dragInitiated, this, &ImgurUploader::startDrag);
+    m_vLayout->addWidget(imageLabel);
+
+    m_hLayout = new QHBoxLayout();
+    m_vLayout->addLayout(m_hLayout);
+
+    m_copyUrlButton = new QPushButton(tr("Copy URL"));
+    m_openUrlButton = new QPushButton(tr("Open URL"));
+    m_openDeleteUrlButton = new QPushButton(tr("Delete image"));
+    m_toClipboardButton = new QPushButton(tr("Image to Clipboard."));
+    m_hLayout->addWidget(m_copyUrlButton);
+    m_hLayout->addWidget(m_openUrlButton);
+    m_hLayout->addWidget(m_openDeleteUrlButton);
+    m_hLayout->addWidget(m_toClipboardButton);
+
+    connect(
+      m_copyUrlButton, &QPushButton::clicked, this, &ImgurUploader::copyURL);
+    connect(
+      m_openUrlButton, &QPushButton::clicked, this, &ImgurUploader::openURL);
+    connect(m_openDeleteUrlButton,
+            &QPushButton::clicked,
+            this,
+            &ImgurUploader::openDeleteURL);
+    connect(m_toClipboardButton,
+            &QPushButton::clicked,
+            this,
+            &ImgurUploader::copyImage);
 }
 
-void
-ImgurUploader::openURL()
+void ImgurUploader::openURL()
 {
-  bool successful = QDesktopServices::openUrl(m_imageURL);
-  if (!successful) {
-    m_notification->showMessage(tr("Unable to open the URL."));
-  }
+    bool successful = QDesktopServices::openUrl(m_imageURL);
+    if (!successful) {
+        m_notification->showMessage(tr("Unable to open the URL."));
+    }
 }
 
-void
-ImgurUploader::copyURL()
+void ImgurUploader::copyURL()
 {
-  QApplication::clipboard()->setText(m_imageURL.toString());
-  m_notification->showMessage(tr("URL copied to clipboard."));
+    QApplication::clipboard()->setText(m_imageURL.toString());
+    m_notification->showMessage(tr("URL copied to clipboard."));
 }
 
-void
-ImgurUploader::openDeleteURL()
+void ImgurUploader::openDeleteURL()
 {
-  bool successful = QDesktopServices::openUrl(m_deleteImageURL);
-  if (!successful) {
-    m_notification->showMessage(tr("Unable to open the URL."));
-  }
+    bool successful = QDesktopServices::openUrl(m_deleteImageURL);
+    if (!successful) {
+        m_notification->showMessage(tr("Unable to open the URL."));
+    }
 }
 
-void
-ImgurUploader::copyImage()
+void ImgurUploader::copyImage()
 {
-  QApplication::clipboard()->setPixmap(m_pixmap);
-  m_notification->showMessage(tr("Screenshot copied to clipboard."));
+    QApplication::clipboard()->setPixmap(m_pixmap);
+    m_notification->showMessage(tr("Screenshot copied to clipboard."));
 }
diff --git a/src/tools/imgur/imguruploader.h b/src/tools/imgur/imguruploader.h
index 082767d1..677a2b67 100644
--- a/src/tools/imgur/imguruploader.h
+++ b/src/tools/imgur/imguruploader.h
@@ -32,37 +32,37 @@ class NotificationWidget;
 
 class ImgurUploader : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ImgurUploader(const QPixmap& capture, QWidget* parent = nullptr);
+    explicit ImgurUploader(const QPixmap& capture, QWidget* parent = nullptr);
 
 private slots:
-  void handleReply(QNetworkReply* reply);
-  void startDrag();
+    void handleReply(QNetworkReply* reply);
+    void startDrag();
 
-  void openURL();
-  void copyURL();
-  void openDeleteURL();
-  void copyImage();
+    void openURL();
+    void copyURL();
+    void openDeleteURL();
+    void copyImage();
 
 private:
-  QPixmap m_pixmap;
-  QNetworkAccessManager* m_NetworkAM;
+    QPixmap m_pixmap;
+    QNetworkAccessManager* m_NetworkAM;
 
-  QVBoxLayout* m_vLayout;
-  QHBoxLayout* m_hLayout;
-  // loading
-  QLabel* m_infoLabel;
-  LoadSpinner* m_spinner;
-  // uploaded
-  QPushButton* m_openUrlButton;
-  QPushButton* m_openDeleteUrlButton;
-  QPushButton* m_copyUrlButton;
-  QPushButton* m_toClipboardButton;
-  QUrl m_imageURL;
-  QUrl m_deleteImageURL;
-  NotificationWidget* m_notification;
+    QVBoxLayout* m_vLayout;
+    QHBoxLayout* m_hLayout;
+    // loading
+    QLabel* m_infoLabel;
+    LoadSpinner* m_spinner;
+    // uploaded
+    QPushButton* m_openUrlButton;
+    QPushButton* m_openDeleteUrlButton;
+    QPushButton* m_copyUrlButton;
+    QPushButton* m_toClipboardButton;
+    QUrl m_imageURL;
+    QUrl m_deleteImageURL;
+    NotificationWidget* m_notification;
 
-  void upload();
-  void onUploadOk();
+    void upload();
+    void onUploadOk();
 };
diff --git a/src/tools/imgur/imguruploadertool.cpp b/src/tools/imgur/imguruploadertool.cpp
index 60763f43..c05d00be 100644
--- a/src/tools/imgur/imguruploadertool.cpp
+++ b/src/tools/imgur/imguruploadertool.cpp
@@ -23,52 +23,44 @@ ImgurUploaderTool::ImgurUploaderTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-ImgurUploaderTool::closeOnButtonPressed() const
+bool ImgurUploaderTool::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-ImgurUploaderTool::icon(const QColor& background, bool inEditor) const
+QIcon ImgurUploaderTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "cloud-upload.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "cloud-upload.svg");
 }
-QString
-ImgurUploaderTool::name() const
+QString ImgurUploaderTool::name() const
 {
-  return tr("Image Uploader");
+    return tr("Image Uploader");
 }
 
-ToolType
-ImgurUploaderTool::nameID() const
+ToolType ImgurUploaderTool::nameID() const
 {
-  return ToolType::IMGUR;
+    return ToolType::IMGUR;
 }
 
-QString
-ImgurUploaderTool::description() const
+QString ImgurUploaderTool::description() const
 {
-  return tr("Upload the selection to Imgur");
+    return tr("Upload the selection to Imgur");
 }
 
-QWidget*
-ImgurUploaderTool::widget()
+QWidget* ImgurUploaderTool::widget()
 {
-  return new ImgurUploader(capture);
+    return new ImgurUploader(capture);
 }
 
-CaptureTool*
-ImgurUploaderTool::copy(QObject* parent)
+CaptureTool* ImgurUploaderTool::copy(QObject* parent)
 {
-  return new ImgurUploaderTool(parent);
+    return new ImgurUploaderTool(parent);
 }
 
-void
-ImgurUploaderTool::pressed(const CaptureContext& context)
+void ImgurUploaderTool::pressed(const CaptureContext& context)
 {
-  capture = context.selectedScreenshotArea();
-  emit requestAction(REQ_CAPTURE_DONE_OK);
-  emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
+    capture = context.selectedScreenshotArea();
+    emit requestAction(REQ_CAPTURE_DONE_OK);
+    emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
 }
diff --git a/src/tools/imgur/imguruploadertool.h b/src/tools/imgur/imguruploadertool.h
index ad23be98..cf08c783 100644
--- a/src/tools/imgur/imguruploadertool.h
+++ b/src/tools/imgur/imguruploadertool.h
@@ -21,26 +21,26 @@
 
 class ImgurUploaderTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ImgurUploaderTool(QObject* parent = nullptr);
+    explicit ImgurUploaderTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  QWidget* widget() override;
+    QWidget* widget() override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 
 private:
-  QPixmap capture;
+    QPixmap capture;
 };
diff --git a/src/tools/launcher/applaunchertool.cpp b/src/tools/launcher/applaunchertool.cpp
index e521f5eb..edacdc8c 100644
--- a/src/tools/launcher/applaunchertool.cpp
+++ b/src/tools/launcher/applaunchertool.cpp
@@ -22,52 +22,44 @@ AppLauncher::AppLauncher(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-AppLauncher::closeOnButtonPressed() const
+bool AppLauncher::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-AppLauncher::icon(const QColor& background, bool inEditor) const
+QIcon AppLauncher::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "open_with.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "open_with.svg");
 }
-QString
-AppLauncher::name() const
+QString AppLauncher::name() const
 {
-  return tr("App Launcher");
+    return tr("App Launcher");
 }
 
-ToolType
-AppLauncher::nameID() const
+ToolType AppLauncher::nameID() const
 {
-  return ToolType::LAUNCHER;
+    return ToolType::LAUNCHER;
 }
 
-QString
-AppLauncher::description() const
+QString AppLauncher::description() const
 {
-  return tr("Choose an app to open the capture");
+    return tr("Choose an app to open the capture");
 }
 
-QWidget*
-AppLauncher::widget()
+QWidget* AppLauncher::widget()
 {
-  return new AppLauncherWidget(capture);
+    return new AppLauncherWidget(capture);
 }
 
-CaptureTool*
-AppLauncher::copy(QObject* parent)
+CaptureTool* AppLauncher::copy(QObject* parent)
 {
-  return new AppLauncher(parent);
+    return new AppLauncher(parent);
 }
 
-void
-AppLauncher::pressed(const CaptureContext& context)
+void AppLauncher::pressed(const CaptureContext& context)
 {
-  capture = context.selectedScreenshotArea();
-  emit requestAction(REQ_CAPTURE_DONE_OK);
-  emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
+    capture = context.selectedScreenshotArea();
+    emit requestAction(REQ_CAPTURE_DONE_OK);
+    emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
 }
diff --git a/src/tools/launcher/applaunchertool.h b/src/tools/launcher/applaunchertool.h
index f2b85e55..9a7513a7 100644
--- a/src/tools/launcher/applaunchertool.h
+++ b/src/tools/launcher/applaunchertool.h
@@ -21,26 +21,26 @@
 
 class AppLauncher : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit AppLauncher(QObject* parent = nullptr);
+    explicit AppLauncher(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  QWidget* widget() override;
+    QWidget* widget() override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 
 private:
-  QPixmap capture;
+    QPixmap capture;
 };
diff --git a/src/tools/launcher/applauncherwidget.cpp b/src/tools/launcher/applauncherwidget.cpp
index cdbd93a7..4ae24175 100644
--- a/src/tools/launcher/applauncherwidget.cpp
+++ b/src/tools/launcher/applauncherwidget.cpp
@@ -51,218 +51,213 @@ AppLauncherWidget::AppLauncherWidget(const QPixmap& p, QWidget* parent)
   : QWidget(parent)
   , m_pixmap(p)
 {
-  setAttribute(Qt::WA_DeleteOnClose);
-  setWindowIcon(QIcon(":img/app/flameshot.svg"));
-  setWindowTitle(tr("Open With"));
+    setAttribute(Qt::WA_DeleteOnClose);
+    setWindowIcon(QIcon(":img/app/flameshot.svg"));
+    setWindowTitle(tr("Open With"));
 
-  m_keepOpen = ConfigHandler().keepOpenAppLauncherValue();
+    m_keepOpen = ConfigHandler().keepOpenAppLauncherValue();
 
-  QString dirLocal = QDir::homePath() + "/.local/share/applications/";
-  QDir appsDirLocal(dirLocal);
-  m_parser.processDirectory(appsDirLocal);
+    QString dirLocal = QDir::homePath() + "/.local/share/applications/";
+    QDir appsDirLocal(dirLocal);
+    m_parser.processDirectory(appsDirLocal);
 
-  QString dir = QStringLiteral("/usr/share/applications/");
-  QDir appsDir(dir);
-  m_parser.processDirectory(appsDir);
+    QString dir = QStringLiteral("/usr/share/applications/");
+    QDir appsDir(dir);
+    m_parser.processDirectory(appsDir);
 
-  initAppMap();
-  initListWidget();
+    initAppMap();
+    initListWidget();
 
-  m_terminalCheckbox = new QCheckBox(tr("Launch in terminal"), this);
-  m_keepOpenCheckbox = new QCheckBox(tr("Keep open after selection"), this);
-  m_keepOpenCheckbox->setChecked(ConfigHandler().keepOpenAppLauncherValue());
-  connect(m_keepOpenCheckbox,
-          &QCheckBox::clicked,
-          this,
-          &AppLauncherWidget::checkboxClicked);
+    m_terminalCheckbox = new QCheckBox(tr("Launch in terminal"), this);
+    m_keepOpenCheckbox = new QCheckBox(tr("Keep open after selection"), this);
+    m_keepOpenCheckbox->setChecked(ConfigHandler().keepOpenAppLauncherValue());
+    connect(m_keepOpenCheckbox,
+            &QCheckBox::clicked,
+            this,
+            &AppLauncherWidget::checkboxClicked);
 
-  // search items
-  m_lineEdit = new QLineEdit;
-  connect(m_lineEdit,
-          &QLineEdit::textChanged,
-          this,
-          &AppLauncherWidget::searchChanged);
-  m_filterList = new QListWidget;
-  m_filterList->hide();
-  configureListView(m_filterList);
-  connect(
-    m_filterList, &QListWidget::clicked, this, &AppLauncherWidget::launch);
+    // search items
+    m_lineEdit = new QLineEdit;
+    connect(m_lineEdit,
+            &QLineEdit::textChanged,
+            this,
+            &AppLauncherWidget::searchChanged);
+    m_filterList = new QListWidget;
+    m_filterList->hide();
+    configureListView(m_filterList);
+    connect(
+      m_filterList, &QListWidget::clicked, this, &AppLauncherWidget::launch);
 
-  m_layout = new QVBoxLayout(this);
-  m_layout->addWidget(m_filterList);
-  m_layout->addWidget(m_tabWidget);
-  m_layout->addWidget(m_lineEdit);
-  m_layout->addWidget(m_keepOpenCheckbox);
-  m_layout->addWidget(m_terminalCheckbox);
-  m_lineEdit->setFocus();
+    m_layout = new QVBoxLayout(this);
+    m_layout->addWidget(m_filterList);
+    m_layout->addWidget(m_tabWidget);
+    m_layout->addWidget(m_lineEdit);
+    m_layout->addWidget(m_keepOpenCheckbox);
+    m_layout->addWidget(m_terminalCheckbox);
+    m_lineEdit->setFocus();
 }
 
-void
-AppLauncherWidget::launch(const QModelIndex& index)
+void AppLauncherWidget::launch(const QModelIndex& index)
 {
-  if (!QFileInfo(m_tempFile).isReadable()) {
-    m_tempFile =
-      FileNameHandler().generateAbsolutePath(QDir::tempPath()) + ".png";
-    bool ok = m_pixmap.save(m_tempFile);
-    if (!ok) {
-      QMessageBox::about(
-        this, tr("Error"), tr("Unable to write in") + QDir::tempPath());
-      return;
+    if (!QFileInfo(m_tempFile).isReadable()) {
+        m_tempFile =
+          FileNameHandler().generateAbsolutePath(QDir::tempPath()) + ".png";
+        bool ok = m_pixmap.save(m_tempFile);
+        if (!ok) {
+            QMessageBox::about(
+              this, tr("Error"), tr("Unable to write in") + QDir::tempPath());
+            return;
+        }
     }
-  }
-  QString command = index.data(Qt::UserRole)
-                      .toString()
-                      .replace(QRegExp("(\\%.)"), '"' + m_tempFile + '"');
+    QString command = index.data(Qt::UserRole)
+                        .toString()
+                        .replace(QRegExp("(\\%.)"), '"' + m_tempFile + '"');
 
-  QString app_name = index.data(Qt::UserRole).toString().split(" ").at(0);
-  bool inTerminal =
-    index.data(Qt::UserRole + 1).toBool() || m_terminalCheckbox->isChecked();
-  if (inTerminal) {
-    bool ok = TerminalLauncher::launchDetached(command);
-    if (!ok) {
-      QMessageBox::about(
-        this, tr("Error"), tr("Unable to launch in terminal."));
+    QString app_name = index.data(Qt::UserRole).toString().split(" ").at(0);
+    bool inTerminal =
+      index.data(Qt::UserRole + 1).toBool() || m_terminalCheckbox->isChecked();
+    if (inTerminal) {
+        bool ok = TerminalLauncher::launchDetached(command);
+        if (!ok) {
+            QMessageBox::about(
+              this, tr("Error"), tr("Unable to launch in terminal."));
+        }
+    } else {
+        QProcess::startDetached(app_name, { m_tempFile });
+    }
+    if (!m_keepOpen) {
+        close();
     }
-  } else {
-    QProcess::startDetached(app_name, { m_tempFile });
-  }
-  if (!m_keepOpen) {
-    close();
-  }
 }
 
-void
-AppLauncherWidget::checkboxClicked(const bool enabled)
+void AppLauncherWidget::checkboxClicked(const bool enabled)
 {
-  m_keepOpen = enabled;
-  ConfigHandler().setKeepOpenAppLauncher(enabled);
-  m_keepOpenCheckbox->setChecked(enabled);
+    m_keepOpen = enabled;
+    ConfigHandler().setKeepOpenAppLauncher(enabled);
+    m_keepOpenCheckbox->setChecked(enabled);
 }
 
-void
-AppLauncherWidget::searchChanged(const QString& text)
+void AppLauncherWidget::searchChanged(const QString& text)
 {
-  if (text.isEmpty()) {
-    m_filterList->hide();
-    m_tabWidget->show();
-  } else {
-    m_tabWidget->hide();
-    m_filterList->show();
-    m_filterList->clear();
-    QRegExp regexp(text, Qt::CaseInsensitive, QRegExp::Wildcard);
-    QVector<DesktopAppData> apps;
+    if (text.isEmpty()) {
+        m_filterList->hide();
+        m_tabWidget->show();
+    } else {
+        m_tabWidget->hide();
+        m_filterList->show();
+        m_filterList->clear();
+        QRegExp regexp(text, Qt::CaseInsensitive, QRegExp::Wildcard);
+        QVector<DesktopAppData> apps;
 
-    for (auto const& i : catIconNames.toStdMap()) {
-      const QString& cat = i.first;
-      if (!m_appsMap.contains(cat)) {
-        continue;
-      }
-      const QVector<DesktopAppData>& appList = m_appsMap[cat];
-      for (const DesktopAppData& app : appList) {
-        if (!apps.contains(app) &&
-            (app.name.contains(regexp) || app.description.contains(regexp))) {
-          apps.append(app);
+        for (auto const& i : catIconNames.toStdMap()) {
+            const QString& cat = i.first;
+            if (!m_appsMap.contains(cat)) {
+                continue;
+            }
+            const QVector<DesktopAppData>& appList = m_appsMap[cat];
+            for (const DesktopAppData& app : appList) {
+                if (!apps.contains(app) && (app.name.contains(regexp) ||
+                                            app.description.contains(regexp))) {
+                    apps.append(app);
+                }
+            }
         }
-      }
+        addAppsToListWidget(m_filterList, apps);
     }
-    addAppsToListWidget(m_filterList, apps);
-  }
 }
 
-void
-AppLauncherWidget::initListWidget()
+void AppLauncherWidget::initListWidget()
 {
-  m_tabWidget = new QTabWidget;
-  const int size = GlobalValues::buttonBaseSize();
-  m_tabWidget->setIconSize(QSize(size, size));
+    m_tabWidget = new QTabWidget;
+    const int size = GlobalValues::buttonBaseSize();
+    m_tabWidget->setIconSize(QSize(size, size));
 
-  for (auto const& i : catIconNames.toStdMap()) {
-    const QString& cat = i.first;
-    const QString& iconName = i.second;
+    for (auto const& i : catIconNames.toStdMap()) {
+        const QString& cat = i.first;
+        const QString& iconName = i.second;
 
-    if (!m_appsMap.contains(cat)) {
-      continue;
-    }
+        if (!m_appsMap.contains(cat)) {
+            continue;
+        }
 
-    QListWidget* itemsWidget = new QListWidget();
-    configureListView(itemsWidget);
+        QListWidget* itemsWidget = new QListWidget();
+        configureListView(itemsWidget);
 
-    const QVector<DesktopAppData>& appList = m_appsMap[cat];
-    addAppsToListWidget(itemsWidget, appList);
+        const QVector<DesktopAppData>& appList = m_appsMap[cat];
+        addAppsToListWidget(itemsWidget, appList);
 
-    m_tabWidget->addTab(
-      itemsWidget, QIcon::fromTheme(iconName), QLatin1String(""));
-    m_tabWidget->setTabToolTip(m_tabWidget->count(), cat);
-    if (cat == QLatin1String("Graphics")) {
-      m_tabWidget->setCurrentIndex(m_tabWidget->count() - 1);
+        m_tabWidget->addTab(
+          itemsWidget, QIcon::fromTheme(iconName), QLatin1String(""));
+        m_tabWidget->setTabToolTip(m_tabWidget->count(), cat);
+        if (cat == QLatin1String("Graphics")) {
+            m_tabWidget->setCurrentIndex(m_tabWidget->count() - 1);
+        }
     }
-  }
 }
 
-void
-AppLauncherWidget::initAppMap()
+void AppLauncherWidget::initAppMap()
 {
-  QStringList categories({ "AudioVideo",
-                           "Audio",
-                           "Video",
-                           "Development",
-                           "Graphics",
-                           "Network",
-                           "Office",
-                           "Science",
-                           "Settings",
-                           "System",
-                           "Utility" });
+    QStringList categories({ "AudioVideo",
+                             "Audio",
+                             "Video",
+                             "Development",
+                             "Graphics",
+                             "Network",
+                             "Office",
+                             "Science",
+                             "Settings",
+                             "System",
+                             "Utility" });
 
-  m_appsMap = m_parser.getAppsByCategory(categories);
+    m_appsMap = m_parser.getAppsByCategory(categories);
 
-  // Unify multimedia.
-  QVector<DesktopAppData> multimediaList;
-  QStringList multimediaNames;
-  multimediaNames << QStringLiteral("AudioVideo") << QStringLiteral("Audio")
-                  << QStringLiteral("Video");
-  for (const QString& name : multimediaNames) {
-    if (!m_appsMap.contains(name)) {
-      continue;
-    }
-    for (auto i : m_appsMap[name]) {
-      if (!multimediaList.contains(i)) {
-        multimediaList.append(i);
-      }
+    // Unify multimedia.
+    QVector<DesktopAppData> multimediaList;
+    QStringList multimediaNames;
+    multimediaNames << QStringLiteral("AudioVideo") << QStringLiteral("Audio")
+                    << QStringLiteral("Video");
+    for (const QString& name : multimediaNames) {
+        if (!m_appsMap.contains(name)) {
+            continue;
+        }
+        for (auto i : m_appsMap[name]) {
+            if (!multimediaList.contains(i)) {
+                multimediaList.append(i);
+            }
+        }
+        m_appsMap.remove(name);
     }
-    m_appsMap.remove(name);
-  }
-  m_appsMap.insert(QStringLiteral("Multimedia"), multimediaList);
+    m_appsMap.insert(QStringLiteral("Multimedia"), multimediaList);
 }
 
-void
-AppLauncherWidget::configureListView(QListWidget* widget)
+void AppLauncherWidget::configureListView(QListWidget* widget)
 {
-  widget->setItemDelegate(new LauncherItemDelegate());
-  widget->setViewMode(QListWidget::IconMode);
-  widget->setResizeMode(QListView::Adjust);
-  widget->setSpacing(4);
-  widget->setFlow(QListView::LeftToRight);
-  widget->setDragEnabled(false);
-  widget->setMinimumWidth(GlobalValues::buttonBaseSize() * 11);
-  connect(widget, &QListWidget::clicked, this, &AppLauncherWidget::launch);
+    widget->setItemDelegate(new LauncherItemDelegate());
+    widget->setViewMode(QListWidget::IconMode);
+    widget->setResizeMode(QListView::Adjust);
+    widget->setSpacing(4);
+    widget->setFlow(QListView::LeftToRight);
+    widget->setDragEnabled(false);
+    widget->setMinimumWidth(GlobalValues::buttonBaseSize() * 11);
+    connect(widget, &QListWidget::clicked, this, &AppLauncherWidget::launch);
 }
 
-void
-AppLauncherWidget::addAppsToListWidget(QListWidget* widget,
-                                       const QVector<DesktopAppData>& appList)
+void AppLauncherWidget::addAppsToListWidget(
+  QListWidget* widget,
+  const QVector<DesktopAppData>& appList)
 {
-  for (const DesktopAppData& app : appList) {
-    QListWidgetItem* buttonItem = new QListWidgetItem(widget);
-    buttonItem->setData(Qt::DecorationRole, app.icon);
-    buttonItem->setData(Qt::DisplayRole, app.name);
-    buttonItem->setData(Qt::UserRole, app.exec);
-    buttonItem->setData(Qt::UserRole + 1, app.showInTerminal);
-    QColor foregroundColor = this->palette().color(QWidget::foregroundRole());
-    buttonItem->setForeground(foregroundColor);
+    for (const DesktopAppData& app : appList) {
+        QListWidgetItem* buttonItem = new QListWidgetItem(widget);
+        buttonItem->setData(Qt::DecorationRole, app.icon);
+        buttonItem->setData(Qt::DisplayRole, app.name);
+        buttonItem->setData(Qt::UserRole, app.exec);
+        buttonItem->setData(Qt::UserRole + 1, app.showInTerminal);
+        QColor foregroundColor =
+          this->palette().color(QWidget::foregroundRole());
+        buttonItem->setForeground(foregroundColor);
 
-    buttonItem->setIcon(app.icon);
-    buttonItem->setText(app.name);
-    buttonItem->setToolTip(app.description);
-  }
+        buttonItem->setIcon(app.icon);
+        buttonItem->setText(app.name);
+        buttonItem->setToolTip(app.description);
+    }
 }
diff --git a/src/tools/launcher/applauncherwidget.h b/src/tools/launcher/applauncherwidget.h
index 5724edd8..a92bd59e 100644
--- a/src/tools/launcher/applauncherwidget.h
+++ b/src/tools/launcher/applauncherwidget.h
@@ -29,31 +29,31 @@ class QListWidget;
 
 class AppLauncherWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit AppLauncherWidget(const QPixmap& p, QWidget* parent = nullptr);
+    explicit AppLauncherWidget(const QPixmap& p, QWidget* parent = nullptr);
 
 private slots:
-  void launch(const QModelIndex& index);
-  void checkboxClicked(const bool enabled);
-  void searchChanged(const QString& text);
+    void launch(const QModelIndex& index);
+    void checkboxClicked(const bool enabled);
+    void searchChanged(const QString& text);
 
 private:
-  void initListWidget();
-  void initAppMap();
-  void configureListView(QListWidget* widget);
-  void addAppsToListWidget(QListWidget* widget,
-                           const QVector<DesktopAppData>& appList);
+    void initListWidget();
+    void initAppMap();
+    void configureListView(QListWidget* widget);
+    void addAppsToListWidget(QListWidget* widget,
+                             const QVector<DesktopAppData>& appList);
 
-  DesktopFileParser m_parser;
-  QPixmap m_pixmap;
-  QString m_tempFile;
-  bool m_keepOpen;
-  QMap<QString, QVector<DesktopAppData>> m_appsMap;
-  QCheckBox* m_keepOpenCheckbox;
-  QCheckBox* m_terminalCheckbox;
-  QVBoxLayout* m_layout;
-  QLineEdit* m_lineEdit;
-  QListWidget* m_filterList;
-  QTabWidget* m_tabWidget;
+    DesktopFileParser m_parser;
+    QPixmap m_pixmap;
+    QString m_tempFile;
+    bool m_keepOpen;
+    QMap<QString, QVector<DesktopAppData>> m_appsMap;
+    QCheckBox* m_keepOpenCheckbox;
+    QCheckBox* m_terminalCheckbox;
+    QVBoxLayout* m_layout;
+    QLineEdit* m_lineEdit;
+    QListWidget* m_filterList;
+    QTabWidget* m_tabWidget;
 };
diff --git a/src/tools/launcher/launcheritemdelegate.cpp b/src/tools/launcher/launcheritemdelegate.cpp
index c7fd5a38..51fcadf9 100644
--- a/src/tools/launcher/launcheritemdelegate.cpp
+++ b/src/tools/launcher/launcheritemdelegate.cpp
@@ -23,45 +23,44 @@ LauncherItemDelegate::LauncherItemDelegate(QObject* parent)
   : QStyledItemDelegate(parent)
 {}
 
-void
-LauncherItemDelegate::paint(QPainter* painter,
-                            const QStyleOptionViewItem& option,
-                            const QModelIndex& index) const
+void LauncherItemDelegate::paint(QPainter* painter,
+                                 const QStyleOptionViewItem& option,
+                                 const QModelIndex& index) const
 {
-  const QRect& rect = option.rect;
-  if (option.state & (QStyle::State_Selected | QStyle::State_MouseOver)) {
-    painter->save();
-    painter->setPen(Qt::transparent);
-    painter->setBrush(QPalette().highlight());
-    painter->drawRect(rect.x(), rect.y(), rect.width() - 1, rect.height() - 1);
-    painter->restore();
-  }
-  QIcon icon = index.data(Qt::DecorationRole).value<QIcon>();
+    const QRect& rect = option.rect;
+    if (option.state & (QStyle::State_Selected | QStyle::State_MouseOver)) {
+        painter->save();
+        painter->setPen(Qt::transparent);
+        painter->setBrush(QPalette().highlight());
+        painter->drawRect(
+          rect.x(), rect.y(), rect.width() - 1, rect.height() - 1);
+        painter->restore();
+    }
+    QIcon icon = index.data(Qt::DecorationRole).value<QIcon>();
 
-  const int iconSide = GlobalValues::buttonBaseSize() * 1.3;
-  const int halfIcon = iconSide / 2;
-  const int halfWidth = rect.width() / 2;
-  const int halfHeight = rect.height() / 2;
-  QSize size(iconSide, iconSide);
-  QPixmap pixIcon = icon.pixmap(size).scaled(size, Qt::KeepAspectRatio);
-  painter->drawPixmap(rect.x() + (halfWidth - halfIcon),
-                      rect.y() + (halfHeight / 2 - halfIcon),
-                      iconSide,
-                      iconSide,
-                      pixIcon);
-  const QRect textRect(
-    rect.x(), rect.y() + halfHeight, rect.width(), halfHeight);
-  painter->drawText(textRect,
-                    Qt::TextWordWrap | Qt::AlignHCenter,
-                    index.data(Qt::DisplayRole).toString());
+    const int iconSide = GlobalValues::buttonBaseSize() * 1.3;
+    const int halfIcon = iconSide / 2;
+    const int halfWidth = rect.width() / 2;
+    const int halfHeight = rect.height() / 2;
+    QSize size(iconSide, iconSide);
+    QPixmap pixIcon = icon.pixmap(size).scaled(size, Qt::KeepAspectRatio);
+    painter->drawPixmap(rect.x() + (halfWidth - halfIcon),
+                        rect.y() + (halfHeight / 2 - halfIcon),
+                        iconSide,
+                        iconSide,
+                        pixIcon);
+    const QRect textRect(
+      rect.x(), rect.y() + halfHeight, rect.width(), halfHeight);
+    painter->drawText(textRect,
+                      Qt::TextWordWrap | Qt::AlignHCenter,
+                      index.data(Qt::DisplayRole).toString());
 }
 
-QSize
-LauncherItemDelegate::sizeHint(const QStyleOptionViewItem& option,
-                               const QModelIndex& index) const
+QSize LauncherItemDelegate::sizeHint(const QStyleOptionViewItem& option,
+                                     const QModelIndex& index) const
 {
-  Q_UNUSED(option);
-  Q_UNUSED(index);
-  const int size = GlobalValues::buttonBaseSize();
-  return QSize(size * 3.2, size * 3.7);
+    Q_UNUSED(option);
+    Q_UNUSED(index);
+    const int size = GlobalValues::buttonBaseSize();
+    return QSize(size * 3.2, size * 3.7);
 }
diff --git a/src/tools/launcher/launcheritemdelegate.h b/src/tools/launcher/launcheritemdelegate.h
index 3360edc0..538179c5 100644
--- a/src/tools/launcher/launcheritemdelegate.h
+++ b/src/tools/launcher/launcheritemdelegate.h
@@ -22,14 +22,14 @@
 
 class LauncherItemDelegate : public QStyledItemDelegate
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit LauncherItemDelegate(QObject* parent = nullptr);
+    explicit LauncherItemDelegate(QObject* parent = nullptr);
 
-  void paint(QPainter* painter,
-             const QStyleOptionViewItem& option,
-             const QModelIndex& index) const;
+    void paint(QPainter* painter,
+               const QStyleOptionViewItem& option,
+               const QModelIndex& index) const;
 
-  QSize sizeHint(const QStyleOptionViewItem& option,
-                 const QModelIndex& index) const;
+    QSize sizeHint(const QStyleOptionViewItem& option,
+                   const QModelIndex& index) const;
 };
diff --git a/src/tools/launcher/openwithprogram.cpp b/src/tools/launcher/openwithprogram.cpp
index 8d69257f..3fbd0e1c 100644
--- a/src/tools/launcher/openwithprogram.cpp
+++ b/src/tools/launcher/openwithprogram.cpp
@@ -33,28 +33,28 @@
 #include "src/tools/launcher/applauncherwidget.h"
 #endif
 
-void
-showOpenWithMenu(const QPixmap& capture)
+void showOpenWithMenu(const QPixmap& capture)
 {
 #if defined(Q_OS_WIN)
-  QString tempFile =
-    FileNameHandler().generateAbsolutePath(QDir::tempPath()) + ".png";
-  bool ok = capture.save(tempFile);
-  if (!ok) {
-    QMessageBox::about(nullptr,
-                       QObject::tr("Error"),
-                       QObject::tr("Unable to write in") + QDir::tempPath());
-    return;
-  }
+    QString tempFile =
+      FileNameHandler().generateAbsolutePath(QDir::tempPath()) + ".png";
+    bool ok = capture.save(tempFile);
+    if (!ok) {
+        QMessageBox::about(nullptr,
+                           QObject::tr("Error"),
+                           QObject::tr("Unable to write in") +
+                             QDir::tempPath());
+        return;
+    }
 
-  OPENASINFO info;
-  auto wStringFile = tempFile.replace("/", "\\").toStdWString();
-  info.pcszFile = wStringFile.c_str();
-  info.pcszClass = nullptr;
-  info.oaifInFlags = OAIF_ALLOW_REGISTRATION | OAIF_EXEC;
-  SHOpenWithDialog(nullptr, &info);
+    OPENASINFO info;
+    auto wStringFile = tempFile.replace("/", "\\").toStdWString();
+    info.pcszFile = wStringFile.c_str();
+    info.pcszClass = nullptr;
+    info.oaifInFlags = OAIF_ALLOW_REGISTRATION | OAIF_EXEC;
+    SHOpenWithDialog(nullptr, &info);
 #else
-  auto w = new AppLauncherWidget(capture);
-  w->show();
+    auto w = new AppLauncherWidget(capture);
+    w->show();
 #endif
 }
diff --git a/src/tools/launcher/openwithprogram.h b/src/tools/launcher/openwithprogram.h
index 5aa9b24c..40396a67 100644
--- a/src/tools/launcher/openwithprogram.h
+++ b/src/tools/launcher/openwithprogram.h
@@ -19,5 +19,4 @@
 
 #include <QPixmap>
 
-void
-showOpenWithMenu(const QPixmap& capture);
+void showOpenWithMenu(const QPixmap& capture);
diff --git a/src/tools/launcher/terminallauncher.cpp b/src/tools/launcher/terminallauncher.cpp
index e7a27d43..32afb563 100644
--- a/src/tools/launcher/terminallauncher.cpp
+++ b/src/tools/launcher/terminallauncher.cpp
@@ -23,18 +23,18 @@
 
 namespace {
 static const TerminalApp terminalApps[] = {
-  { "x-terminal-emulator", "-e" },
-  { "xfce4-terminal", "-x" },
-  { "konsole", "-e" },
-  { "gnome-terminal", "--" },
-  { "terminator", "-e" },
-  { "terminology", "-e" },
-  { "tilix", "-e" },
-  { "xterm", "-e" },
-  { "aterm", "-e" },
-  { "Eterm", "-e" },
-  { "rxvt", "-e" },
-  { "urxvt", "-e" },
+    { "x-terminal-emulator", "-e" },
+    { "xfce4-terminal", "-x" },
+    { "konsole", "-e" },
+    { "gnome-terminal", "--" },
+    { "terminator", "-e" },
+    { "terminology", "-e" },
+    { "tilix", "-e" },
+    { "xterm", "-e" },
+    { "aterm", "-e" },
+    { "Eterm", "-e" },
+    { "rxvt", "-e" },
+    { "urxvt", "-e" },
 };
 }
 
@@ -42,24 +42,22 @@ TerminalLauncher::TerminalLauncher(QObject* parent)
   : QObject(parent)
 {}
 
-TerminalApp
-TerminalLauncher::getPreferedTerminal()
+TerminalApp TerminalLauncher::getPreferedTerminal()
 {
-  TerminalApp res;
-  for (const TerminalApp& app : terminalApps) {
-    QString path = QStandardPaths::findExecutable(app.name);
-    if (!path.isEmpty()) {
-      res = app;
-      break;
+    TerminalApp res;
+    for (const TerminalApp& app : terminalApps) {
+        QString path = QStandardPaths::findExecutable(app.name);
+        if (!path.isEmpty()) {
+            res = app;
+            break;
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-bool
-TerminalLauncher::launchDetached(const QString& command)
+bool TerminalLauncher::launchDetached(const QString& command)
 {
-  TerminalApp app = getPreferedTerminal();
-  QString s = app.name + " " + app.arg + " " + command;
-  return QProcess::startDetached(app.name, { app.arg, command });
+    TerminalApp app = getPreferedTerminal();
+    QString s = app.name + " " + app.arg + " " + command;
+    return QProcess::startDetached(app.name, { app.arg, command });
 }
diff --git a/src/tools/launcher/terminallauncher.h b/src/tools/launcher/terminallauncher.h
index c2fbf828..df67ffb5 100644
--- a/src/tools/launcher/terminallauncher.h
+++ b/src/tools/launcher/terminallauncher.h
@@ -21,18 +21,18 @@
 
 struct TerminalApp
 {
-  QString name;
-  QString arg;
+    QString name;
+    QString arg;
 };
 
 class TerminalLauncher : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit TerminalLauncher(QObject* parent = nullptr);
+    explicit TerminalLauncher(QObject* parent = nullptr);
 
-  static bool launchDetached(const QString& command);
+    static bool launchDetached(const QString& command);
 
 private:
-  static TerminalApp getPreferedTerminal();
+    static TerminalApp getPreferedTerminal();
 };
diff --git a/src/tools/line/linetool.cpp b/src/tools/line/linetool.cpp
index de15ae91..c5f402a0 100644
--- a/src/tools/line/linetool.cpp
+++ b/src/tools/line/linetool.cpp
@@ -27,68 +27,62 @@ namespace {
 LineTool::LineTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_supportsOrthogonalAdj = true;
-  m_supportsDiagonalAdj = true;
+    m_supportsOrthogonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-QIcon
-LineTool::icon(const QColor& background, bool inEditor) const
+QIcon LineTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "line.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "line.svg");
 }
-QString
-LineTool::name() const
+QString LineTool::name() const
 {
-  return tr("Line");
+    return tr("Line");
 }
 
-ToolType
-LineTool::nameID() const
+ToolType LineTool::nameID() const
 {
-  return ToolType::LINE;
+    return ToolType::LINE;
 }
 
-QString
-LineTool::description() const
+QString LineTool::description() const
 {
-  return tr("Set the Line as the paint tool");
+    return tr("Set the Line as the paint tool");
 }
 
-CaptureTool*
-LineTool::copy(QObject* parent)
+CaptureTool* LineTool::copy(QObject* parent)
 {
-  return new LineTool(parent);
+    return new LineTool(parent);
 }
 
-void
-LineTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void LineTool::process(QPainter& painter,
+                       const QPixmap& pixmap,
+                       bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawLine(m_points.first, m_points.second);
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawLine(m_points.first, m_points.second);
 }
 
-void
-LineTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void LineTool::paintMousePreview(QPainter& painter,
+                                 const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-LineTool::drawStart(const CaptureContext& context)
+void LineTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-LineTool::pressed(const CaptureContext& context)
+void LineTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/line/linetool.h b/src/tools/line/linetool.h
index 02b63792..e312d5a0 100644
--- a/src/tools/line/linetool.h
+++ b/src/tools/line/linetool.h
@@ -21,25 +21,25 @@
 
 class LineTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit LineTool(QObject* parent = nullptr);
+    explicit LineTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/marker/markertool.cpp b/src/tools/marker/markertool.cpp
index 135f6db2..f0503960 100644
--- a/src/tools/marker/markertool.cpp
+++ b/src/tools/marker/markertool.cpp
@@ -27,78 +27,71 @@ namespace {
 MarkerTool::MarkerTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_supportsOrthogonalAdj = true;
-  m_supportsDiagonalAdj = true;
+    m_supportsOrthogonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-QIcon
-MarkerTool::icon(const QColor& background, bool inEditor) const
+QIcon MarkerTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "marker.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "marker.svg");
 }
-QString
-MarkerTool::name() const
+QString MarkerTool::name() const
 {
-  return tr("Marker");
+    return tr("Marker");
 }
 
-ToolType
-MarkerTool::nameID() const
+ToolType MarkerTool::nameID() const
 {
-  return ToolType::MARKER;
+    return ToolType::MARKER;
 }
 
-QString
-MarkerTool::description() const
+QString MarkerTool::description() const
 {
-  return tr("Set the Marker as the paint tool");
+    return tr("Set the Marker as the paint tool");
 }
 
-CaptureTool*
-MarkerTool::copy(QObject* parent)
+CaptureTool* MarkerTool::copy(QObject* parent)
 {
-  return new MarkerTool(parent);
+    return new MarkerTool(parent);
 }
 
-void
-MarkerTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void MarkerTool::process(QPainter& painter,
+                         const QPixmap& pixmap,
+                         bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setCompositionMode(QPainter::CompositionMode_Multiply);
-  painter.setOpacity(0.35);
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawLine(m_points.first, m_points.second);
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setCompositionMode(QPainter::CompositionMode_Multiply);
+    painter.setOpacity(0.35);
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawLine(m_points.first, m_points.second);
 }
 
-void
-MarkerTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void MarkerTool::paintMousePreview(QPainter& painter,
+                                   const CaptureContext& context)
 {
-  painter.setCompositionMode(QPainter::CompositionMode_Multiply);
-  painter.setOpacity(0.35);
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setCompositionMode(QPainter::CompositionMode_Multiply);
+    painter.setOpacity(0.35);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-MarkerTool::drawStart(const CaptureContext& context)
+void MarkerTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-MarkerTool::pressed(const CaptureContext& context)
+void MarkerTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
 
-void
-MarkerTool::thicknessChanged(const int th)
+void MarkerTool::thicknessChanged(const int th)
 {
-  m_thickness = th + PADDING_VALUE;
+    m_thickness = th + PADDING_VALUE;
 }
diff --git a/src/tools/marker/markertool.h b/src/tools/marker/markertool.h
index 7c1b378c..a15791af 100644
--- a/src/tools/marker/markertool.h
+++ b/src/tools/marker/markertool.h
@@ -21,26 +21,26 @@
 
 class MarkerTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit MarkerTool(QObject* parent = nullptr);
+    explicit MarkerTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
-  void thicknessChanged(const int th) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
+    void thicknessChanged(const int th) override;
 };
diff --git a/src/tools/move/movetool.cpp b/src/tools/move/movetool.cpp
index 5b7f15ca..24e2d858 100644
--- a/src/tools/move/movetool.cpp
+++ b/src/tools/move/movetool.cpp
@@ -22,45 +22,38 @@ MoveTool::MoveTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-MoveTool::closeOnButtonPressed() const
+bool MoveTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-MoveTool::icon(const QColor& background, bool inEditor) const
+QIcon MoveTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "cursor-move.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "cursor-move.svg");
 }
-QString
-MoveTool::name() const
+QString MoveTool::name() const
 {
-  return tr("Move");
+    return tr("Move");
 }
 
-ToolType
-MoveTool::nameID() const
+ToolType MoveTool::nameID() const
 {
-  return ToolType::MOVE;
+    return ToolType::MOVE;
 }
 
-QString
-MoveTool::description() const
+QString MoveTool::description() const
 {
-  return tr("Move the selection area");
+    return tr("Move the selection area");
 }
 
-CaptureTool*
-MoveTool::copy(QObject* parent)
+CaptureTool* MoveTool::copy(QObject* parent)
 {
-  return new MoveTool(parent);
+    return new MoveTool(parent);
 }
 
-void
-MoveTool::pressed(const CaptureContext& context)
+void MoveTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
-  emit requestAction(REQ_MOVE_MODE);
+    Q_UNUSED(context);
+    emit requestAction(REQ_MOVE_MODE);
 }
diff --git a/src/tools/move/movetool.h b/src/tools/move/movetool.h
index 358f19f8..dd36d98d 100644
--- a/src/tools/move/movetool.h
+++ b/src/tools/move/movetool.h
@@ -21,19 +21,19 @@
 
 class MoveTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit MoveTool(QObject* parent = nullptr);
+    explicit MoveTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  ToolType nameID() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    ToolType nameID() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/pencil/penciltool.cpp b/src/tools/pencil/penciltool.cpp
index 74d4ea89..77961dbd 100644
--- a/src/tools/pencil/penciltool.cpp
+++ b/src/tools/pencil/penciltool.cpp
@@ -22,65 +22,59 @@ PencilTool::PencilTool(QObject* parent)
   : AbstractPathTool(parent)
 {}
 
-QIcon
-PencilTool::icon(const QColor& background, bool inEditor) const
+QIcon PencilTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "pencil.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "pencil.svg");
 }
-QString
-PencilTool::name() const
+QString PencilTool::name() const
 {
-  return tr("Pencil");
+    return tr("Pencil");
 }
 
-ToolType
-PencilTool::nameID() const
+ToolType PencilTool::nameID() const
 {
-  return ToolType::PENCIL;
+    return ToolType::PENCIL;
 }
 
-QString
-PencilTool::description() const
+QString PencilTool::description() const
 {
-  return tr("Set the Pencil as the paint tool");
+    return tr("Set the Pencil as the paint tool");
 }
 
-CaptureTool*
-PencilTool::copy(QObject* parent)
+CaptureTool* PencilTool::copy(QObject* parent)
 {
-  return new PencilTool(parent);
+    return new PencilTool(parent);
 }
 
-void
-PencilTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void PencilTool::process(QPainter& painter,
+                         const QPixmap& pixmap,
+                         bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawPolyline(m_points.data(), m_points.size());
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawPolyline(m_points.data(), m_points.size());
 }
 
-void
-PencilTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void PencilTool::paintMousePreview(QPainter& painter,
+                                   const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, context.thickness + 2));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, context.thickness + 2));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-PencilTool::drawStart(const CaptureContext& context)
+void PencilTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + 2;
-  m_points.append(context.mousePos);
-  m_backupArea.setTopLeft(context.mousePos);
-  m_backupArea.setBottomRight(context.mousePos);
+    m_color = context.color;
+    m_thickness = context.thickness + 2;
+    m_points.append(context.mousePos);
+    m_backupArea.setTopLeft(context.mousePos);
+    m_backupArea.setBottomRight(context.mousePos);
 }
 
-void
-PencilTool::pressed(const CaptureContext& context)
+void PencilTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/pencil/penciltool.h b/src/tools/pencil/penciltool.h
index fabba6bd..63dc0de0 100644
--- a/src/tools/pencil/penciltool.h
+++ b/src/tools/pencil/penciltool.h
@@ -21,26 +21,26 @@
 
 class PencilTool : public AbstractPathTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit PencilTool(QObject* parent = nullptr);
+    explicit PencilTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/pin/pintool.cpp b/src/tools/pin/pintool.cpp
index 455443df..613bd32d 100644
--- a/src/tools/pin/pintool.cpp
+++ b/src/tools/pin/pintool.cpp
@@ -22,58 +22,50 @@ PinTool::PinTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-PinTool::closeOnButtonPressed() const
+bool PinTool::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-PinTool::icon(const QColor& background, bool inEditor) const
+QIcon PinTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "pin.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "pin.svg");
 }
-QString
-PinTool::name() const
+QString PinTool::name() const
 {
-  return tr("Pin Tool");
+    return tr("Pin Tool");
 }
 
-ToolType
-PinTool::nameID() const
+ToolType PinTool::nameID() const
 {
-  return ToolType::PIN;
+    return ToolType::PIN;
 }
 
-QString
-PinTool::description() const
+QString PinTool::description() const
 {
-  return tr("Pin image on the desktop");
+    return tr("Pin image on the desktop");
 }
 
-QWidget*
-PinTool::widget()
+QWidget* PinTool::widget()
 {
-  PinWidget* w = new PinWidget(m_pixmap);
-  const int&& m = w->margin();
-  QRect adjusted_pos = m_geometry + QMargins(m, m, m, m);
-  w->setGeometry(adjusted_pos);
-  return w;
+    PinWidget* w = new PinWidget(m_pixmap);
+    const int&& m = w->margin();
+    QRect adjusted_pos = m_geometry + QMargins(m, m, m, m);
+    w->setGeometry(adjusted_pos);
+    return w;
 }
 
-CaptureTool*
-PinTool::copy(QObject* parent)
+CaptureTool* PinTool::copy(QObject* parent)
 {
-  return new PinTool(parent);
+    return new PinTool(parent);
 }
 
-void
-PinTool::pressed(const CaptureContext& context)
+void PinTool::pressed(const CaptureContext& context)
 {
-  emit requestAction(REQ_CAPTURE_DONE_OK);
-  m_geometry = context.selection;
-  m_geometry.setTopLeft(m_geometry.topLeft() + context.widgetOffset);
-  m_pixmap = context.selectedScreenshotArea();
-  emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
+    emit requestAction(REQ_CAPTURE_DONE_OK);
+    m_geometry = context.selection;
+    m_geometry.setTopLeft(m_geometry.topLeft() + context.widgetOffset);
+    m_pixmap = context.selectedScreenshotArea();
+    emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);
 }
diff --git a/src/tools/pin/pintool.h b/src/tools/pin/pintool.h
index 7ff993c3..0192f53d 100644
--- a/src/tools/pin/pintool.h
+++ b/src/tools/pin/pintool.h
@@ -21,27 +21,27 @@
 
 class PinTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit PinTool(QObject* parent = nullptr);
+    explicit PinTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  QWidget* widget() override;
+    QWidget* widget() override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 
 private:
-  QRect m_geometry;
-  QPixmap m_pixmap;
+    QRect m_geometry;
+    QPixmap m_pixmap;
 };
diff --git a/src/tools/pin/pinwidget.cpp b/src/tools/pin/pinwidget.cpp
index d50288ce..4c95ed06 100644
--- a/src/tools/pin/pinwidget.cpp
+++ b/src/tools/pin/pinwidget.cpp
@@ -27,93 +27,85 @@ PinWidget::PinWidget(const QPixmap& pixmap, QWidget* parent)
   : QWidget(parent)
   , m_pixmap(pixmap)
 {
-  setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint);
-  // set the bottom widget background transparent
-  setAttribute(Qt::WA_TranslucentBackground);
-
-  ConfigHandler conf;
-  m_baseColor = conf.uiMainColorValue();
-  m_hoverColor = conf.uiContrastColorValue();
-
-  m_layout = new QVBoxLayout(this);
-  const int margin = this->margin();
-  m_layout->setContentsMargins(margin, margin, margin, margin);
-
-  m_shadowEffect = new QGraphicsDropShadowEffect(this);
-  m_shadowEffect->setColor(m_baseColor);
-  m_shadowEffect->setBlurRadius(2 * margin);
-  m_shadowEffect->setOffset(0, 0);
-  setGraphicsEffect(m_shadowEffect);
-
-  m_label = new QLabel();
-  m_label->setPixmap(m_pixmap);
-  m_layout->addWidget(m_label);
-
-  new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close()));
-  new QShortcut(Qt::Key_Escape, this, SLOT(close()));
+    setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint);
+    // set the bottom widget background transparent
+    setAttribute(Qt::WA_TranslucentBackground);
+
+    ConfigHandler conf;
+    m_baseColor = conf.uiMainColorValue();
+    m_hoverColor = conf.uiContrastColorValue();
+
+    m_layout = new QVBoxLayout(this);
+    const int margin = this->margin();
+    m_layout->setContentsMargins(margin, margin, margin, margin);
+
+    m_shadowEffect = new QGraphicsDropShadowEffect(this);
+    m_shadowEffect->setColor(m_baseColor);
+    m_shadowEffect->setBlurRadius(2 * margin);
+    m_shadowEffect->setOffset(0, 0);
+    setGraphicsEffect(m_shadowEffect);
+
+    m_label = new QLabel();
+    m_label->setPixmap(m_pixmap);
+    m_layout->addWidget(m_label);
+
+    new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close()));
+    new QShortcut(Qt::Key_Escape, this, SLOT(close()));
 }
 
-int
-PinWidget::margin() const
+int PinWidget::margin() const
 {
-  return 7;
+    return 7;
 }
 
-void
-PinWidget::wheelEvent(QWheelEvent* e)
+void PinWidget::wheelEvent(QWheelEvent* e)
 {
-  int val = e->angleDelta().y() > 0 ? 15 : -15;
-  int newWidth = qBound(50, m_label->width() + val, maximumWidth());
-  int newHeight = qBound(50, m_label->height() + val, maximumHeight());
+    int val = e->angleDelta().y() > 0 ? 15 : -15;
+    int newWidth = qBound(50, m_label->width() + val, maximumWidth());
+    int newHeight = qBound(50, m_label->height() + val, maximumHeight());
 
-  QSize size(newWidth, newHeight);
-  setScaledPixmap(size);
-  adjustSize();
+    QSize size(newWidth, newHeight);
+    setScaledPixmap(size);
+    adjustSize();
 
-  e->accept();
+    e->accept();
 }
 
-void
-PinWidget::enterEvent(QEvent*)
+void PinWidget::enterEvent(QEvent*)
 {
-  m_shadowEffect->setColor(m_hoverColor);
+    m_shadowEffect->setColor(m_hoverColor);
 }
-void
-PinWidget::leaveEvent(QEvent*)
+void PinWidget::leaveEvent(QEvent*)
 {
-  m_shadowEffect->setColor(m_baseColor);
+    m_shadowEffect->setColor(m_baseColor);
 }
 
-void
-PinWidget::mouseDoubleClickEvent(QMouseEvent*)
+void PinWidget::mouseDoubleClickEvent(QMouseEvent*)
 {
-  close();
+    close();
 }
 
-void
-PinWidget::mousePressEvent(QMouseEvent* e)
+void PinWidget::mousePressEvent(QMouseEvent* e)
 {
-  m_dragStart = e->globalPos();
-  m_offsetX = e->localPos().x() / width();
-  m_offsetY = e->localPos().y() / height();
+    m_dragStart = e->globalPos();
+    m_offsetX = e->localPos().x() / width();
+    m_offsetY = e->localPos().y() / height();
 }
 
-void
-PinWidget::mouseMoveEvent(QMouseEvent* e)
+void PinWidget::mouseMoveEvent(QMouseEvent* e)
 {
-  const QPoint delta = e->globalPos() - m_dragStart;
-  int offsetW = width() * m_offsetX;
-  int offsetH = height() * m_offsetY;
-  move(m_dragStart.x() + delta.x() - offsetW,
-       m_dragStart.y() + delta.y() - offsetH);
+    const QPoint delta = e->globalPos() - m_dragStart;
+    int offsetW = width() * m_offsetX;
+    int offsetH = height() * m_offsetY;
+    move(m_dragStart.x() + delta.x() - offsetW,
+         m_dragStart.y() + delta.y() - offsetH);
 }
 
-void
-PinWidget::setScaledPixmap(const QSize& size)
+void PinWidget::setScaledPixmap(const QSize& size)
 {
-  const qreal scale = qApp->devicePixelRatio();
-  QPixmap scaledPixmap = m_pixmap.scaled(
-    size * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation);
-  scaledPixmap.setDevicePixelRatio(scale);
-  m_label->setPixmap(scaledPixmap);
+    const qreal scale = qApp->devicePixelRatio();
+    QPixmap scaledPixmap = m_pixmap.scaled(
+      size * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+    scaledPixmap.setDevicePixelRatio(scale);
+    m_label->setPixmap(scaledPixmap);
 }
diff --git a/src/tools/pin/pinwidget.h b/src/tools/pin/pinwidget.h
index 435b72da..893c4888 100644
--- a/src/tools/pin/pinwidget.h
+++ b/src/tools/pin/pinwidget.h
@@ -25,28 +25,28 @@ class QLabel;
 
 class PinWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit PinWidget(const QPixmap& pixmap, QWidget* parent = nullptr);
+    explicit PinWidget(const QPixmap& pixmap, QWidget* parent = nullptr);
 
-  int margin() const;
+    int margin() const;
 
 protected:
-  void wheelEvent(QWheelEvent* e);
-  void mouseDoubleClickEvent(QMouseEvent*);
-  void mousePressEvent(QMouseEvent*);
-  void mouseMoveEvent(QMouseEvent*);
-  void enterEvent(QEvent*);
-  void leaveEvent(QEvent*);
+    void wheelEvent(QWheelEvent* e);
+    void mouseDoubleClickEvent(QMouseEvent*);
+    void mousePressEvent(QMouseEvent*);
+    void mouseMoveEvent(QMouseEvent*);
+    void enterEvent(QEvent*);
+    void leaveEvent(QEvent*);
 
 private:
-  void setScaledPixmap(const QSize& size);
-
-  QPixmap m_pixmap;
-  QVBoxLayout* m_layout;
-  QLabel* m_label;
-  QPoint m_dragStart;
-  qreal m_offsetX, m_offsetY;
-  QGraphicsDropShadowEffect* m_shadowEffect;
-  QColor m_baseColor, m_hoverColor;
+    void setScaledPixmap(const QSize& size);
+
+    QPixmap m_pixmap;
+    QVBoxLayout* m_layout;
+    QLabel* m_label;
+    QPoint m_dragStart;
+    qreal m_offsetX, m_offsetY;
+    QGraphicsDropShadowEffect* m_shadowEffect;
+    QColor m_baseColor, m_hoverColor;
 };
diff --git a/src/tools/pixelate/pixelatetool.cpp b/src/tools/pixelate/pixelatetool.cpp
index 45fa6a64..6f742279 100644
--- a/src/tools/pixelate/pixelatetool.cpp
+++ b/src/tools/pixelate/pixelatetool.cpp
@@ -28,95 +28,88 @@ PixelateTool::PixelateTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {}
 
-QIcon
-PixelateTool::icon(const QColor& background, bool inEditor) const
+QIcon PixelateTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "pixelate.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "pixelate.svg");
 }
-QString
-PixelateTool::name() const
+QString PixelateTool::name() const
 {
-  return tr("Pixelate");
+    return tr("Pixelate");
 }
 
-ToolType
-PixelateTool::nameID() const
+ToolType PixelateTool::nameID() const
 {
-  return ToolType::PIXELATE;
+    return ToolType::PIXELATE;
 }
 
-QString
-PixelateTool::description() const
+QString PixelateTool::description() const
 {
-  return tr("Set Pixelate as the paint tool");
+    return tr("Set Pixelate as the paint tool");
 }
 
-CaptureTool*
-PixelateTool::copy(QObject* parent)
+CaptureTool* PixelateTool::copy(QObject* parent)
 {
-  return new PixelateTool(parent);
+    return new PixelateTool(parent);
 }
 
-void
-PixelateTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void PixelateTool::process(QPainter& painter,
+                           const QPixmap& pixmap,
+                           bool recordUndo)
 {
 
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-
-  QPoint& p0 = m_points.first;
-  QPoint& p1 = m_points.second;
-  QRect selection = QRect(p0, p1).normalized();
-
-  // If thickness is less than 1, use old blur process
-  if (m_thickness <= 1) {
-    auto pixelRatio = pixmap.devicePixelRatio();
-
-    QRect selectionScaled =
-      QRect(p0 * pixelRatio, p1 * pixelRatio).normalized();
-
-    QGraphicsBlurEffect* blur = new QGraphicsBlurEffect;
-    blur->setBlurRadius(10);
-    QGraphicsPixmapItem* item =
-      new QGraphicsPixmapItem(pixmap.copy(selectionScaled));
-    item->setGraphicsEffect(blur);
-
-    QGraphicsScene scene;
-    scene.addItem(item);
-
-    scene.render(&painter, selection, QRectF());
-    blur->setBlurRadius(12);
-    scene.render(&painter, selection, QRectF());
-  } else {
-    int width = selection.width() * (0.5 / qMax(1, m_thickness));
-
-    QPixmap t = pixmap.copy(selection);
-    t = t.scaledToWidth(qMax(width, 10), Qt::SmoothTransformation);
-    t = t.scaledToWidth(selection.width());
-    painter.drawImage(selection, t.toImage());
-  }
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+
+    QPoint& p0 = m_points.first;
+    QPoint& p1 = m_points.second;
+    QRect selection = QRect(p0, p1).normalized();
+
+    // If thickness is less than 1, use old blur process
+    if (m_thickness <= 1) {
+        auto pixelRatio = pixmap.devicePixelRatio();
+
+        QRect selectionScaled =
+          QRect(p0 * pixelRatio, p1 * pixelRatio).normalized();
+
+        QGraphicsBlurEffect* blur = new QGraphicsBlurEffect;
+        blur->setBlurRadius(10);
+        QGraphicsPixmapItem* item =
+          new QGraphicsPixmapItem(pixmap.copy(selectionScaled));
+        item->setGraphicsEffect(blur);
+
+        QGraphicsScene scene;
+        scene.addItem(item);
+
+        scene.render(&painter, selection, QRectF());
+        blur->setBlurRadius(12);
+        scene.render(&painter, selection, QRectF());
+    } else {
+        int width = selection.width() * (0.5 / qMax(1, m_thickness));
+
+        QPixmap t = pixmap.copy(selection);
+        t = t.scaledToWidth(qMax(width, 10), Qt::SmoothTransformation);
+        t = t.scaledToWidth(selection.width());
+        painter.drawImage(selection, t.toImage());
+    }
 }
 
-void
-PixelateTool::paintMousePreview(QPainter& painter,
-                                const CaptureContext& context)
+void PixelateTool::paintMousePreview(QPainter& painter,
+                                     const CaptureContext& context)
 {
-  Q_UNUSED(context);
-  Q_UNUSED(painter);
+    Q_UNUSED(context);
+    Q_UNUSED(painter);
 }
 
-void
-PixelateTool::drawStart(const CaptureContext& context)
+void PixelateTool::drawStart(const CaptureContext& context)
 {
-  m_thickness = context.thickness;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_thickness = context.thickness;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-PixelateTool::pressed(const CaptureContext& context)
+void PixelateTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/pixelate/pixelatetool.h b/src/tools/pixelate/pixelatetool.h
index d1b1753f..9336819d 100644
--- a/src/tools/pixelate/pixelatetool.h
+++ b/src/tools/pixelate/pixelatetool.h
@@ -21,25 +21,25 @@
 
 class PixelateTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit PixelateTool(QObject* parent = nullptr);
+    explicit PixelateTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/rectangle/rectangletool.cpp b/src/tools/rectangle/rectangletool.cpp
index 0648d887..ec50273f 100644
--- a/src/tools/rectangle/rectangletool.cpp
+++ b/src/tools/rectangle/rectangletool.cpp
@@ -25,71 +25,62 @@ namespace {
 RectangleTool::RectangleTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_supportsDiagonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-QIcon
-RectangleTool::icon(const QColor& background, bool inEditor) const
+QIcon RectangleTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "square.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "square.svg");
 }
-QString
-RectangleTool::name() const
+QString RectangleTool::name() const
 {
-  return tr("Rectangle");
+    return tr("Rectangle");
 }
 
-ToolType
-RectangleTool::nameID() const
+ToolType RectangleTool::nameID() const
 {
-  return ToolType::RECTANGLE;
+    return ToolType::RECTANGLE;
 }
 
-QString
-RectangleTool::description() const
+QString RectangleTool::description() const
 {
-  return tr("Set the Rectangle as the paint tool");
+    return tr("Set the Rectangle as the paint tool");
 }
 
-CaptureTool*
-RectangleTool::copy(QObject* parent)
+CaptureTool* RectangleTool::copy(QObject* parent)
 {
-  return new RectangleTool(parent);
+    return new RectangleTool(parent);
 }
 
-void
-RectangleTool::process(QPainter& painter,
-                       const QPixmap& pixmap,
-                       bool recordUndo)
+void RectangleTool::process(QPainter& painter,
+                            const QPixmap& pixmap,
+                            bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.setBrush(QBrush(m_color));
-  painter.drawRect(QRect(m_points.first, m_points.second));
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.setBrush(QBrush(m_color));
+    painter.drawRect(QRect(m_points.first, m_points.second));
 }
 
-void
-RectangleTool::paintMousePreview(QPainter& painter,
-                                 const CaptureContext& context)
+void RectangleTool::paintMousePreview(QPainter& painter,
+                                      const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-RectangleTool::drawStart(const CaptureContext& context)
+void RectangleTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-RectangleTool::pressed(const CaptureContext& context)
+void RectangleTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/rectangle/rectangletool.h b/src/tools/rectangle/rectangletool.h
index 2fe2a949..fc936c9f 100644
--- a/src/tools/rectangle/rectangletool.h
+++ b/src/tools/rectangle/rectangletool.h
@@ -21,25 +21,25 @@
 
 class RectangleTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit RectangleTool(QObject* parent = nullptr);
+    explicit RectangleTool(QObject* parent = nullptr);
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/redo/redotool.cpp b/src/tools/redo/redotool.cpp
index 3aca17f0..1c35b355 100644
--- a/src/tools/redo/redotool.cpp
+++ b/src/tools/redo/redotool.cpp
@@ -22,45 +22,38 @@ RedoTool::RedoTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-RedoTool::closeOnButtonPressed() const
+bool RedoTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-RedoTool::icon(const QColor& background, bool inEditor) const
+QIcon RedoTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "redo-variant.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "redo-variant.svg");
 }
-QString
-RedoTool::name() const
+QString RedoTool::name() const
 {
-  return tr("Redo");
+    return tr("Redo");
 }
 
-ToolType
-RedoTool::nameID() const
+ToolType RedoTool::nameID() const
 {
-  return ToolType::REDO;
+    return ToolType::REDO;
 }
 
-QString
-RedoTool::description() const
+QString RedoTool::description() const
 {
-  return tr("Redo the next modification");
+    return tr("Redo the next modification");
 }
 
-CaptureTool*
-RedoTool::copy(QObject* parent)
+CaptureTool* RedoTool::copy(QObject* parent)
 {
-  return new RedoTool(parent);
+    return new RedoTool(parent);
 }
 
-void
-RedoTool::pressed(const CaptureContext& context)
+void RedoTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
-  emit requestAction(REQ_REDO_MODIFICATION);
+    Q_UNUSED(context);
+    emit requestAction(REQ_REDO_MODIFICATION);
 }
diff --git a/src/tools/redo/redotool.h b/src/tools/redo/redotool.h
index 1900779c..4c0791a0 100644
--- a/src/tools/redo/redotool.h
+++ b/src/tools/redo/redotool.h
@@ -21,21 +21,21 @@
 
 class RedoTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit RedoTool(QObject* parent = nullptr);
+    explicit RedoTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/save/savetool.cpp b/src/tools/save/savetool.cpp
index 80c6ceb5..43c194b0 100644
--- a/src/tools/save/savetool.cpp
+++ b/src/tools/save/savetool.cpp
@@ -23,57 +23,50 @@ SaveTool::SaveTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-SaveTool::closeOnButtonPressed() const
+bool SaveTool::closeOnButtonPressed() const
 {
-  return true;
+    return true;
 }
 
-QIcon
-SaveTool::icon(const QColor& background, bool inEditor) const
+QIcon SaveTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "content-save.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "content-save.svg");
 }
-QString
-SaveTool::name() const
+QString SaveTool::name() const
 {
-  return tr("Save");
+    return tr("Save");
 }
 
-ToolType
-SaveTool::nameID() const
+ToolType SaveTool::nameID() const
 {
-  return ToolType::SAVE;
+    return ToolType::SAVE;
 }
 
-QString
-SaveTool::description() const
+QString SaveTool::description() const
 {
-  return tr("Save the capture");
+    return tr("Save the capture");
 }
 
-CaptureTool*
-SaveTool::copy(QObject* parent)
+CaptureTool* SaveTool::copy(QObject* parent)
 {
-  return new SaveTool(parent);
+    return new SaveTool(parent);
 }
 
-void
-SaveTool::pressed(const CaptureContext& context)
+void SaveTool::pressed(const CaptureContext& context)
 {
-  if (context.savePath.isEmpty()) {
-    emit requestAction(REQ_HIDE_GUI);
-    bool ok =
-      ScreenshotSaver().saveToFilesystemGUI(context.selectedScreenshotArea());
-    if (ok) {
-      emit requestAction(REQ_CAPTURE_DONE_OK);
+    if (context.savePath.isEmpty()) {
+        emit requestAction(REQ_HIDE_GUI);
+        bool ok = ScreenshotSaver().saveToFilesystemGUI(
+          context.selectedScreenshotArea());
+        if (ok) {
+            emit requestAction(REQ_CAPTURE_DONE_OK);
+        }
+    } else {
+        bool ok = ScreenshotSaver().saveToFilesystem(
+          context.selectedScreenshotArea(), context.savePath, "");
+        if (ok) {
+            emit requestAction(REQ_CAPTURE_DONE_OK);
+        }
     }
-  } else {
-    bool ok = ScreenshotSaver().saveToFilesystem(
-      context.selectedScreenshotArea(), context.savePath, "");
-    if (ok) {
-      emit requestAction(REQ_CAPTURE_DONE_OK);
-    }
-  }
 }
diff --git a/src/tools/save/savetool.h b/src/tools/save/savetool.h
index 3322ec53..3c79e442 100644
--- a/src/tools/save/savetool.h
+++ b/src/tools/save/savetool.h
@@ -21,21 +21,21 @@
 
 class SaveTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit SaveTool(QObject* parent = nullptr);
+    explicit SaveTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/selection/selectiontool.cpp b/src/tools/selection/selectiontool.cpp
index 0fa45c11..3c28792d 100644
--- a/src/tools/selection/selectiontool.cpp
+++ b/src/tools/selection/selectiontool.cpp
@@ -25,76 +25,66 @@ namespace {
 SelectionTool::SelectionTool(QObject* parent)
   : AbstractTwoPointTool(parent)
 {
-  m_supportsDiagonalAdj = true;
+    m_supportsDiagonalAdj = true;
 }
 
-bool
-SelectionTool::closeOnButtonPressed() const
+bool SelectionTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-SelectionTool::icon(const QColor& background, bool inEditor) const
+QIcon SelectionTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "square-outline.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "square-outline.svg");
 }
-QString
-SelectionTool::name() const
+QString SelectionTool::name() const
 {
-  return tr("Rectangular Selection");
+    return tr("Rectangular Selection");
 }
 
-ToolType
-SelectionTool::nameID() const
+ToolType SelectionTool::nameID() const
 {
-  return ToolType::SELECTION;
+    return ToolType::SELECTION;
 }
 
-QString
-SelectionTool::description() const
+QString SelectionTool::description() const
 {
-  return tr("Set Selection as the paint tool");
+    return tr("Set Selection as the paint tool");
 }
 
-CaptureTool*
-SelectionTool::copy(QObject* parent)
+CaptureTool* SelectionTool::copy(QObject* parent)
 {
-  return new SelectionTool(parent);
+    return new SelectionTool(parent);
 }
 
-void
-SelectionTool::process(QPainter& painter,
-                       const QPixmap& pixmap,
-                       bool recordUndo)
+void SelectionTool::process(QPainter& painter,
+                            const QPixmap& pixmap,
+                            bool recordUndo)
 {
-  if (recordUndo) {
-    updateBackup(pixmap);
-  }
-  painter.setPen(QPen(m_color, m_thickness));
-  painter.drawRect(QRect(m_points.first, m_points.second));
+    if (recordUndo) {
+        updateBackup(pixmap);
+    }
+    painter.setPen(QPen(m_color, m_thickness));
+    painter.drawRect(QRect(m_points.first, m_points.second));
 }
 
-void
-SelectionTool::paintMousePreview(QPainter& painter,
-                                 const CaptureContext& context)
+void SelectionTool::paintMousePreview(QPainter& painter,
+                                      const CaptureContext& context)
 {
-  painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
-  painter.drawLine(context.mousePos, context.mousePos);
+    painter.setPen(QPen(context.color, PADDING_VALUE + context.thickness));
+    painter.drawLine(context.mousePos, context.mousePos);
 }
 
-void
-SelectionTool::drawStart(const CaptureContext& context)
+void SelectionTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_thickness = context.thickness + PADDING_VALUE;
-  m_points.first = context.mousePos;
-  m_points.second = context.mousePos;
+    m_color = context.color;
+    m_thickness = context.thickness + PADDING_VALUE;
+    m_points.first = context.mousePos;
+    m_points.second = context.mousePos;
 }
 
-void
-SelectionTool::pressed(const CaptureContext& context)
+void SelectionTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/selection/selectiontool.h b/src/tools/selection/selectiontool.h
index 822ff47a..f8448dbd 100644
--- a/src/tools/selection/selectiontool.h
+++ b/src/tools/selection/selectiontool.h
@@ -21,27 +21,27 @@
 
 class SelectionTool : public AbstractTwoPointTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit SelectionTool(QObject* parent = nullptr);
+    explicit SelectionTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/sizeindicator/sizeindicatortool.cpp b/src/tools/sizeindicator/sizeindicatortool.cpp
index cda7f761..f3c77ddf 100644
--- a/src/tools/sizeindicator/sizeindicatortool.cpp
+++ b/src/tools/sizeindicator/sizeindicatortool.cpp
@@ -22,44 +22,37 @@ SizeIndicatorTool::SizeIndicatorTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-SizeIndicatorTool::closeOnButtonPressed() const
+bool SizeIndicatorTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-SizeIndicatorTool::icon(const QColor& background, bool inEditor) const
+QIcon SizeIndicatorTool::icon(const QColor& background, bool inEditor) const
 {
-  return inEditor ? QIcon()
-                  : QIcon(iconPath(background) + "size_indicator.svg");
+    return inEditor ? QIcon()
+                    : QIcon(iconPath(background) + "size_indicator.svg");
 }
-QString
-SizeIndicatorTool::name() const
+QString SizeIndicatorTool::name() const
 {
-  return tr("Selection Size Indicator");
+    return tr("Selection Size Indicator");
 }
 
-ToolType
-SizeIndicatorTool::nameID() const
+ToolType SizeIndicatorTool::nameID() const
 {
-  return ToolType::SIZEINDICATOR;
+    return ToolType::SIZEINDICATOR;
 }
 
-QString
-SizeIndicatorTool::description() const
+QString SizeIndicatorTool::description() const
 {
-  return tr("Show the dimensions of the selection (X Y)");
+    return tr("Show the dimensions of the selection (X Y)");
 }
 
-CaptureTool*
-SizeIndicatorTool::copy(QObject* parent)
+CaptureTool* SizeIndicatorTool::copy(QObject* parent)
 {
-  return new SizeIndicatorTool(parent);
+    return new SizeIndicatorTool(parent);
 }
 
-void
-SizeIndicatorTool::pressed(const CaptureContext& context)
+void SizeIndicatorTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
diff --git a/src/tools/sizeindicator/sizeindicatortool.h b/src/tools/sizeindicator/sizeindicatortool.h
index af377811..26fca63c 100644
--- a/src/tools/sizeindicator/sizeindicatortool.h
+++ b/src/tools/sizeindicator/sizeindicatortool.h
@@ -21,21 +21,21 @@
 
 class SizeIndicatorTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit SizeIndicatorTool(QObject* parent = nullptr);
+    explicit SizeIndicatorTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/tools/text/textconfig.cpp b/src/tools/text/textconfig.cpp
index f4eb31c2..1e27cd8e 100644
--- a/src/tools/text/textconfig.cpp
+++ b/src/tools/text/textconfig.cpp
@@ -27,98 +27,93 @@
 TextConfig::TextConfig(QWidget* parent)
   : QWidget(parent)
 {
-  m_layout = new QVBoxLayout(this);
+    m_layout = new QVBoxLayout(this);
 
-  QFontDatabase fontDB;
-  QComboBox* fontsCB = new QComboBox();
-  connect(fontsCB,
-          &QComboBox::currentTextChanged,
-          this,
-          &TextConfig::fontFamilyChanged);
-  fontsCB->addItems(fontDB.families());
-  // TODO save family in config
-  int index = fontsCB->findText(font().family());
-  fontsCB->setCurrentIndex(index);
+    QFontDatabase fontDB;
+    QComboBox* fontsCB = new QComboBox();
+    connect(fontsCB,
+            &QComboBox::currentTextChanged,
+            this,
+            &TextConfig::fontFamilyChanged);
+    fontsCB->addItems(fontDB.families());
+    // TODO save family in config
+    int index = fontsCB->findText(font().family());
+    fontsCB->setCurrentIndex(index);
 
-  QString iconPrefix = ColorUtils::colorIsDark(palette().windowText().color())
-                         ? PathInfo::blackIconPath()
-                         : PathInfo::whiteIconPath();
+    QString iconPrefix = ColorUtils::colorIsDark(palette().windowText().color())
+                           ? PathInfo::blackIconPath()
+                           : PathInfo::whiteIconPath();
 
-  m_strikeOutButton = new QPushButton(
-    QIcon(iconPrefix + "format_strikethrough.svg"), QLatin1String(""));
-  m_strikeOutButton->setCheckable(true);
-  connect(m_strikeOutButton,
-          &QPushButton::clicked,
-          this,
-          &TextConfig::fontStrikeOutChanged);
-  m_strikeOutButton->setToolTip(tr("StrikeOut"));
+    m_strikeOutButton = new QPushButton(
+      QIcon(iconPrefix + "format_strikethrough.svg"), QLatin1String(""));
+    m_strikeOutButton->setCheckable(true);
+    connect(m_strikeOutButton,
+            &QPushButton::clicked,
+            this,
+            &TextConfig::fontStrikeOutChanged);
+    m_strikeOutButton->setToolTip(tr("StrikeOut"));
 
-  m_underlineButton = new QPushButton(
-    QIcon(iconPrefix + "format_underlined.svg"), QLatin1String(""));
-  m_underlineButton->setCheckable(true);
-  connect(m_underlineButton,
-          &QPushButton::clicked,
-          this,
-          &TextConfig::fontUnderlineChanged);
-  m_underlineButton->setToolTip(tr("Underline"));
+    m_underlineButton = new QPushButton(
+      QIcon(iconPrefix + "format_underlined.svg"), QLatin1String(""));
+    m_underlineButton->setCheckable(true);
+    connect(m_underlineButton,
+            &QPushButton::clicked,
+            this,
+            &TextConfig::fontUnderlineChanged);
+    m_underlineButton->setToolTip(tr("Underline"));
 
-  m_weightButton =
-    new QPushButton(QIcon(iconPrefix + "format_bold.svg"), QLatin1String(""));
-  m_weightButton->setCheckable(true);
-  connect(m_weightButton,
-          &QPushButton::clicked,
-          this,
-          &TextConfig::weightButtonPressed);
-  m_weightButton->setToolTip(tr("Bold"));
+    m_weightButton =
+      new QPushButton(QIcon(iconPrefix + "format_bold.svg"), QLatin1String(""));
+    m_weightButton->setCheckable(true);
+    connect(m_weightButton,
+            &QPushButton::clicked,
+            this,
+            &TextConfig::weightButtonPressed);
+    m_weightButton->setToolTip(tr("Bold"));
 
-  m_italicButton =
-    new QPushButton(QIcon(iconPrefix + "format_italic.svg"), QLatin1String(""));
-  m_italicButton->setCheckable(true);
-  connect(m_italicButton,
-          &QPushButton::clicked,
-          this,
-          &TextConfig::fontItalicChanged);
-  m_italicButton->setToolTip(tr("Italic"));
-  QHBoxLayout* modifiersLayout = new QHBoxLayout();
+    m_italicButton = new QPushButton(QIcon(iconPrefix + "format_italic.svg"),
+                                     QLatin1String(""));
+    m_italicButton->setCheckable(true);
+    connect(m_italicButton,
+            &QPushButton::clicked,
+            this,
+            &TextConfig::fontItalicChanged);
+    m_italicButton->setToolTip(tr("Italic"));
+    QHBoxLayout* modifiersLayout = new QHBoxLayout();
 
-  m_layout->addWidget(fontsCB);
-  modifiersLayout->addWidget(m_strikeOutButton);
-  modifiersLayout->addWidget(m_underlineButton);
-  modifiersLayout->addWidget(m_weightButton);
-  modifiersLayout->addWidget(m_italicButton);
-  m_layout->addLayout(modifiersLayout);
+    m_layout->addWidget(fontsCB);
+    modifiersLayout->addWidget(m_strikeOutButton);
+    modifiersLayout->addWidget(m_underlineButton);
+    modifiersLayout->addWidget(m_weightButton);
+    modifiersLayout->addWidget(m_italicButton);
+    m_layout->addLayout(modifiersLayout);
 }
 
-void
-TextConfig::setUnderline(const bool u)
+void TextConfig::setUnderline(const bool u)
 {
-  m_underlineButton->setChecked(u);
+    m_underlineButton->setChecked(u);
 }
 
-void
-TextConfig::setStrikeOut(const bool s)
+void TextConfig::setStrikeOut(const bool s)
 {
-  m_strikeOutButton->setChecked(s);
+    m_strikeOutButton->setChecked(s);
 }
 
-void
-TextConfig::setWeight(const int w)
+void TextConfig::setWeight(const int w)
 {
-  m_weightButton->setChecked(static_cast<QFont::Weight>(w) == QFont::Bold);
+    m_weightButton->setChecked(static_cast<QFont::Weight>(w) == QFont::Bold);
 }
 
-void
-TextConfig::setItalic(const bool i)
+void TextConfig::setItalic(const bool i)
 {
-  m_italicButton->setChecked(i);
+    m_italicButton->setChecked(i);
 }
 
-void
-TextConfig::weightButtonPressed(const bool w)
+void TextConfig::weightButtonPressed(const bool w)
 {
-  if (w) {
-    emit fontWeightChanged(QFont::Bold);
-  } else {
-    emit fontWeightChanged(QFont::Normal);
-  }
+    if (w) {
+        emit fontWeightChanged(QFont::Bold);
+    } else {
+        emit fontWeightChanged(QFont::Normal);
+    }
 }
diff --git a/src/tools/text/textconfig.h b/src/tools/text/textconfig.h
index 2d4ed72a..fd8a97e3 100644
--- a/src/tools/text/textconfig.h
+++ b/src/tools/text/textconfig.h
@@ -24,31 +24,31 @@ class QPushButton;
 
 class TextConfig : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit TextConfig(QWidget* parent = nullptr);
+    explicit TextConfig(QWidget* parent = nullptr);
 
-  void setUnderline(const bool u);
-  void setStrikeOut(const bool s);
-  void setWeight(const int w);
-  void setItalic(const bool i);
+    void setUnderline(const bool u);
+    void setStrikeOut(const bool s);
+    void setWeight(const int w);
+    void setItalic(const bool i);
 
 signals:
-  void fontFamilyChanged(const QString& f);
-  void fontUnderlineChanged(const bool underlined);
-  void fontStrikeOutChanged(const bool dashed);
-  void fontWeightChanged(const QFont::Weight w);
-  void fontItalicChanged(const bool italic);
+    void fontFamilyChanged(const QString& f);
+    void fontUnderlineChanged(const bool underlined);
+    void fontStrikeOutChanged(const bool dashed);
+    void fontWeightChanged(const QFont::Weight w);
+    void fontItalicChanged(const bool italic);
 
 public slots:
 
 private slots:
-  void weightButtonPressed(const bool w);
+    void weightButtonPressed(const bool w);
 
 private:
-  QVBoxLayout* m_layout;
-  QPushButton* m_strikeOutButton;
-  QPushButton* m_underlineButton;
-  QPushButton* m_weightButton;
-  QPushButton* m_italicButton;
+    QVBoxLayout* m_layout;
+    QPushButton* m_strikeOutButton;
+    QPushButton* m_underlineButton;
+    QPushButton* m_weightButton;
+    QPushButton* m_italicButton;
 };
diff --git a/src/tools/text/texttool.cpp b/src/tools/text/texttool.cpp
index 81711f18..c791b20d 100644
--- a/src/tools/text/texttool.cpp
+++ b/src/tools/text/texttool.cpp
@@ -26,246 +26,227 @@ TextTool::TextTool(QObject* parent)
   , m_size(1)
 {}
 
-bool
-TextTool::isValid() const
+bool TextTool::isValid() const
 {
-  return !m_text.isEmpty();
+    return !m_text.isEmpty();
 }
 
-bool
-TextTool::closeOnButtonPressed() const
+bool TextTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-bool
-TextTool::isSelectable() const
+bool TextTool::isSelectable() const
 {
-  return true;
+    return true;
 }
 
-bool
-TextTool::showMousePreview() const
+bool TextTool::showMousePreview() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-TextTool::icon(const QColor& background, bool inEditor) const
+QIcon TextTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "text.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "text.svg");
 }
 
-QString
-TextTool::name() const
+QString TextTool::name() const
 {
-  return tr("Text");
+    return tr("Text");
 }
 
-ToolType
-TextTool::nameID() const
+ToolType TextTool::nameID() const
 {
-  return ToolType::TEXT;
+    return ToolType::TEXT;
 }
 
-QString
-TextTool::description() const
+QString TextTool::description() const
 {
-  return tr("Add text to your capture");
+    return tr("Add text to your capture");
 }
 
-QWidget*
-TextTool::widget()
+QWidget* TextTool::widget()
 {
-  TextWidget* w = new TextWidget();
-  w->setTextColor(m_color);
-  m_font.setPointSize(m_size + BASE_POINT_SIZE);
-  w->setFont(m_font);
-  connect(w, &TextWidget::textUpdated, this, &TextTool::updateText);
-  m_widget = w;
-  return w;
+    TextWidget* w = new TextWidget();
+    w->setTextColor(m_color);
+    m_font.setPointSize(m_size + BASE_POINT_SIZE);
+    w->setFont(m_font);
+    connect(w, &TextWidget::textUpdated, this, &TextTool::updateText);
+    m_widget = w;
+    return w;
 }
 
-QWidget*
-TextTool::configurationWidget()
+QWidget* TextTool::configurationWidget()
 {
-  m_confW = new TextConfig();
-  connect(
-    m_confW, &TextConfig::fontFamilyChanged, this, &TextTool::updateFamily);
-  connect(
-    m_confW, &TextConfig::fontItalicChanged, this, &TextTool::updateFontItalic);
-  connect(m_confW,
-          &TextConfig::fontStrikeOutChanged,
-          this,
-          &TextTool::updateFontStrikeOut);
-  connect(m_confW,
-          &TextConfig::fontUnderlineChanged,
-          this,
-          &TextTool::updateFontUnderline);
-  connect(
-    m_confW, &TextConfig::fontWeightChanged, this, &TextTool::updateFontWeight);
-  m_confW->setItalic(m_font.italic());
-  m_confW->setUnderline(m_font.underline());
-  m_confW->setStrikeOut(m_font.strikeOut());
-  m_confW->setWeight(m_font.weight());
-  return m_confW;
+    m_confW = new TextConfig();
+    connect(
+      m_confW, &TextConfig::fontFamilyChanged, this, &TextTool::updateFamily);
+    connect(m_confW,
+            &TextConfig::fontItalicChanged,
+            this,
+            &TextTool::updateFontItalic);
+    connect(m_confW,
+            &TextConfig::fontStrikeOutChanged,
+            this,
+            &TextTool::updateFontStrikeOut);
+    connect(m_confW,
+            &TextConfig::fontUnderlineChanged,
+            this,
+            &TextTool::updateFontUnderline);
+    connect(m_confW,
+            &TextConfig::fontWeightChanged,
+            this,
+            &TextTool::updateFontWeight);
+    m_confW->setItalic(m_font.italic());
+    m_confW->setUnderline(m_font.underline());
+    m_confW->setStrikeOut(m_font.strikeOut());
+    m_confW->setWeight(m_font.weight());
+    return m_confW;
 }
 
-CaptureTool*
-TextTool::copy(QObject* parent)
+CaptureTool* TextTool::copy(QObject* parent)
 {
-  TextTool* tt = new TextTool(parent);
-  connect(m_confW, &TextConfig::fontFamilyChanged, tt, &TextTool::updateFamily);
-  connect(
-    m_confW, &TextConfig::fontItalicChanged, tt, &TextTool::updateFontItalic);
-  connect(m_confW,
-          &TextConfig::fontStrikeOutChanged,
-          tt,
-          &TextTool::updateFontStrikeOut);
-  connect(m_confW,
-          &TextConfig::fontUnderlineChanged,
-          tt,
-          &TextTool::updateFontUnderline);
-  connect(
-    m_confW, &TextConfig::fontWeightChanged, tt, &TextTool::updateFontWeight);
-  tt->m_font = m_font;
-  return tt;
+    TextTool* tt = new TextTool(parent);
+    connect(
+      m_confW, &TextConfig::fontFamilyChanged, tt, &TextTool::updateFamily);
+    connect(
+      m_confW, &TextConfig::fontItalicChanged, tt, &TextTool::updateFontItalic);
+    connect(m_confW,
+            &TextConfig::fontStrikeOutChanged,
+            tt,
+            &TextTool::updateFontStrikeOut);
+    connect(m_confW,
+            &TextConfig::fontUnderlineChanged,
+            tt,
+            &TextTool::updateFontUnderline);
+    connect(
+      m_confW, &TextConfig::fontWeightChanged, tt, &TextTool::updateFontWeight);
+    tt->m_font = m_font;
+    return tt;
 }
 
-void
-TextTool::undo(QPixmap& pixmap)
+void TextTool::undo(QPixmap& pixmap)
 {
-  QPainter p(&pixmap);
-  p.drawPixmap(m_backupArea.topLeft(), m_pixmapBackup);
+    QPainter p(&pixmap);
+    p.drawPixmap(m_backupArea.topLeft(), m_pixmapBackup);
 }
 
-void
-TextTool::process(QPainter& painter, const QPixmap& pixmap, bool recordUndo)
+void TextTool::process(QPainter& painter,
+                       const QPixmap& pixmap,
+                       bool recordUndo)
 {
-  if (m_text.isEmpty()) {
-    return;
-  }
-  QFontMetrics fm(m_font);
-  QSize size(fm.boundingRect(QRect(), 0, m_text).size());
-  m_backupArea.setSize(size);
-  if (recordUndo) {
-    m_pixmapBackup = pixmap.copy(m_backupArea + QMargins(0, 0, 5, 5));
-  }
-  // draw text
-  painter.setFont(m_font);
-  painter.setPen(m_color);
-  painter.drawText(m_backupArea + QMargins(-5, -5, 5, 5), m_text);
+    if (m_text.isEmpty()) {
+        return;
+    }
+    QFontMetrics fm(m_font);
+    QSize size(fm.boundingRect(QRect(), 0, m_text).size());
+    m_backupArea.setSize(size);
+    if (recordUndo) {
+        m_pixmapBackup = pixmap.copy(m_backupArea + QMargins(0, 0, 5, 5));
+    }
+    // draw text
+    painter.setFont(m_font);
+    painter.setPen(m_color);
+    painter.drawText(m_backupArea + QMargins(-5, -5, 5, 5), m_text);
 }
 
-void
-TextTool::paintMousePreview(QPainter& painter, const CaptureContext& context)
+void TextTool::paintMousePreview(QPainter& painter,
+                                 const CaptureContext& context)
 {
-  Q_UNUSED(painter);
-  Q_UNUSED(context);
+    Q_UNUSED(painter);
+    Q_UNUSED(context);
 }
 
-void
-TextTool::drawEnd(const QPoint& p)
+void TextTool::drawEnd(const QPoint& p)
 {
-  m_backupArea.moveTo(p);
+    m_backupArea.moveTo(p);
 }
 
-void
-TextTool::drawMove(const QPoint& p)
+void TextTool::drawMove(const QPoint& p)
 {
-  m_widget->move(p);
+    m_widget->move(p);
 }
 
-void
-TextTool::drawStart(const CaptureContext& context)
+void TextTool::drawStart(const CaptureContext& context)
 {
-  m_color = context.color;
-  m_size = context.thickness;
-  emit requestAction(REQ_ADD_CHILD_WIDGET);
+    m_color = context.color;
+    m_size = context.thickness;
+    emit requestAction(REQ_ADD_CHILD_WIDGET);
 }
 
-void
-TextTool::pressed(const CaptureContext& context)
+void TextTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
+    Q_UNUSED(context);
 }
 
-void
-TextTool::colorChanged(const QColor& c)
+void TextTool::colorChanged(const QColor& c)
 {
-  m_color = c;
-  if (m_widget) {
-    m_widget->setTextColor(c);
-  }
+    m_color = c;
+    if (m_widget) {
+        m_widget->setTextColor(c);
+    }
 }
 
-void
-TextTool::thicknessChanged(const int th)
+void TextTool::thicknessChanged(const int th)
 {
-  m_size = th;
-  m_font.setPointSize(m_size + BASE_POINT_SIZE);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_size = th;
+    m_font.setPointSize(m_size + BASE_POINT_SIZE);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
 
-void
-TextTool::updateText(const QString& s)
+void TextTool::updateText(const QString& s)
 {
-  m_text = s;
+    m_text = s;
 }
 
-void
-TextTool::setFont(const QFont& f)
+void TextTool::setFont(const QFont& f)
 {
-  m_font = f;
-  if (m_widget) {
-    m_widget->setFont(f);
-  }
+    m_font = f;
+    if (m_widget) {
+        m_widget->setFont(f);
+    }
 }
 
-void
-TextTool::updateFamily(const QString& s)
+void TextTool::updateFamily(const QString& s)
 {
-  m_font.setFamily(s);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_font.setFamily(s);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
 
-void
-TextTool::updateFontUnderline(const bool underlined)
+void TextTool::updateFontUnderline(const bool underlined)
 {
-  m_font.setUnderline(underlined);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_font.setUnderline(underlined);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
 
-void
-TextTool::updateFontStrikeOut(const bool s)
+void TextTool::updateFontStrikeOut(const bool s)
 {
-  m_font.setStrikeOut(s);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_font.setStrikeOut(s);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
 
-void
-TextTool::updateFontWeight(const QFont::Weight w)
+void TextTool::updateFontWeight(const QFont::Weight w)
 {
-  m_font.setWeight(w);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_font.setWeight(w);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
 
-void
-TextTool::updateFontItalic(const bool italic)
+void TextTool::updateFontItalic(const bool italic)
 {
-  m_font.setItalic(italic);
-  if (m_widget) {
-    m_widget->setFont(m_font);
-  }
+    m_font.setItalic(italic);
+    if (m_widget) {
+        m_widget->setFont(m_font);
+    }
 }
diff --git a/src/tools/text/texttool.h b/src/tools/text/texttool.h
index 4fba5c8b..136bf05e 100644
--- a/src/tools/text/texttool.h
+++ b/src/tools/text/texttool.h
@@ -25,57 +25,57 @@ class TextConfig;
 
 class TextTool : public CaptureTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit TextTool(QObject* parent = nullptr);
+    explicit TextTool(QObject* parent = nullptr);
 
-  bool isValid() const override;
-  bool closeOnButtonPressed() const override;
-  bool isSelectable() const override;
-  bool showMousePreview() const override;
+    bool isValid() const override;
+    bool closeOnButtonPressed() const override;
+    bool isSelectable() const override;
+    bool showMousePreview() const override;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  QWidget* widget() override;
-  QWidget* configurationWidget() override;
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    QWidget* widget() override;
+    QWidget* configurationWidget() override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
-  void undo(QPixmap& pixmap) override;
-  void process(QPainter& painter,
-               const QPixmap& pixmap,
-               bool recordUndo = false) override;
-  void paintMousePreview(QPainter& painter,
-                         const CaptureContext& context) override;
+    void undo(QPixmap& pixmap) override;
+    void process(QPainter& painter,
+                 const QPixmap& pixmap,
+                 bool recordUndo = false) override;
+    void paintMousePreview(QPainter& painter,
+                           const CaptureContext& context) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void drawEnd(const QPoint& p) override;
-  void drawMove(const QPoint& p) override;
-  void drawStart(const CaptureContext& context) override;
-  void pressed(const CaptureContext& context) override;
-  void colorChanged(const QColor& c) override;
-  void thicknessChanged(const int th) override;
+    void drawEnd(const QPoint& p) override;
+    void drawMove(const QPoint& p) override;
+    void drawStart(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
+    void colorChanged(const QColor& c) override;
+    void thicknessChanged(const int th) override;
 
 private slots:
-  void updateText(const QString& s);
-  void setFont(const QFont& f);
-  void updateFamily(const QString& s);
-  void updateFontUnderline(const bool underlined);
-  void updateFontStrikeOut(const bool s);
-  void updateFontWeight(const QFont::Weight w);
-  void updateFontItalic(const bool italic);
+    void updateText(const QString& s);
+    void setFont(const QFont& f);
+    void updateFamily(const QString& s);
+    void updateFontUnderline(const bool underlined);
+    void updateFontStrikeOut(const bool s);
+    void updateFontWeight(const QFont::Weight w);
+    void updateFontItalic(const bool italic);
 
 private:
-  QFont m_font;
-  QString m_text;
-  int m_size;
-  QColor m_color;
-  QPixmap m_pixmapBackup;
-  QRect m_backupArea;
-  QPointer<TextWidget> m_widget;
-  QPointer<TextConfig> m_confW;
+    QFont m_font;
+    QString m_text;
+    int m_size;
+    QColor m_color;
+    QPixmap m_pixmapBackup;
+    QRect m_backupArea;
+    QPointer<TextWidget> m_widget;
+    QPointer<TextConfig> m_confW;
 };
diff --git a/src/tools/text/textwidget.cpp b/src/tools/text/textwidget.cpp
index 1edb8317..d991abfd 100644
--- a/src/tools/text/textwidget.cpp
+++ b/src/tools/text/textwidget.cpp
@@ -20,85 +20,77 @@
 TextWidget::TextWidget(QWidget* parent)
   : QTextEdit(parent)
 {
-  setStyleSheet(QStringLiteral("TextWidget { background: transparent; }"));
-  connect(this, &TextWidget::textChanged, this, &TextWidget::adjustSize);
-  connect(this, &TextWidget::textChanged, this, &TextWidget::emitTextUpdated);
-  setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-  setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-  setContextMenuPolicy(Qt::NoContextMenu);
+    setStyleSheet(QStringLiteral("TextWidget { background: transparent; }"));
+    connect(this, &TextWidget::textChanged, this, &TextWidget::adjustSize);
+    connect(this, &TextWidget::textChanged, this, &TextWidget::emitTextUpdated);
+    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setContextMenuPolicy(Qt::NoContextMenu);
 }
 
-void
-TextWidget::showEvent(QShowEvent* e)
+void TextWidget::showEvent(QShowEvent* e)
 {
-  QFont font;
-  QFontMetrics fm(font);
-  setFixedWidth(fm.lineSpacing() * 6);
-  setFixedHeight(fm.lineSpacing() * 2.5);
-  m_baseSize = size();
-  m_minSize = m_baseSize;
-  QTextEdit::showEvent(e);
-  adjustSize();
+    QFont font;
+    QFontMetrics fm(font);
+    setFixedWidth(fm.lineSpacing() * 6);
+    setFixedHeight(fm.lineSpacing() * 2.5);
+    m_baseSize = size();
+    m_minSize = m_baseSize;
+    QTextEdit::showEvent(e);
+    adjustSize();
 }
 
-void
-TextWidget::resizeEvent(QResizeEvent* e)
+void TextWidget::resizeEvent(QResizeEvent* e)
 {
-  m_minSize.setHeight(qMin(m_baseSize.height(), height()));
-  m_minSize.setWidth(qMin(m_baseSize.width(), width()));
-  QTextEdit::resizeEvent(e);
+    m_minSize.setHeight(qMin(m_baseSize.height(), height()));
+    m_minSize.setWidth(qMin(m_baseSize.width(), width()));
+    QTextEdit::resizeEvent(e);
 }
 
-void
-TextWidget::setFont(const QFont& f)
+void TextWidget::setFont(const QFont& f)
 {
-  QTextEdit::setFont(f);
-  adjustSize();
+    QTextEdit::setFont(f);
+    adjustSize();
 }
 
-void
-TextWidget::updateFont(const QFont& f)
+void TextWidget::updateFont(const QFont& f)
 {
-  setFont(f);
+    setFont(f);
 }
 
-void
-TextWidget::setFontPointSize(qreal s)
+void TextWidget::setFontPointSize(qreal s)
 {
-  QFont f = font();
-  f.setPointSize(s);
-  setFont(f);
+    QFont f = font();
+    f.setPointSize(s);
+    setFont(f);
 }
 
-void
-TextWidget::setTextColor(const QColor& c)
+void TextWidget::setTextColor(const QColor& c)
 {
-  QString s(
-    QStringLiteral("TextWidget { background: transparent; color: %1; }"));
-  setStyleSheet(s.arg(c.name()));
+    QString s(
+      QStringLiteral("TextWidget { background: transparent; color: %1; }"));
+    setStyleSheet(s.arg(c.name()));
 }
 
-void
-TextWidget::adjustSize()
+void TextWidget::adjustSize()
 {
-  QString&& text = this->toPlainText();
+    QString&& text = this->toPlainText();
 
-  QFontMetrics fm(font());
-  QRect bounds = fm.boundingRect(QRect(), 0, text);
-  int pixelsWide = bounds.width() + fm.lineSpacing();
-  int pixelsHigh = bounds.height() * 1.15 + fm.lineSpacing();
-  if (pixelsWide < m_minSize.width()) {
-    pixelsWide = m_minSize.width();
-  }
-  if (pixelsHigh < m_minSize.height()) {
-    pixelsHigh = m_minSize.height();
-  }
+    QFontMetrics fm(font());
+    QRect bounds = fm.boundingRect(QRect(), 0, text);
+    int pixelsWide = bounds.width() + fm.lineSpacing();
+    int pixelsHigh = bounds.height() * 1.15 + fm.lineSpacing();
+    if (pixelsWide < m_minSize.width()) {
+        pixelsWide = m_minSize.width();
+    }
+    if (pixelsHigh < m_minSize.height()) {
+        pixelsHigh = m_minSize.height();
+    }
 
-  this->setFixedSize(pixelsWide, pixelsHigh);
+    this->setFixedSize(pixelsWide, pixelsHigh);
 }
 
-void
-TextWidget::emitTextUpdated()
+void TextWidget::emitTextUpdated()
 {
-  emit textUpdated(this->toPlainText());
+    emit textUpdated(this->toPlainText());
 }
diff --git a/src/tools/text/textwidget.h b/src/tools/text/textwidget.h
index d3f2c9a1..40f23c58 100644
--- a/src/tools/text/textwidget.h
+++ b/src/tools/text/textwidget.h
@@ -21,29 +21,29 @@
 
 class TextWidget : public QTextEdit
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit TextWidget(QWidget* parent = nullptr);
+    explicit TextWidget(QWidget* parent = nullptr);
 
-  void adjustSize();
-  void setFont(const QFont& f);
+    void adjustSize();
+    void setFont(const QFont& f);
 
 protected:
-  void showEvent(QShowEvent* e);
-  void resizeEvent(QResizeEvent* e);
+    void showEvent(QShowEvent* e);
+    void resizeEvent(QResizeEvent* e);
 
 signals:
-  void textUpdated(const QString& s);
+    void textUpdated(const QString& s);
 
 public slots:
-  void updateFont(const QFont& f);
-  void setTextColor(const QColor& c);
-  void setFontPointSize(qreal s);
+    void updateFont(const QFont& f);
+    void setTextColor(const QColor& c);
+    void setFontPointSize(qreal s);
 
 private slots:
-  void emitTextUpdated();
+    void emitTextUpdated();
 
 private:
-  QSize m_baseSize;
-  QSize m_minSize;
+    QSize m_baseSize;
+    QSize m_minSize;
 };
diff --git a/src/tools/toolfactory.cpp b/src/tools/toolfactory.cpp
index 1ee86496..8df420a4 100644
--- a/src/tools/toolfactory.cpp
+++ b/src/tools/toolfactory.cpp
@@ -41,75 +41,75 @@ ToolFactory::ToolFactory(QObject* parent)
   : QObject(parent)
 {}
 
-CaptureTool*
-ToolFactory::CreateTool(CaptureToolButton::ButtonType t, QObject* parent)
+CaptureTool* ToolFactory::CreateTool(CaptureToolButton::ButtonType t,
+                                     QObject* parent)
 {
-  CaptureTool* tool;
-  switch (t) {
-    case CaptureToolButton::TYPE_ARROW:
-      tool = new ArrowTool(parent);
-      break;
-    case CaptureToolButton::TYPE_CIRCLE:
-      tool = new CircleTool(parent);
-      break;
-    case CaptureToolButton::TYPE_COPY:
-      tool = new CopyTool(parent);
-      break;
-    case CaptureToolButton::TYPE_EXIT:
-      tool = new ExitTool(parent);
-      break;
-    case CaptureToolButton::TYPE_IMAGEUPLOADER:
-      tool = new ImgurUploaderTool(parent);
-      break;
-    case CaptureToolButton::TYPE_DRAWER:
-      tool = new LineTool(parent);
-      break;
-    case CaptureToolButton::TYPE_MARKER:
-      tool = new MarkerTool(parent);
-      break;
-    case CaptureToolButton::TYPE_MOVESELECTION:
-      tool = new MoveTool(parent);
-      break;
-    case CaptureToolButton::TYPE_PENCIL:
-      tool = new PencilTool(parent);
-      break;
-    case CaptureToolButton::TYPE_RECTANGLE:
-      tool = new RectangleTool(parent);
-      break;
-    case CaptureToolButton::TYPE_SAVE:
-      tool = new SaveTool(parent);
-      break;
-    case CaptureToolButton::TYPE_SELECTION:
-      tool = new SelectionTool(parent);
-      break;
-    case CaptureToolButton::TYPE_SELECTIONINDICATOR:
-      tool = new SizeIndicatorTool(parent);
-      break;
-    case CaptureToolButton::TYPE_UNDO:
-      tool = new UndoTool(parent);
-      break;
-    case CaptureToolButton::TYPE_REDO:
-      tool = new RedoTool(parent);
-      break;
-    case CaptureToolButton::TYPE_OPEN_APP:
-      tool = new AppLauncher(parent);
-      break;
-    case CaptureToolButton::TYPE_PIXELATE:
-      tool = new PixelateTool(parent);
-      break;
-    case CaptureToolButton::TYPE_PIN:
-      tool = new PinTool(parent);
-      break;
-    case CaptureToolButton::TYPE_TEXT:
-      tool = new TextTool(parent);
-      break;
-    case CaptureToolButton::TYPE_CIRCLECOUNT:
-      tool = new CircleCountTool(parent);
-      break;
+    CaptureTool* tool;
+    switch (t) {
+        case CaptureToolButton::TYPE_ARROW:
+            tool = new ArrowTool(parent);
+            break;
+        case CaptureToolButton::TYPE_CIRCLE:
+            tool = new CircleTool(parent);
+            break;
+        case CaptureToolButton::TYPE_COPY:
+            tool = new CopyTool(parent);
+            break;
+        case CaptureToolButton::TYPE_EXIT:
+            tool = new ExitTool(parent);
+            break;
+        case CaptureToolButton::TYPE_IMAGEUPLOADER:
+            tool = new ImgurUploaderTool(parent);
+            break;
+        case CaptureToolButton::TYPE_DRAWER:
+            tool = new LineTool(parent);
+            break;
+        case CaptureToolButton::TYPE_MARKER:
+            tool = new MarkerTool(parent);
+            break;
+        case CaptureToolButton::TYPE_MOVESELECTION:
+            tool = new MoveTool(parent);
+            break;
+        case CaptureToolButton::TYPE_PENCIL:
+            tool = new PencilTool(parent);
+            break;
+        case CaptureToolButton::TYPE_RECTANGLE:
+            tool = new RectangleTool(parent);
+            break;
+        case CaptureToolButton::TYPE_SAVE:
+            tool = new SaveTool(parent);
+            break;
+        case CaptureToolButton::TYPE_SELECTION:
+            tool = new SelectionTool(parent);
+            break;
+        case CaptureToolButton::TYPE_SELECTIONINDICATOR:
+            tool = new SizeIndicatorTool(parent);
+            break;
+        case CaptureToolButton::TYPE_UNDO:
+            tool = new UndoTool(parent);
+            break;
+        case CaptureToolButton::TYPE_REDO:
+            tool = new RedoTool(parent);
+            break;
+        case CaptureToolButton::TYPE_OPEN_APP:
+            tool = new AppLauncher(parent);
+            break;
+        case CaptureToolButton::TYPE_PIXELATE:
+            tool = new PixelateTool(parent);
+            break;
+        case CaptureToolButton::TYPE_PIN:
+            tool = new PinTool(parent);
+            break;
+        case CaptureToolButton::TYPE_TEXT:
+            tool = new TextTool(parent);
+            break;
+        case CaptureToolButton::TYPE_CIRCLECOUNT:
+            tool = new CircleCountTool(parent);
+            break;
 
-    default:
-      tool = nullptr;
-      break;
-  }
-  return tool;
+        default:
+            tool = nullptr;
+            break;
+    }
+    return tool;
 }
diff --git a/src/tools/toolfactory.h b/src/tools/toolfactory.h
index 84cf7244..bb6e6e6c 100644
--- a/src/tools/toolfactory.h
+++ b/src/tools/toolfactory.h
@@ -25,14 +25,14 @@ class CaptureTool;
 
 class ToolFactory : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  explicit ToolFactory(QObject* parent = nullptr);
+    explicit ToolFactory(QObject* parent = nullptr);
 
-  ToolFactory(const ToolFactory&) = delete;
-  ToolFactory& operator=(const ToolFactory&) = delete;
+    ToolFactory(const ToolFactory&) = delete;
+    ToolFactory& operator=(const ToolFactory&) = delete;
 
-  CaptureTool* CreateTool(CaptureToolButton::ButtonType t,
-                          QObject* parent = nullptr);
+    CaptureTool* CreateTool(CaptureToolButton::ButtonType t,
+                            QObject* parent = nullptr);
 };
diff --git a/src/tools/undo/undotool.cpp b/src/tools/undo/undotool.cpp
index 217f19d7..efadb0ce 100644
--- a/src/tools/undo/undotool.cpp
+++ b/src/tools/undo/undotool.cpp
@@ -22,45 +22,38 @@ UndoTool::UndoTool(QObject* parent)
   : AbstractActionTool(parent)
 {}
 
-bool
-UndoTool::closeOnButtonPressed() const
+bool UndoTool::closeOnButtonPressed() const
 {
-  return false;
+    return false;
 }
 
-QIcon
-UndoTool::icon(const QColor& background, bool inEditor) const
+QIcon UndoTool::icon(const QColor& background, bool inEditor) const
 {
-  Q_UNUSED(inEditor);
-  return QIcon(iconPath(background) + "undo-variant.svg");
+    Q_UNUSED(inEditor);
+    return QIcon(iconPath(background) + "undo-variant.svg");
 }
-QString
-UndoTool::name() const
+QString UndoTool::name() const
 {
-  return tr("Undo");
+    return tr("Undo");
 }
 
-ToolType
-UndoTool::nameID() const
+ToolType UndoTool::nameID() const
 {
-  return ToolType::UNDO;
+    return ToolType::UNDO;
 }
 
-QString
-UndoTool::description() const
+QString UndoTool::description() const
 {
-  return tr("Undo the last modification");
+    return tr("Undo the last modification");
 }
 
-CaptureTool*
-UndoTool::copy(QObject* parent)
+CaptureTool* UndoTool::copy(QObject* parent)
 {
-  return new UndoTool(parent);
+    return new UndoTool(parent);
 }
 
-void
-UndoTool::pressed(const CaptureContext& context)
+void UndoTool::pressed(const CaptureContext& context)
 {
-  Q_UNUSED(context);
-  emit requestAction(REQ_UNDO_MODIFICATION);
+    Q_UNUSED(context);
+    emit requestAction(REQ_UNDO_MODIFICATION);
 }
diff --git a/src/tools/undo/undotool.h b/src/tools/undo/undotool.h
index 94b1ad0f..140407ea 100644
--- a/src/tools/undo/undotool.h
+++ b/src/tools/undo/undotool.h
@@ -21,21 +21,21 @@
 
 class UndoTool : public AbstractActionTool
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit UndoTool(QObject* parent = nullptr);
+    explicit UndoTool(QObject* parent = nullptr);
 
-  bool closeOnButtonPressed() const;
+    bool closeOnButtonPressed() const;
 
-  QIcon icon(const QColor& background, bool inEditor) const override;
-  QString name() const override;
-  QString description() const override;
+    QIcon icon(const QColor& background, bool inEditor) const override;
+    QString name() const override;
+    QString description() const override;
 
-  CaptureTool* copy(QObject* parent = nullptr) override;
+    CaptureTool* copy(QObject* parent = nullptr) override;
 
 protected:
-  ToolType nameID() const override;
+    ToolType nameID() const override;
 
 public slots:
-  void pressed(const CaptureContext& context) override;
+    void pressed(const CaptureContext& context) override;
 };
diff --git a/src/utils/colorutils.cpp b/src/utils/colorutils.cpp
index febf3b4e..8ba9f8ed 100644
--- a/src/utils/colorutils.cpp
+++ b/src/utils/colorutils.cpp
@@ -17,28 +17,25 @@
 
 #include "colorutils.h"
 
-inline qreal
-getColorLuma(const QColor& c)
+inline qreal getColorLuma(const QColor& c)
 {
-  return 0.30 * c.redF() + 0.59 * c.greenF() + 0.11 * c.blueF();
+    return 0.30 * c.redF() + 0.59 * c.greenF() + 0.11 * c.blueF();
 }
 
-bool
-ColorUtils::colorIsDark(const QColor& c)
+bool ColorUtils::colorIsDark(const QColor& c)
 {
-  bool isWhite = false;
-  if (getColorLuma(c) <= 0.60) {
-    isWhite = true;
-  }
-  return isWhite;
+    bool isWhite = false;
+    if (getColorLuma(c) <= 0.60) {
+        isWhite = true;
+    }
+    return isWhite;
 }
 
-QColor
-ColorUtils::contrastColor(const QColor& c)
+QColor ColorUtils::contrastColor(const QColor& c)
 {
-  int change = colorIsDark(c) ? 30 : -45;
+    int change = colorIsDark(c) ? 30 : -45;
 
-  return QColor(qBound(0, c.red() + change, 255),
-                qBound(0, c.green() + change, 255),
-                qBound(0, c.blue() + change, 255));
+    return QColor(qBound(0, c.red() + change, 255),
+                  qBound(0, c.green() + change, 255),
+                  qBound(0, c.blue() + change, 255));
 }
diff --git a/src/utils/colorutils.h b/src/utils/colorutils.h
index f587e7ad..bfee6c78 100644
--- a/src/utils/colorutils.h
+++ b/src/utils/colorutils.h
@@ -21,10 +21,8 @@
 
 namespace ColorUtils { // namespace
 
-bool
-colorIsDark(const QColor& c);
+bool colorIsDark(const QColor& c);
 
-QColor
-contrastColor(const QColor& c);
+QColor contrastColor(const QColor& c);
 
 } // namespace
diff --git a/src/utils/confighandler.cpp b/src/utils/confighandler.cpp
index 38341e55..ee50acb9 100644
--- a/src/utils/confighandler.cpp
+++ b/src/utils/confighandler.cpp
@@ -23,472 +23,434 @@
 
 ConfigHandler::ConfigHandler()
 {
-  m_settings.setDefaultFormat(QSettings::IniFormat);
+    m_settings.setDefaultFormat(QSettings::IniFormat);
+}
+
+QVector<CaptureToolButton::ButtonType> ConfigHandler::getButtons()
+{
+    QVector<CaptureToolButton::ButtonType> buttons;
+    if (m_settings.contains(QStringLiteral("buttons"))) {
+        // TODO: remove toList in v1.0
+        QVector<int> buttonsInt = m_settings.value(QStringLiteral("buttons"))
+                                    .value<QList<int>>()
+                                    .toVector();
+        bool modified = normalizeButtons(buttonsInt);
+        if (modified) {
+            m_settings.setValue(QStringLiteral("buttons"),
+                                QVariant::fromValue(buttonsInt.toList()));
+        }
+        buttons = fromIntToButton(buttonsInt);
+    } else {
+        // Default tools
+        buttons << CaptureToolButton::TYPE_PENCIL
+                << CaptureToolButton::TYPE_DRAWER
+                << CaptureToolButton::TYPE_ARROW
+                << CaptureToolButton::TYPE_SELECTION
+                << CaptureToolButton::TYPE_RECTANGLE
+                << CaptureToolButton::TYPE_CIRCLE
+                << CaptureToolButton::TYPE_MARKER
+                << CaptureToolButton::TYPE_PIXELATE
+                << CaptureToolButton::TYPE_SELECTIONINDICATOR
+                << CaptureToolButton::TYPE_MOVESELECTION
+                << CaptureToolButton::TYPE_UNDO << CaptureToolButton::TYPE_REDO
+                << CaptureToolButton::TYPE_COPY << CaptureToolButton::TYPE_SAVE
+                << CaptureToolButton::TYPE_EXIT
+                << CaptureToolButton::TYPE_IMAGEUPLOADER
+                << CaptureToolButton::TYPE_OPEN_APP
+                << CaptureToolButton::TYPE_PIN << CaptureToolButton::TYPE_TEXT
+                << CaptureToolButton::TYPE_CIRCLECOUNT;
+    }
+
+    using bt = CaptureToolButton::ButtonType;
+    std::sort(buttons.begin(), buttons.end(), [](bt a, bt b) {
+        return CaptureToolButton::getPriorityByButton(a) <
+               CaptureToolButton::getPriorityByButton(b);
+    });
+    return buttons;
 }
 
-QVector<CaptureToolButton::ButtonType>
-ConfigHandler::getButtons()
+void ConfigHandler::setButtons(
+  const QVector<CaptureToolButton::ButtonType>& buttons)
 {
-  QVector<CaptureToolButton::ButtonType> buttons;
-  if (m_settings.contains(QStringLiteral("buttons"))) {
+    QVector<int> l = fromButtonToInt(buttons);
+    normalizeButtons(l);
     // TODO: remove toList in v1.0
-    QVector<int> buttonsInt = m_settings.value(QStringLiteral("buttons"))
-                                .value<QList<int>>()
-                                .toVector();
-    bool modified = normalizeButtons(buttonsInt);
-    if (modified) {
-      m_settings.setValue(QStringLiteral("buttons"),
-                          QVariant::fromValue(buttonsInt.toList()));
-    }
-    buttons = fromIntToButton(buttonsInt);
-  } else {
-    // Default tools
-    buttons << CaptureToolButton::TYPE_PENCIL << CaptureToolButton::TYPE_DRAWER
-            << CaptureToolButton::TYPE_ARROW
-            << CaptureToolButton::TYPE_SELECTION
-            << CaptureToolButton::TYPE_RECTANGLE
-            << CaptureToolButton::TYPE_CIRCLE << CaptureToolButton::TYPE_MARKER
-            << CaptureToolButton::TYPE_PIXELATE
-            << CaptureToolButton::TYPE_SELECTIONINDICATOR
-            << CaptureToolButton::TYPE_MOVESELECTION
-            << CaptureToolButton::TYPE_UNDO << CaptureToolButton::TYPE_REDO
-            << CaptureToolButton::TYPE_COPY << CaptureToolButton::TYPE_SAVE
-            << CaptureToolButton::TYPE_EXIT
-            << CaptureToolButton::TYPE_IMAGEUPLOADER
-            << CaptureToolButton::TYPE_OPEN_APP << CaptureToolButton::TYPE_PIN
-            << CaptureToolButton::TYPE_TEXT
-            << CaptureToolButton::TYPE_CIRCLECOUNT;
-  }
-
-  using bt = CaptureToolButton::ButtonType;
-  std::sort(buttons.begin(), buttons.end(), [](bt a, bt b) {
-    return CaptureToolButton::getPriorityByButton(a) <
-           CaptureToolButton::getPriorityByButton(b);
-  });
-  return buttons;
-}
-
-void
-ConfigHandler::setButtons(const QVector<CaptureToolButton::ButtonType>& buttons)
-{
-  QVector<int> l = fromButtonToInt(buttons);
-  normalizeButtons(l);
-  // TODO: remove toList in v1.0
-  m_settings.setValue(QStringLiteral("buttons"),
-                      QVariant::fromValue(l.toList()));
-}
-
-QVector<QColor>
-ConfigHandler::getUserColors()
-{
-  QVector<QColor> colors;
-  const QVector<QColor>& defaultColors = {
-    Qt::darkRed, Qt::red,  Qt::yellow,  Qt::green,      Qt::darkGreen,
-    Qt::cyan,    Qt::blue, Qt::magenta, Qt::darkMagenta
-  };
-
-  if (m_settings.contains(QStringLiteral("userColors"))) {
-    for (const QString& hex :
-         m_settings.value(QStringLiteral("userColors")).toStringList()) {
-      if (QColor::isValidColor(hex)) {
-        colors.append(QColor(hex));
-      }
-    }
-
-    if (colors.isEmpty()) {
-      colors = defaultColors;
+    m_settings.setValue(QStringLiteral("buttons"),
+                        QVariant::fromValue(l.toList()));
+}
+
+QVector<QColor> ConfigHandler::getUserColors()
+{
+    QVector<QColor> colors;
+    const QVector<QColor>& defaultColors = {
+        Qt::darkRed, Qt::red,  Qt::yellow,  Qt::green,      Qt::darkGreen,
+        Qt::cyan,    Qt::blue, Qt::magenta, Qt::darkMagenta
+    };
+
+    if (m_settings.contains(QStringLiteral("userColors"))) {
+        for (const QString& hex :
+             m_settings.value(QStringLiteral("userColors")).toStringList()) {
+            if (QColor::isValidColor(hex)) {
+                colors.append(QColor(hex));
+            }
+        }
+
+        if (colors.isEmpty()) {
+            colors = defaultColors;
+        }
+    } else {
+        colors = defaultColors;
     }
-  } else {
-    colors = defaultColors;
-  }
 
-  return colors;
+    return colors;
 }
 
-void
-ConfigHandler::setUserColors(const QVector<QColor>& l)
+void ConfigHandler::setUserColors(const QVector<QColor>& l)
 {
-  QStringList hexColors;
+    QStringList hexColors;
 
-  for (const QColor& color : l) {
-    hexColors.append(color.name());
-  }
+    for (const QColor& color : l) {
+        hexColors.append(color.name());
+    }
 
-  m_settings.setValue(QStringLiteral("userColors"),
-                      QVariant::fromValue(hexColors));
+    m_settings.setValue(QStringLiteral("userColors"),
+                        QVariant::fromValue(hexColors));
 }
 
-QString
-ConfigHandler::savePathValue()
+QString ConfigHandler::savePathValue()
 {
-  return m_settings.value(QStringLiteral("savePath")).toString();
+    return m_settings.value(QStringLiteral("savePath")).toString();
 }
 
-void
-ConfigHandler::setSavePath(const QString& savePath)
+void ConfigHandler::setSavePath(const QString& savePath)
 {
-  m_settings.setValue(QStringLiteral("savePath"), savePath);
+    m_settings.setValue(QStringLiteral("savePath"), savePath);
 }
 
-QColor
-ConfigHandler::uiMainColorValue()
+QColor ConfigHandler::uiMainColorValue()
 {
-  QColor res = QColor(116, 0, 150);
+    QColor res = QColor(116, 0, 150);
 
-  if (m_settings.contains(QStringLiteral("uiColor"))) {
-    QString hex = m_settings.value(QStringLiteral("uiColor")).toString();
+    if (m_settings.contains(QStringLiteral("uiColor"))) {
+        QString hex = m_settings.value(QStringLiteral("uiColor")).toString();
 
-    if (QColor::isValidColor(hex)) {
-      res = QColor(hex);
+        if (QColor::isValidColor(hex)) {
+            res = QColor(hex);
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-void
-ConfigHandler::setUIMainColor(const QColor& c)
+void ConfigHandler::setUIMainColor(const QColor& c)
 {
-  m_settings.setValue(QStringLiteral("uiColor"), c.name());
+    m_settings.setValue(QStringLiteral("uiColor"), c.name());
 }
 
-QColor
-ConfigHandler::uiContrastColorValue()
+QColor ConfigHandler::uiContrastColorValue()
 {
-  QColor res = QColor(86, 0, 120);
+    QColor res = QColor(86, 0, 120);
 
-  if (m_settings.contains(QStringLiteral("contrastUiColor"))) {
-    QString hex =
-      m_settings.value(QStringLiteral("contrastUiColor")).toString();
+    if (m_settings.contains(QStringLiteral("contrastUiColor"))) {
+        QString hex =
+          m_settings.value(QStringLiteral("contrastUiColor")).toString();
 
-    if (QColor::isValidColor(hex)) {
-      res = QColor(hex);
+        if (QColor::isValidColor(hex)) {
+            res = QColor(hex);
+        }
     }
-  }
 
-  return res;
+    return res;
 }
 
-void
-ConfigHandler::setUIContrastColor(const QColor& c)
+void ConfigHandler::setUIContrastColor(const QColor& c)
 {
-  m_settings.setValue(QStringLiteral("contrastUiColor"), c.name());
+    m_settings.setValue(QStringLiteral("contrastUiColor"), c.name());
 }
 
-QColor
-ConfigHandler::drawColorValue()
+QColor ConfigHandler::drawColorValue()
 {
-  QColor res(Qt::red);
+    QColor res(Qt::red);
 
-  if (m_settings.contains(QStringLiteral("drawColor"))) {
-    QString hex = m_settings.value(QStringLiteral("drawColor")).toString();
+    if (m_settings.contains(QStringLiteral("drawColor"))) {
+        QString hex = m_settings.value(QStringLiteral("drawColor")).toString();
 
-    if (QColor::isValidColor(hex)) {
-      res = QColor(hex);
+        if (QColor::isValidColor(hex)) {
+            res = QColor(hex);
+        }
     }
-  }
 
-  return res;
+    return res;
 }
 
-void
-ConfigHandler::setDrawColor(const QColor& c)
+void ConfigHandler::setDrawColor(const QColor& c)
 {
-  m_settings.setValue(QStringLiteral("drawColor"), c.name());
+    m_settings.setValue(QStringLiteral("drawColor"), c.name());
 }
 
-bool
-ConfigHandler::showHelpValue()
+bool ConfigHandler::showHelpValue()
 {
-  bool res = true;
-  if (m_settings.contains(QStringLiteral("showHelp"))) {
-    res = m_settings.value(QStringLiteral("showHelp")).toBool();
-  }
-  return res;
+    bool res = true;
+    if (m_settings.contains(QStringLiteral("showHelp"))) {
+        res = m_settings.value(QStringLiteral("showHelp")).toBool();
+    }
+    return res;
 }
 
-void
-ConfigHandler::setShowHelp(const bool showHelp)
+void ConfigHandler::setShowHelp(const bool showHelp)
 {
-  m_settings.setValue(QStringLiteral("showHelp"), showHelp);
+    m_settings.setValue(QStringLiteral("showHelp"), showHelp);
 }
 
-bool
-ConfigHandler::showSidePanelButtonValue()
+bool ConfigHandler::showSidePanelButtonValue()
 {
-  return m_settings.value(QStringLiteral("showSidePanelButton"), true).toBool();
+    return m_settings.value(QStringLiteral("showSidePanelButton"), true)
+      .toBool();
 }
 
-void
-ConfigHandler::setShowSidePanelButton(const bool showSidePanelButton)
+void ConfigHandler::setShowSidePanelButton(const bool showSidePanelButton)
 {
-  m_settings.setValue(QStringLiteral("showSidePanelButton"),
-                      showSidePanelButton);
+    m_settings.setValue(QStringLiteral("showSidePanelButton"),
+                        showSidePanelButton);
 }
 
-bool
-ConfigHandler::desktopNotificationValue()
+bool ConfigHandler::desktopNotificationValue()
 {
-  bool res = true;
-  if (m_settings.contains(QStringLiteral("showDesktopNotification"))) {
-    res = m_settings.value(QStringLiteral("showDesktopNotification")).toBool();
-  }
-  return res;
+    bool res = true;
+    if (m_settings.contains(QStringLiteral("showDesktopNotification"))) {
+        res =
+          m_settings.value(QStringLiteral("showDesktopNotification")).toBool();
+    }
+    return res;
 }
 
-void
-ConfigHandler::setDesktopNotification(const bool showDesktopNotification)
+void ConfigHandler::setDesktopNotification(const bool showDesktopNotification)
 {
-  m_settings.setValue(QStringLiteral("showDesktopNotification"),
-                      showDesktopNotification);
+    m_settings.setValue(QStringLiteral("showDesktopNotification"),
+                        showDesktopNotification);
 }
 
-QString
-ConfigHandler::filenamePatternValue()
+QString ConfigHandler::filenamePatternValue()
 {
-  return m_settings.value(QStringLiteral("filenamePattern")).toString();
+    return m_settings.value(QStringLiteral("filenamePattern")).toString();
 }
 
-void
-ConfigHandler::setFilenamePattern(const QString& pattern)
+void ConfigHandler::setFilenamePattern(const QString& pattern)
 {
-  return m_settings.setValue(QStringLiteral("filenamePattern"), pattern);
+    return m_settings.setValue(QStringLiteral("filenamePattern"), pattern);
 }
 
-bool
-ConfigHandler::disabledTrayIconValue()
+bool ConfigHandler::disabledTrayIconValue()
 {
-  bool res = false;
-  if (m_settings.contains(QStringLiteral("disabledTrayIcon"))) {
-    res = m_settings.value(QStringLiteral("disabledTrayIcon")).toBool();
-  }
-  return res;
+    bool res = false;
+    if (m_settings.contains(QStringLiteral("disabledTrayIcon"))) {
+        res = m_settings.value(QStringLiteral("disabledTrayIcon")).toBool();
+    }
+    return res;
 }
 
-void
-ConfigHandler::setDisabledTrayIcon(const bool disabledTrayIcon)
+void ConfigHandler::setDisabledTrayIcon(const bool disabledTrayIcon)
 {
-  m_settings.setValue(QStringLiteral("disabledTrayIcon"), disabledTrayIcon);
+    m_settings.setValue(QStringLiteral("disabledTrayIcon"), disabledTrayIcon);
 }
 
-int
-ConfigHandler::drawThicknessValue()
+int ConfigHandler::drawThicknessValue()
 {
-  int res = 0;
-  if (m_settings.contains(QStringLiteral("drawThickness"))) {
-    res = m_settings.value(QStringLiteral("drawThickness")).toInt();
-  }
-  return res;
+    int res = 0;
+    if (m_settings.contains(QStringLiteral("drawThickness"))) {
+        res = m_settings.value(QStringLiteral("drawThickness")).toInt();
+    }
+    return res;
 }
 
-void
-ConfigHandler::setdrawThickness(const int thickness)
+void ConfigHandler::setdrawThickness(const int thickness)
 {
-  m_settings.setValue(QStringLiteral("drawThickness"), thickness);
+    m_settings.setValue(QStringLiteral("drawThickness"), thickness);
 }
 
-bool
-ConfigHandler::keepOpenAppLauncherValue()
+bool ConfigHandler::keepOpenAppLauncherValue()
 {
-  return m_settings.value(QStringLiteral("keepOpenAppLauncher")).toBool();
+    return m_settings.value(QStringLiteral("keepOpenAppLauncher")).toBool();
 }
 
-void
-ConfigHandler::setKeepOpenAppLauncher(const bool keepOpen)
+void ConfigHandler::setKeepOpenAppLauncher(const bool keepOpen)
 {
-  m_settings.setValue(QStringLiteral("keepOpenAppLauncher"), keepOpen);
+    m_settings.setValue(QStringLiteral("keepOpenAppLauncher"), keepOpen);
 }
 
-bool
-ConfigHandler::startupLaunchValue()
+bool ConfigHandler::startupLaunchValue()
 {
-  bool res = false;
+    bool res = false;
 
-  if (m_settings.contains(QStringLiteral("startupLaunch"))) {
-    res = m_settings.value(QStringLiteral("startupLaunch")).toBool();
-  }
+    if (m_settings.contains(QStringLiteral("startupLaunch"))) {
+        res = m_settings.value(QStringLiteral("startupLaunch")).toBool();
+    }
 
-  if (res != verifyLaunchFile()) {
-    setStartupLaunch(res);
-  }
+    if (res != verifyLaunchFile()) {
+        setStartupLaunch(res);
+    }
 
-  return res;
+    return res;
 }
 
-bool
-ConfigHandler::verifyLaunchFile()
+bool ConfigHandler::verifyLaunchFile()
 {
-  bool res = false;
+    bool res = false;
 
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  QString path = QDir::homePath() + "/.config/autostart/Flameshot.desktop";
-  res = QFile(path).exists();
+    QString path = QDir::homePath() + "/.config/autostart/Flameshot.desktop";
+    res = QFile(path).exists();
 #elif defined(Q_OS_WIN)
-  QSettings bootUpSettings(
-    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
-    QSettings::NativeFormat);
-  res = bootUpSettings.value("Flameshot").toString() ==
-        QDir::toNativeSeparators(QCoreApplication::applicationFilePath());
+    QSettings bootUpSettings(
+      "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
+      QSettings::NativeFormat);
+    res = bootUpSettings.value("Flameshot").toString() ==
+          QDir::toNativeSeparators(QCoreApplication::applicationFilePath());
 #endif
-  return res;
+    return res;
 }
 
-void
-ConfigHandler::setStartupLaunch(const bool start)
+void ConfigHandler::setStartupLaunch(const bool start)
 {
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  QString path = QDir::homePath() + "/.config/autostart/";
-  QDir autostartDir(path);
-  if (!autostartDir.exists()) {
-    autostartDir.mkpath(".");
-  }
-
-  QFile file(path + "Flameshot.desktop");
-  if (start) {
-    if (file.open(QIODevice::WriteOnly)) {
-      QByteArray data("[Desktop Entry]\nName=flameshot\nIcon=flameshot"
-                      "\nExec=flameshot\nTerminal=false\nType=Application"
-                      "\nX-GNOME-Autostart-enabled=true\n");
-      file.write(data);
+    QString path = QDir::homePath() + "/.config/autostart/";
+    QDir autostartDir(path);
+    if (!autostartDir.exists()) {
+        autostartDir.mkpath(".");
+    }
+
+    QFile file(path + "Flameshot.desktop");
+    if (start) {
+        if (file.open(QIODevice::WriteOnly)) {
+            QByteArray data("[Desktop Entry]\nName=flameshot\nIcon=flameshot"
+                            "\nExec=flameshot\nTerminal=false\nType=Application"
+                            "\nX-GNOME-Autostart-enabled=true\n");
+            file.write(data);
+        }
+    } else {
+        file.remove();
     }
-  } else {
-    file.remove();
-  }
 #elif defined(Q_OS_WIN)
-  QSettings bootUpSettings(
-    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
-    QSettings::NativeFormat);
-  if (start) {
-    QString app_path =
-      QDir::toNativeSeparators(QCoreApplication::applicationFilePath());
-    bootUpSettings.setValue("Flameshot", app_path);
-  } else {
-    bootUpSettings.remove("Flameshot");
-  }
+    QSettings bootUpSettings(
+      "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
+      QSettings::NativeFormat);
+    if (start) {
+        QString app_path =
+          QDir::toNativeSeparators(QCoreApplication::applicationFilePath());
+        bootUpSettings.setValue("Flameshot", app_path);
+    } else {
+        bootUpSettings.remove("Flameshot");
+    }
 #endif
-  m_settings.setValue(QStringLiteral("startupLaunch"), start);
+    m_settings.setValue(QStringLiteral("startupLaunch"), start);
 }
 
-int
-ConfigHandler::contrastOpacityValue()
+int ConfigHandler::contrastOpacityValue()
 {
-  int opacity = 190;
-  if (m_settings.contains(QStringLiteral("contrastOpacity"))) {
-    opacity = m_settings.value(QStringLiteral("contrastOpacity")).toInt();
-    opacity = qBound(0, opacity, 255);
-  }
-  return opacity;
+    int opacity = 190;
+    if (m_settings.contains(QStringLiteral("contrastOpacity"))) {
+        opacity = m_settings.value(QStringLiteral("contrastOpacity")).toInt();
+        opacity = qBound(0, opacity, 255);
+    }
+    return opacity;
 }
 
-void
-ConfigHandler::setContrastOpacity(const int transparency)
+void ConfigHandler::setContrastOpacity(const int transparency)
 {
-  m_settings.setValue(QStringLiteral("contrastOpacity"), transparency);
+    m_settings.setValue(QStringLiteral("contrastOpacity"), transparency);
 }
 
-bool
-ConfigHandler::closeAfterScreenshotValue()
+bool ConfigHandler::closeAfterScreenshotValue()
 {
-  return m_settings.value(QStringLiteral("closeAfterScreenshot")).toBool();
+    return m_settings.value(QStringLiteral("closeAfterScreenshot")).toBool();
 }
 
-void
-ConfigHandler::setCloseAfterScreenshot(const bool close)
+void ConfigHandler::setCloseAfterScreenshot(const bool close)
 {
-  m_settings.setValue(QStringLiteral("closeAfterScreenshot"), close);
+    m_settings.setValue(QStringLiteral("closeAfterScreenshot"), close);
 }
 
-bool
-ConfigHandler::copyAndCloseAfterUploadEnabled()
+bool ConfigHandler::copyAndCloseAfterUploadEnabled()
 {
-  return m_settings.value(QStringLiteral("copyAndCloseAfterUpload")).toBool();
+    return m_settings.value(QStringLiteral("copyAndCloseAfterUpload")).toBool();
 }
 
-void
-ConfigHandler::setCopyAndCloseAfterUploadEnabled(const bool value)
+void ConfigHandler::setCopyAndCloseAfterUploadEnabled(const bool value)
 {
-  m_settings.setValue(QStringLiteral("copyAndCloseAfterUpload"), value);
+    m_settings.setValue(QStringLiteral("copyAndCloseAfterUpload"), value);
 }
-bool
-ConfigHandler::saveAfterCopyValue()
+bool ConfigHandler::saveAfterCopyValue()
 {
-  return m_settings.value(QStringLiteral("saveAfterCopy")).toBool();
+    return m_settings.value(QStringLiteral("saveAfterCopy")).toBool();
 }
 
-void
-ConfigHandler::setSaveAfterCopy(const bool save)
+void ConfigHandler::setSaveAfterCopy(const bool save)
 {
-  m_settings.setValue(QStringLiteral("saveAfterCopy"), save);
+    m_settings.setValue(QStringLiteral("saveAfterCopy"), save);
 }
 
-QString
-ConfigHandler::saveAfterCopyPathValue()
+QString ConfigHandler::saveAfterCopyPathValue()
 {
-  return m_settings.value(QStringLiteral("saveAfterCopyPath")).toString();
+    return m_settings.value(QStringLiteral("saveAfterCopyPath")).toString();
 }
 
-void
-ConfigHandler::setSaveAfterCopyPath(const QString& path)
+void ConfigHandler::setSaveAfterCopyPath(const QString& path)
 {
-  m_settings.setValue(QStringLiteral("saveAfterCopyPath"), path);
+    m_settings.setValue(QStringLiteral("saveAfterCopyPath"), path);
 }
 
-void
-ConfigHandler::setDefaults()
+void ConfigHandler::setDefaults()
 {
-  m_settings.clear();
+    m_settings.clear();
 }
 
-void
-ConfigHandler::setAllTheButtons()
+void ConfigHandler::setAllTheButtons()
 {
-  QVector<int> buttons;
-  auto listTypes = CaptureToolButton::getIterableButtonTypes();
-  for (const CaptureToolButton::ButtonType t : listTypes) {
-    buttons << static_cast<int>(t);
-  }
-  // TODO: remove toList in v1.0
-  m_settings.setValue(QStringLiteral("buttons"),
-                      QVariant::fromValue(buttons.toList()));
+    QVector<int> buttons;
+    auto listTypes = CaptureToolButton::getIterableButtonTypes();
+    for (const CaptureToolButton::ButtonType t : listTypes) {
+        buttons << static_cast<int>(t);
+    }
+    // TODO: remove toList in v1.0
+    m_settings.setValue(QStringLiteral("buttons"),
+                        QVariant::fromValue(buttons.toList()));
 }
 
-QString
-ConfigHandler::configFilePath() const
+QString ConfigHandler::configFilePath() const
 {
-  return m_settings.fileName();
+    return m_settings.fileName();
 }
 
-bool
-ConfigHandler::normalizeButtons(QVector<int>& buttons)
+bool ConfigHandler::normalizeButtons(QVector<int>& buttons)
 {
-  auto listTypes = CaptureToolButton::getIterableButtonTypes();
-  QVector<int> listTypesInt;
-  for (auto i : listTypes)
-    listTypesInt << static_cast<int>(i);
+    auto listTypes = CaptureToolButton::getIterableButtonTypes();
+    QVector<int> listTypesInt;
+    for (auto i : listTypes)
+        listTypesInt << static_cast<int>(i);
 
-  bool hasChanged = false;
-  for (int i = 0; i < buttons.size(); i++) {
-    if (!listTypesInt.contains(buttons.at(i))) {
-      buttons.remove(i);
-      hasChanged = true;
+    bool hasChanged = false;
+    for (int i = 0; i < buttons.size(); i++) {
+        if (!listTypesInt.contains(buttons.at(i))) {
+            buttons.remove(i);
+            hasChanged = true;
+        }
     }
-  }
-  return hasChanged;
+    return hasChanged;
 }
 
-QVector<CaptureToolButton::ButtonType>
-ConfigHandler::fromIntToButton(const QVector<int>& l)
+QVector<CaptureToolButton::ButtonType> ConfigHandler::fromIntToButton(
+  const QVector<int>& l)
 {
-  QVector<CaptureToolButton::ButtonType> buttons;
-  for (auto const i : l)
-    buttons << static_cast<CaptureToolButton::ButtonType>(i);
-  return buttons;
+    QVector<CaptureToolButton::ButtonType> buttons;
+    for (auto const i : l)
+        buttons << static_cast<CaptureToolButton::ButtonType>(i);
+    return buttons;
 }
 
-QVector<int>
-ConfigHandler::fromButtonToInt(const QVector<CaptureToolButton::ButtonType>& l)
+QVector<int> ConfigHandler::fromButtonToInt(
+  const QVector<CaptureToolButton::ButtonType>& l)
 {
-  QVector<int> buttons;
-  for (auto const i : l)
-    buttons << static_cast<int>(i);
-  return buttons;
+    QVector<int> buttons;
+    for (auto const i : l)
+        buttons << static_cast<int>(i);
+    return buttons;
 }
diff --git a/src/utils/confighandler.h b/src/utils/confighandler.h
index 46cfb06f..38480e28 100644
--- a/src/utils/confighandler.h
+++ b/src/utils/confighandler.h
@@ -24,75 +24,77 @@
 class ConfigHandler
 {
 public:
-  explicit ConfigHandler();
+    explicit ConfigHandler();
 
-  QVector<CaptureToolButton::ButtonType> getButtons();
-  void setButtons(const QVector<CaptureToolButton::ButtonType>&);
+    QVector<CaptureToolButton::ButtonType> getButtons();
+    void setButtons(const QVector<CaptureToolButton::ButtonType>&);
 
-  QVector<QColor> getUserColors();
-  void setUserColors(const QVector<QColor>&);
+    QVector<QColor> getUserColors();
+    void setUserColors(const QVector<QColor>&);
 
-  QString savePathValue();
-  void setSavePath(const QString&);
+    QString savePathValue();
+    void setSavePath(const QString&);
 
-  QColor uiMainColorValue();
-  void setUIMainColor(const QColor&);
+    QColor uiMainColorValue();
+    void setUIMainColor(const QColor&);
 
-  QColor uiContrastColorValue();
-  void setUIContrastColor(const QColor&);
+    QColor uiContrastColorValue();
+    void setUIContrastColor(const QColor&);
 
-  QColor drawColorValue();
-  void setDrawColor(const QColor&);
+    QColor drawColorValue();
+    void setDrawColor(const QColor&);
 
-  bool showHelpValue();
-  void setShowHelp(const bool);
+    bool showHelpValue();
+    void setShowHelp(const bool);
 
-  bool showSidePanelButtonValue();
-  void setShowSidePanelButton(const bool);
+    bool showSidePanelButtonValue();
+    void setShowSidePanelButton(const bool);
 
-  bool desktopNotificationValue();
-  void setDesktopNotification(const bool);
+    bool desktopNotificationValue();
+    void setDesktopNotification(const bool);
 
-  QString filenamePatternValue();
-  void setFilenamePattern(const QString&);
+    QString filenamePatternValue();
+    void setFilenamePattern(const QString&);
 
-  bool disabledTrayIconValue();
-  void setDisabledTrayIcon(const bool);
+    bool disabledTrayIconValue();
+    void setDisabledTrayIcon(const bool);
 
-  int drawThicknessValue();
-  void setdrawThickness(const int);
+    int drawThicknessValue();
+    void setdrawThickness(const int);
 
-  bool keepOpenAppLauncherValue();
-  void setKeepOpenAppLauncher(const bool);
+    bool keepOpenAppLauncherValue();
+    void setKeepOpenAppLauncher(const bool);
 
-  bool verifyLaunchFile();
-  bool startupLaunchValue();
-  void setStartupLaunch(const bool);
+    bool verifyLaunchFile();
+    bool startupLaunchValue();
+    void setStartupLaunch(const bool);
 
-  int contrastOpacityValue();
-  void setContrastOpacity(const int);
+    int contrastOpacityValue();
+    void setContrastOpacity(const int);
 
-  bool closeAfterScreenshotValue();
-  void setCloseAfterScreenshot(const bool);
+    bool closeAfterScreenshotValue();
+    void setCloseAfterScreenshot(const bool);
 
-  bool copyAndCloseAfterUploadEnabled();
-  void setCopyAndCloseAfterUploadEnabled(const bool);
-  bool saveAfterCopyValue();
-  void setSaveAfterCopy(const bool);
+    bool copyAndCloseAfterUploadEnabled();
+    void setCopyAndCloseAfterUploadEnabled(const bool);
+    bool saveAfterCopyValue();
+    void setSaveAfterCopy(const bool);
 
-  QString saveAfterCopyPathValue();
-  void setSaveAfterCopyPath(const QString&);
+    QString saveAfterCopyPathValue();
+    void setSaveAfterCopyPath(const QString&);
 
-  void setDefaults();
-  void setAllTheButtons();
+    void setDefaults();
+    void setAllTheButtons();
 
-  QString configFilePath() const;
+    QString configFilePath() const;
 
 private:
-  QSettings m_settings;
+    QSettings m_settings;
 
-  bool normalizeButtons(QVector<int>&);
+    bool normalizeButtons(QVector<int>&);
 
-  QVector<CaptureToolButton::ButtonType> fromIntToButton(const QVector<int>& l);
-  QVector<int> fromButtonToInt(const QVector<CaptureToolButton::ButtonType>& l);
+    QVector<CaptureToolButton::ButtonType> fromIntToButton(
+      const QVector<int>& l);
+    QVector<int> fromButtonToInt(
+      const QVector<CaptureToolButton::ButtonType>& l);
 };
diff --git a/src/utils/dbusutils.cpp b/src/utils/dbusutils.cpp
index 7c906f38..070a1667 100644
--- a/src/utils/dbusutils.cpp
+++ b/src/utils/dbusutils.cpp
@@ -25,52 +25,48 @@ DBusUtils::DBusUtils(QObject* parent)
   : QObject(parent)
 {}
 
-void
-DBusUtils::connectPrintCapture(QDBusConnection& session, uint id)
+void DBusUtils::connectPrintCapture(QDBusConnection& session, uint id)
 {
-  m_id = id;
-  // captureTaken
-  session.connect(QStringLiteral("org.flameshot.Flameshot"),
-                  QStringLiteral("/"),
-                  QLatin1String(""),
-                  QStringLiteral("captureTaken"),
-                  this,
-                  SLOT(captureTaken(uint, QByteArray)));
-  // captureFailed
-  session.connect(QStringLiteral("org.flameshot.Flameshot"),
-                  QStringLiteral("/"),
-                  QLatin1String(""),
-                  QStringLiteral("captureFailed"),
-                  this,
-                  SLOT(captureFailed(uint)));
+    m_id = id;
+    // captureTaken
+    session.connect(QStringLiteral("org.flameshot.Flameshot"),
+                    QStringLiteral("/"),
+                    QLatin1String(""),
+                    QStringLiteral("captureTaken"),
+                    this,
+                    SLOT(captureTaken(uint, QByteArray)));
+    // captureFailed
+    session.connect(QStringLiteral("org.flameshot.Flameshot"),
+                    QStringLiteral("/"),
+                    QLatin1String(""),
+                    QStringLiteral("captureFailed"),
+                    this,
+                    SLOT(captureFailed(uint)));
 }
 
-void
-DBusUtils::checkDBusConnection(const QDBusConnection& connection)
+void DBusUtils::checkDBusConnection(const QDBusConnection& connection)
 {
-  if (!connection.isConnected()) {
-    SystemNotification().sendMessage(tr("Unable to connect via DBus"));
-    qApp->exit(1);
-  }
+    if (!connection.isConnected()) {
+        SystemNotification().sendMessage(tr("Unable to connect via DBus"));
+        qApp->exit(1);
+    }
 }
 
-void
-DBusUtils::captureTaken(uint id, QByteArray rawImage)
+void DBusUtils::captureTaken(uint id, QByteArray rawImage)
 {
-  if (m_id == id) {
-    QFile file;
-    file.open(stdout, QIODevice::WriteOnly);
-    file.write(rawImage);
-    file.close();
-    qApp->exit();
-  }
+    if (m_id == id) {
+        QFile file;
+        file.open(stdout, QIODevice::WriteOnly);
+        file.write(rawImage);
+        file.close();
+        qApp->exit();
+    }
 }
 
-void
-DBusUtils::captureFailed(uint id)
+void DBusUtils::captureFailed(uint id)
 {
-  if (m_id == id) {
-    QTextStream(stdout) << "screenshot aborted\n";
-    qApp->exit(1);
-  }
+    if (m_id == id) {
+        QTextStream(stdout) << "screenshot aborted\n";
+        qApp->exit(1);
+    }
 }
diff --git a/src/utils/dbusutils.h b/src/utils/dbusutils.h
index 82de1b95..87a84c07 100644
--- a/src/utils/dbusutils.h
+++ b/src/utils/dbusutils.h
@@ -23,17 +23,17 @@
 
 class DBusUtils : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit DBusUtils(QObject* parent = nullptr);
+    explicit DBusUtils(QObject* parent = nullptr);
 
-  void connectPrintCapture(QDBusConnection& session, uint id);
-  void checkDBusConnection(const QDBusConnection& connection);
+    void connectPrintCapture(QDBusConnection& session, uint id);
+    void checkDBusConnection(const QDBusConnection& connection);
 
 public slots:
-  void captureTaken(uint id, QByteArray rawImage);
-  void captureFailed(uint id);
+    void captureTaken(uint id, QByteArray rawImage);
+    void captureFailed(uint id);
 
 private:
-  uint m_id;
+    uint m_id;
 };
diff --git a/src/utils/desktopfileparse.cpp b/src/utils/desktopfileparse.cpp
index 88171d62..b6d0f005 100644
--- a/src/utils/desktopfileparse.cpp
+++ b/src/utils/desktopfileparse.cpp
@@ -24,126 +24,130 @@
 
 DesktopFileParser::DesktopFileParser()
 {
-  QString locale = QLocale().name();
-  QString localeShort = QLocale().name().left(2);
-  m_localeName = QStringLiteral("Name[%1]").arg(locale);
-  m_localeDescription = QStringLiteral("Comment[%1]").arg(locale);
-  m_localeNameShort = QStringLiteral("Name[%1]").arg(localeShort);
-  m_localeDescriptionShort = QStringLiteral("Comment[%1]").arg(localeShort);
-  m_defaultIcon = QIcon::fromTheme(QStringLiteral("application-x-executable"));
+    QString locale = QLocale().name();
+    QString localeShort = QLocale().name().left(2);
+    m_localeName = QStringLiteral("Name[%1]").arg(locale);
+    m_localeDescription = QStringLiteral("Comment[%1]").arg(locale);
+    m_localeNameShort = QStringLiteral("Name[%1]").arg(localeShort);
+    m_localeDescriptionShort = QStringLiteral("Comment[%1]").arg(localeShort);
+    m_defaultIcon =
+      QIcon::fromTheme(QStringLiteral("application-x-executable"));
 }
 
-DesktopAppData
-DesktopFileParser::parseDesktopFile(const QString& fileName, bool& ok) const
+DesktopAppData DesktopFileParser::parseDesktopFile(const QString& fileName,
+                                                   bool& ok) const
 {
-  DesktopAppData res;
-  ok = true;
-  QFile file(fileName);
-  if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
-    ok = false;
-    return res;
-  }
-  bool nameLocaleSet = false;
-  bool descriptionLocaleSet = false;
-  bool isApplication = false;
-  QTextStream in(&file);
-  // enter the desktop entry definition
-  while (!in.atEnd() && in.readLine() != QLatin1String("[Desktop Entry]")) {
-  }
-  // start parsing
-  while (!in.atEnd()) {
-    QString line = in.readLine();
-    if (line.startsWith(QLatin1String("Icon"))) {
-      res.icon = QIcon::fromTheme(
-        line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed(),
-        m_defaultIcon);
-    } else if (!nameLocaleSet && line.startsWith(QLatin1String("Name"))) {
-      if (line.startsWith(m_localeName) || line.startsWith(m_localeNameShort)) {
-        res.name = line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
-        nameLocaleSet = true;
-      } else if (line.startsWith(QLatin1String("Name="))) {
-        res.name = line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
-      }
-    } else if (!descriptionLocaleSet &&
-               line.startsWith(QLatin1String("Comment"))) {
-      if (line.startsWith(m_localeDescription) ||
-          line.startsWith(m_localeDescriptionShort)) {
-        res.description =
-          line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
-        descriptionLocaleSet = true;
-      } else if (line.startsWith(QLatin1String("Comment="))) {
-        res.description =
-          line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
-      }
-    } else if (line.startsWith(QLatin1String("Exec"))) {
-      if (line.contains(QLatin1String("%"))) {
-        res.exec = line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
-      } else {
+    DesktopAppData res;
+    ok = true;
+    QFile file(fileName);
+    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
         ok = false;
-        break;
-      }
-    } else if (line.startsWith(QLatin1String("Type"))) {
-      if (line.contains(QLatin1String("Application"))) {
-        isApplication = true;
-      }
-    } else if (line.startsWith(QLatin1String("Categories"))) {
-      res.categories = line.mid(line.indexOf(QLatin1String("=")) + 1)
-                         .split(QStringLiteral(";"));
-    } else if (line == QLatin1String("NoDisplay=true")) {
-      ok = false;
-      break;
-    } else if (line == QLatin1String("Terminal=true")) {
-      res.showInTerminal = true;
+        return res;
+    }
+    bool nameLocaleSet = false;
+    bool descriptionLocaleSet = false;
+    bool isApplication = false;
+    QTextStream in(&file);
+    // enter the desktop entry definition
+    while (!in.atEnd() && in.readLine() != QLatin1String("[Desktop Entry]")) {
     }
-    // ignore the other entries
-    else if (line.startsWith(QLatin1String("["))) {
-      break;
+    // start parsing
+    while (!in.atEnd()) {
+        QString line = in.readLine();
+        if (line.startsWith(QLatin1String("Icon"))) {
+            res.icon = QIcon::fromTheme(
+              line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed(),
+              m_defaultIcon);
+        } else if (!nameLocaleSet && line.startsWith(QLatin1String("Name"))) {
+            if (line.startsWith(m_localeName) ||
+                line.startsWith(m_localeNameShort)) {
+                res.name =
+                  line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
+                nameLocaleSet = true;
+            } else if (line.startsWith(QLatin1String("Name="))) {
+                res.name =
+                  line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
+            }
+        } else if (!descriptionLocaleSet &&
+                   line.startsWith(QLatin1String("Comment"))) {
+            if (line.startsWith(m_localeDescription) ||
+                line.startsWith(m_localeDescriptionShort)) {
+                res.description =
+                  line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
+                descriptionLocaleSet = true;
+            } else if (line.startsWith(QLatin1String("Comment="))) {
+                res.description =
+                  line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
+            }
+        } else if (line.startsWith(QLatin1String("Exec"))) {
+            if (line.contains(QLatin1String("%"))) {
+                res.exec =
+                  line.mid(line.indexOf(QLatin1String("=")) + 1).trimmed();
+            } else {
+                ok = false;
+                break;
+            }
+        } else if (line.startsWith(QLatin1String("Type"))) {
+            if (line.contains(QLatin1String("Application"))) {
+                isApplication = true;
+            }
+        } else if (line.startsWith(QLatin1String("Categories"))) {
+            res.categories = line.mid(line.indexOf(QLatin1String("=")) + 1)
+                               .split(QStringLiteral(";"));
+        } else if (line == QLatin1String("NoDisplay=true")) {
+            ok = false;
+            break;
+        } else if (line == QLatin1String("Terminal=true")) {
+            res.showInTerminal = true;
+        }
+        // ignore the other entries
+        else if (line.startsWith(QLatin1String("["))) {
+            break;
+        }
+    }
+    file.close();
+    if (res.exec.isEmpty() || res.name.isEmpty() || !isApplication) {
+        ok = false;
     }
-  }
-  file.close();
-  if (res.exec.isEmpty() || res.name.isEmpty() || !isApplication) {
-    ok = false;
-  }
-  return res;
+    return res;
 }
 
-int
-DesktopFileParser::processDirectory(const QDir& dir)
+int DesktopFileParser::processDirectory(const QDir& dir)
 {
-  QStringList entries = dir.entryList(QDir::NoDotAndDotDot | QDir::Files);
-  bool ok;
-  int length = m_appList.length();
-  for (QString file : entries) {
-    DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok);
-    if (ok) {
-      m_appList.append(app);
+    QStringList entries = dir.entryList(QDir::NoDotAndDotDot | QDir::Files);
+    bool ok;
+    int length = m_appList.length();
+    for (QString file : entries) {
+        DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok);
+        if (ok) {
+            m_appList.append(app);
+        }
     }
-  }
-  return m_appList.length() - length;
+    return m_appList.length() - length;
 }
 
-QVector<DesktopAppData>
-DesktopFileParser::getAppsByCategory(const QString& category)
+QVector<DesktopAppData> DesktopFileParser::getAppsByCategory(
+  const QString& category)
 {
-  QVector<DesktopAppData> res;
-  for (const DesktopAppData& app : m_appList) {
-    if (app.categories.contains(category)) {
-      res.append(app);
+    QVector<DesktopAppData> res;
+    for (const DesktopAppData& app : m_appList) {
+        if (app.categories.contains(category)) {
+            res.append(app);
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-QMap<QString, QVector<DesktopAppData>>
-DesktopFileParser::getAppsByCategory(const QStringList& categories)
+QMap<QString, QVector<DesktopAppData>> DesktopFileParser::getAppsByCategory(
+  const QStringList& categories)
 {
-  QMap<QString, QVector<DesktopAppData>> res;
-  for (const DesktopAppData& app : m_appList) {
-    for (const QString& category : categories) {
-      if (app.categories.contains(category)) {
-        res[category].append(app);
-      }
+    QMap<QString, QVector<DesktopAppData>> res;
+    for (const DesktopAppData& app : m_appList) {
+        for (const QString& category : categories) {
+            if (app.categories.contains(category)) {
+                res[category].append(app);
+            }
+        }
     }
-  }
-  return res;
+    return res;
 }
diff --git a/src/utils/desktopfileparse.h b/src/utils/desktopfileparse.h
index 79e74509..0f39c4f4 100644
--- a/src/utils/desktopfileparse.h
+++ b/src/utils/desktopfileparse.h
@@ -27,50 +27,50 @@ class QTextStream;
 
 struct DesktopAppData
 {
-  DesktopAppData()
-    : showInTerminal()
-  {}
+    DesktopAppData()
+      : showInTerminal()
+    {}
 
-  DesktopAppData(const QString& name,
-                 const QString& description,
-                 const QString& exec,
-                 QIcon icon)
-    : name(name)
-    , description(description)
-    , exec(exec)
-    , icon(icon)
-    , showInTerminal(false)
-  {}
+    DesktopAppData(const QString& name,
+                   const QString& description,
+                   const QString& exec,
+                   QIcon icon)
+      : name(name)
+      , description(description)
+      , exec(exec)
+      , icon(icon)
+      , showInTerminal(false)
+    {}
 
-  bool operator==(const DesktopAppData& other) const
-  {
-    return name == other.name;
-  }
+    bool operator==(const DesktopAppData& other) const
+    {
+        return name == other.name;
+    }
 
-  QString name;
-  QString description;
-  QString exec;
-  QStringList categories;
-  QIcon icon;
-  bool showInTerminal;
+    QString name;
+    QString description;
+    QString exec;
+    QStringList categories;
+    QIcon icon;
+    bool showInTerminal;
 };
 
 struct DesktopFileParser
 {
-  DesktopFileParser();
-  DesktopAppData parseDesktopFile(const QString& fileName, bool& ok) const;
-  int processDirectory(const QDir& dir);
+    DesktopFileParser();
+    DesktopAppData parseDesktopFile(const QString& fileName, bool& ok) const;
+    int processDirectory(const QDir& dir);
 
-  QVector<DesktopAppData> getAppsByCategory(const QString& category);
-  QMap<QString, QVector<DesktopAppData>> getAppsByCategory(
-    const QStringList& categories);
+    QVector<DesktopAppData> getAppsByCategory(const QString& category);
+    QMap<QString, QVector<DesktopAppData>> getAppsByCategory(
+      const QStringList& categories);
 
 private:
-  QString m_localeName;
-  QString m_localeDescription;
-  QString m_localeNameShort;
-  QString m_localeDescriptionShort;
+    QString m_localeName;
+    QString m_localeDescription;
+    QString m_localeNameShort;
+    QString m_localeDescriptionShort;
 
-  QIcon m_defaultIcon;
-  QVector<DesktopAppData> m_appList;
+    QIcon m_defaultIcon;
+    QVector<DesktopAppData> m_appList;
 };
diff --git a/src/utils/desktopinfo.cpp b/src/utils/desktopinfo.cpp
index 57bfdd16..bb932b78 100644
--- a/src/utils/desktopinfo.cpp
+++ b/src/utils/desktopinfo.cpp
@@ -20,35 +20,33 @@
 
 DesktopInfo::DesktopInfo()
 {
-  auto e = QProcessEnvironment::systemEnvironment();
-  XDG_CURRENT_DESKTOP = e.value(QStringLiteral("XDG_CURRENT_DESKTOP"));
-  XDG_SESSION_TYPE = e.value(QStringLiteral("XDG_SESSION_TYPE"));
-  WAYLAND_DISPLAY = e.value(QStringLiteral("WAYLAND_DISPLAY"));
-  KDE_FULL_SESSION = e.value(QStringLiteral("KDE_FULL_SESSION"));
-  GNOME_DESKTOP_SESSION_ID =
-    e.value(QStringLiteral("GNOME_DESKTOP_SESSION_ID"));
-  DESKTOP_SESSION = e.value(QStringLiteral("DESKTOP_SESSION"));
+    auto e = QProcessEnvironment::systemEnvironment();
+    XDG_CURRENT_DESKTOP = e.value(QStringLiteral("XDG_CURRENT_DESKTOP"));
+    XDG_SESSION_TYPE = e.value(QStringLiteral("XDG_SESSION_TYPE"));
+    WAYLAND_DISPLAY = e.value(QStringLiteral("WAYLAND_DISPLAY"));
+    KDE_FULL_SESSION = e.value(QStringLiteral("KDE_FULL_SESSION"));
+    GNOME_DESKTOP_SESSION_ID =
+      e.value(QStringLiteral("GNOME_DESKTOP_SESSION_ID"));
+    DESKTOP_SESSION = e.value(QStringLiteral("DESKTOP_SESSION"));
 }
 
-bool
-DesktopInfo::waylandDectected()
+bool DesktopInfo::waylandDectected()
 {
-  return XDG_SESSION_TYPE == QLatin1String("wayland") ||
-         WAYLAND_DISPLAY.contains(QLatin1String("wayland"),
-                                  Qt::CaseInsensitive);
+    return XDG_SESSION_TYPE == QLatin1String("wayland") ||
+           WAYLAND_DISPLAY.contains(QLatin1String("wayland"),
+                                    Qt::CaseInsensitive);
 }
 
-DesktopInfo::WM
-DesktopInfo::windowManager()
+DesktopInfo::WM DesktopInfo::windowManager()
 {
-  DesktopInfo::WM res = DesktopInfo::OTHER;
-  if (XDG_CURRENT_DESKTOP.contains(QLatin1String("GNOME"),
-                                   Qt::CaseInsensitive) ||
-      !GNOME_DESKTOP_SESSION_ID.isEmpty()) {
-    res = DesktopInfo::GNOME;
-  } else if (!KDE_FULL_SESSION.isEmpty() ||
-             DESKTOP_SESSION == QLatin1String("kde-plasma")) {
-    res = DesktopInfo::KDE;
-  }
-  return res;
+    DesktopInfo::WM res = DesktopInfo::OTHER;
+    if (XDG_CURRENT_DESKTOP.contains(QLatin1String("GNOME"),
+                                     Qt::CaseInsensitive) ||
+        !GNOME_DESKTOP_SESSION_ID.isEmpty()) {
+        res = DesktopInfo::GNOME;
+    } else if (!KDE_FULL_SESSION.isEmpty() ||
+               DESKTOP_SESSION == QLatin1String("kde-plasma")) {
+        res = DesktopInfo::KDE;
+    }
+    return res;
 }
diff --git a/src/utils/desktopinfo.h b/src/utils/desktopinfo.h
index 8eff6acc..061c6e0a 100644
--- a/src/utils/desktopinfo.h
+++ b/src/utils/desktopinfo.h
@@ -22,24 +22,24 @@
 class DesktopInfo
 {
 public:
-  DesktopInfo();
+    DesktopInfo();
 
-  enum WM
-  {
-    GNOME,
-    KDE,
-    OTHER
-  };
+    enum WM
+    {
+        GNOME,
+        KDE,
+        OTHER
+    };
 
-  bool waylandDectected();
-  WM windowManager();
+    bool waylandDectected();
+    WM windowManager();
 
 private:
-  QString XDG_CURRENT_DESKTOP;
-  QString XDG_SESSION_TYPE;
-  QString WAYLAND_DISPLAY;
-  QString KDE_FULL_SESSION;
-  QString GNOME_DESKTOP_SESSION_ID;
-  QString GDMSESSION;
-  QString DESKTOP_SESSION;
+    QString XDG_CURRENT_DESKTOP;
+    QString XDG_SESSION_TYPE;
+    QString WAYLAND_DISPLAY;
+    QString KDE_FULL_SESSION;
+    QString GNOME_DESKTOP_SESSION_ID;
+    QString GDMSESSION;
+    QString DESKTOP_SESSION;
 };
diff --git a/src/utils/filenamehandler.cpp b/src/utils/filenamehandler.cpp
index 2b51c458..e3eb0e7c 100644
--- a/src/utils/filenamehandler.cpp
+++ b/src/utils/filenamehandler.cpp
@@ -25,106 +25,98 @@
 FileNameHandler::FileNameHandler(QObject* parent)
   : QObject(parent)
 {
-  std::locale::global(std::locale(""));
+    std::locale::global(std::locale(""));
 }
 
-QString
-FileNameHandler::parsedPattern()
+QString FileNameHandler::parsedPattern()
 {
-  return parseFilename(ConfigHandler().filenamePatternValue());
+    return parseFilename(ConfigHandler().filenamePatternValue());
 }
 
-QString
-FileNameHandler::parseFilename(const QString& name)
+QString FileNameHandler::parseFilename(const QString& name)
 {
-  QString res = name;
-  if (name.isEmpty()) {
-    res = QLatin1String("%F_%H-%M");
-  }
-  std::time_t t = std::time(NULL);
+    QString res = name;
+    if (name.isEmpty()) {
+        res = QLatin1String("%F_%H-%M");
+    }
+    std::time_t t = std::time(NULL);
 
-  char* tempData = QStringTocharArr(res);
-  char data[MAX_CHARACTERS] = { 0 };
-  std::strftime(data, sizeof(data), tempData, std::localtime(&t));
-  res = QString::fromLocal8Bit(data, (int)strlen(data));
-  free(tempData);
+    char* tempData = QStringTocharArr(res);
+    char data[MAX_CHARACTERS] = { 0 };
+    std::strftime(data, sizeof(data), tempData, std::localtime(&t));
+    res = QString::fromLocal8Bit(data, (int)strlen(data));
+    free(tempData);
 
-  // add the parsed pattern in a correct format for the filesystem
-  res = res.replace(QLatin1String("/"), QStringLiteral("⁄"))
-          .replace(QLatin1String(":"), QLatin1String("-"));
-  return res;
+    // add the parsed pattern in a correct format for the filesystem
+    res = res.replace(QLatin1String("/"), QStringLiteral("⁄"))
+            .replace(QLatin1String(":"), QLatin1String("-"));
+    return res;
 }
 
-QString
-FileNameHandler::generateAbsolutePath(const QString& path)
+QString FileNameHandler::generateAbsolutePath(const QString& path)
 {
-  QString directory = path;
-  QString filename = parsedPattern();
-  fixPath(directory, filename);
-  return directory + filename;
+    QString directory = path;
+    QString filename = parsedPattern();
+    fixPath(directory, filename);
+    return directory + filename;
 }
 // path a images si no existe, add numeration
-void
-FileNameHandler::setPattern(const QString& pattern)
+void FileNameHandler::setPattern(const QString& pattern)
 {
-  ConfigHandler().setFilenamePattern(pattern);
+    ConfigHandler().setFilenamePattern(pattern);
 }
 
-QString
-FileNameHandler::absoluteSavePath(QString& directory, QString& filename)
+QString FileNameHandler::absoluteSavePath(QString& directory, QString& filename)
 {
-  ConfigHandler config;
-  directory = config.savePathValue();
-  if (directory.isEmpty() || !QDir(directory).exists() ||
-      !QFileInfo(directory).isWritable()) {
-    directory =
-      QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);
-  }
-  filename = parsedPattern();
-  fixPath(directory, filename);
-  return directory + filename;
+    ConfigHandler config;
+    directory = config.savePathValue();
+    if (directory.isEmpty() || !QDir(directory).exists() ||
+        !QFileInfo(directory).isWritable()) {
+        directory =
+          QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);
+    }
+    filename = parsedPattern();
+    fixPath(directory, filename);
+    return directory + filename;
 }
 
-QString
-FileNameHandler::absoluteSavePath()
+QString FileNameHandler::absoluteSavePath()
 {
-  QString dir, file;
-  return absoluteSavePath(dir, file);
+    QString dir, file;
+    return absoluteSavePath(dir, file);
 }
 
-QString
-FileNameHandler::charArrToQString(const char* c)
+QString FileNameHandler::charArrToQString(const char* c)
 {
-  return QString::fromLocal8Bit(c, MAX_CHARACTERS);
+    return QString::fromLocal8Bit(c, MAX_CHARACTERS);
 }
 
-char*
-FileNameHandler::QStringTocharArr(const QString& s)
+char* FileNameHandler::QStringTocharArr(const QString& s)
 {
-  QByteArray ba = s.toLocal8Bit();
-  return const_cast<char*>(strdup(ba.constData()));
+    QByteArray ba = s.toLocal8Bit();
+    return const_cast<char*>(strdup(ba.constData()));
 }
 
-void
-FileNameHandler::fixPath(QString& directory, QString& filename)
+void FileNameHandler::fixPath(QString& directory, QString& filename)
 {
-  // add '/' at the end of the directory
-  if (!directory.endsWith(QLatin1String("/"))) {
-    directory += QLatin1String("/");
-  }
-  // add numeration in case of repeated filename in the directory
-  // find unused name adding _n where n is a number
-  QFileInfo checkFile(directory + filename + ".png");
-  if (checkFile.exists()) {
-    filename += QLatin1String("_");
-    int i = 1;
-    while (true) {
-      checkFile.setFile(directory + filename + QString::number(i) + ".png");
-      if (!checkFile.exists()) {
-        filename += QString::number(i);
-        break;
-      }
-      ++i;
+    // add '/' at the end of the directory
+    if (!directory.endsWith(QLatin1String("/"))) {
+        directory += QLatin1String("/");
+    }
+    // add numeration in case of repeated filename in the directory
+    // find unused name adding _n where n is a number
+    QFileInfo checkFile(directory + filename + ".png");
+    if (checkFile.exists()) {
+        filename += QLatin1String("_");
+        int i = 1;
+        while (true) {
+            checkFile.setFile(directory + filename + QString::number(i) +
+                              ".png");
+            if (!checkFile.exists()) {
+                filename += QString::number(i);
+                break;
+            }
+            ++i;
+        }
     }
-  }
 }
diff --git a/src/utils/filenamehandler.h b/src/utils/filenamehandler.h
index 74d5e875..c20e752f 100644
--- a/src/utils/filenamehandler.h
+++ b/src/utils/filenamehandler.h
@@ -21,25 +21,25 @@
 
 class FileNameHandler : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit FileNameHandler(QObject* parent = nullptr);
+    explicit FileNameHandler(QObject* parent = nullptr);
 
-  QString parsedPattern();
-  QString parseFilename(const QString& name);
-  QString generateAbsolutePath(const QString& path);
-  QString absoluteSavePath(QString& directory, QString& filename);
-  QString absoluteSavePath();
+    QString parsedPattern();
+    QString parseFilename(const QString& name);
+    QString generateAbsolutePath(const QString& path);
+    QString absoluteSavePath(QString& directory, QString& filename);
+    QString absoluteSavePath();
 
-  static const int MAX_CHARACTERS = 70;
+    static const int MAX_CHARACTERS = 70;
 
 public slots:
-  void setPattern(const QString& pattern);
+    void setPattern(const QString& pattern);
 
 private:
-  // using charArr = char[MAX_CHARACTERS];
-  QString charArrToQString(const char* c);
-  char* QStringTocharArr(const QString& s);
+    // using charArr = char[MAX_CHARACTERS];
+    QString charArrToQString(const char* c);
+    char* QStringTocharArr(const QString& s);
 
-  void fixPath(QString& directory, QString& filename);
+    void fixPath(QString& directory, QString& filename);
 };
diff --git a/src/utils/globalvalues.cpp b/src/utils/globalvalues.cpp
index de394136..60349e6d 100644
--- a/src/utils/globalvalues.cpp
+++ b/src/utils/globalvalues.cpp
@@ -19,8 +19,7 @@
 #include <QApplication>
 #include <QFontMetrics>
 
-int
-GlobalValues::buttonBaseSize()
+int GlobalValues::buttonBaseSize()
 {
-  return QApplication::fontMetrics().lineSpacing() * 2.2;
+    return QApplication::fontMetrics().lineSpacing() * 2.2;
 }
diff --git a/src/utils/globalvalues.h b/src/utils/globalvalues.h
index 64478036..656306bd 100644
--- a/src/utils/globalvalues.h
+++ b/src/utils/globalvalues.h
@@ -19,7 +19,6 @@
 
 namespace GlobalValues {
 
-int
-buttonBaseSize();
+int buttonBaseSize();
 
 }
diff --git a/src/utils/pathinfo.cpp b/src/utils/pathinfo.cpp
index 366b9d07..32802d1e 100644
--- a/src/utils/pathinfo.cpp
+++ b/src/utils/pathinfo.cpp
@@ -20,29 +20,27 @@
 #include <QDir>
 #include <QFileInfo>
 
-const QString
-PathInfo::whiteIconPath()
+const QString PathInfo::whiteIconPath()
 {
-  return QStringLiteral(":/img/material/white/");
+    return QStringLiteral(":/img/material/white/");
 }
 
-const QString
-PathInfo::blackIconPath()
+const QString PathInfo::blackIconPath()
 {
-  return QStringLiteral(":/img/material/black/");
+    return QStringLiteral(":/img/material/black/");
 }
 
-QStringList
-PathInfo::translationsPaths()
+QStringList PathInfo::translationsPaths()
 {
-  QString binaryPath = QFileInfo(qApp->applicationDirPath()).absoluteFilePath();
-  QString trPath = QDir::toNativeSeparators(binaryPath + "/translations");
+    QString binaryPath =
+      QFileInfo(qApp->applicationDirPath()).absoluteFilePath();
+    QString trPath = QDir::toNativeSeparators(binaryPath + "/translations");
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  return QStringList()
-         << QStringLiteral(APP_PREFIX) + "/share/flameshot/translations"
-         << trPath << QStringLiteral("/usr/share/flameshot/translations")
-         << QStringLiteral("/usr/local/share/flameshot/translations");
+    return QStringList()
+           << QStringLiteral(APP_PREFIX) + "/share/flameshot/translations"
+           << trPath << QStringLiteral("/usr/share/flameshot/translations")
+           << QStringLiteral("/usr/local/share/flameshot/translations");
 #elif defined(Q_OS_WIN)
-  return QStringList() << trPath;
+    return QStringList() << trPath;
 #endif
 }
diff --git a/src/utils/pathinfo.h b/src/utils/pathinfo.h
index 28004fd7..d7d57ddd 100644
--- a/src/utils/pathinfo.h
+++ b/src/utils/pathinfo.h
@@ -21,13 +21,10 @@
 
 namespace PathInfo { // namespace
 
-const QString
-whiteIconPath();
+const QString whiteIconPath();
 
-const QString
-blackIconPath();
+const QString blackIconPath();
 
-QStringList
-translationsPaths();
+QStringList translationsPaths();
 
 } // namespace
diff --git a/src/utils/screengrabber.cpp b/src/utils/screengrabber.cpp
index c2a9ae67..a6a35711 100644
--- a/src/utils/screengrabber.cpp
+++ b/src/utils/screengrabber.cpp
@@ -34,101 +34,102 @@ ScreenGrabber::ScreenGrabber(QObject* parent)
   : QObject(parent)
 {}
 
-QPixmap
-ScreenGrabber::grabEntireDesktop(bool& ok)
+QPixmap ScreenGrabber::grabEntireDesktop(bool& ok)
 {
-  ok = true;
+    ok = true;
 #if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)
-  if (m_info.waylandDectected()) {
-    QPixmap res;
-    // handle screenshot based on DE
-    switch (m_info.windowManager()) {
-      case DesktopInfo::GNOME: {
-        // https://github.com/GNOME/gnome-shell/blob/695bfb96160033be55cfb5ac41c121998f98c328/data/org.gnome.Shell.Screenshot.xml
-        QString path =
-          FileNameHandler().generateAbsolutePath(QDir::tempPath()) + ".png";
-        QDBusInterface gnomeInterface(
-          QStringLiteral("org.gnome.Shell"),
-          QStringLiteral("/org/gnome/Shell/Screenshot"),
-          QStringLiteral("org.gnome.Shell.Screenshot"));
-        QDBusReply<bool> reply =
-          gnomeInterface.call(QStringLiteral("Screenshot"), false, false, path);
-        if (reply.value()) {
-          res = QPixmap(path);
-          QFile dbusResult(path);
-          dbusResult.remove();
-        } else {
-          ok = false;
+    if (m_info.waylandDectected()) {
+        QPixmap res;
+        // handle screenshot based on DE
+        switch (m_info.windowManager()) {
+            case DesktopInfo::GNOME: {
+                // https://github.com/GNOME/gnome-shell/blob/695bfb96160033be55cfb5ac41c121998f98c328/data/org.gnome.Shell.Screenshot.xml
+                QString path =
+                  FileNameHandler().generateAbsolutePath(QDir::tempPath()) +
+                  ".png";
+                QDBusInterface gnomeInterface(
+                  QStringLiteral("org.gnome.Shell"),
+                  QStringLiteral("/org/gnome/Shell/Screenshot"),
+                  QStringLiteral("org.gnome.Shell.Screenshot"));
+                QDBusReply<bool> reply = gnomeInterface.call(
+                  QStringLiteral("Screenshot"), false, false, path);
+                if (reply.value()) {
+                    res = QPixmap(path);
+                    QFile dbusResult(path);
+                    dbusResult.remove();
+                } else {
+                    ok = false;
+                }
+                break;
+            }
+            case DesktopInfo::KDE: {
+                // https://github.com/KDE/spectacle/blob/517a7baf46a4ca0a45f32fd3f2b1b7210b180134/src/PlatformBackends/KWinWaylandImageGrabber.cpp#L145
+                QDBusInterface kwinInterface(
+                  QStringLiteral("org.kde.KWin"),
+                  QStringLiteral("/Screenshot"),
+                  QStringLiteral("org.kde.kwin.Screenshot"));
+                QDBusReply<QString> reply =
+                  kwinInterface.call(QStringLiteral("screenshotFullscreen"));
+                res = QPixmap(reply.value());
+                if (!res.isNull()) {
+                    QFile dbusResult(reply.value());
+                    dbusResult.remove();
+                }
+                break;
+            }
+            default:
+                ok = false;
+                break;
         }
-        break;
-      }
-      case DesktopInfo::KDE: {
-        // https://github.com/KDE/spectacle/blob/517a7baf46a4ca0a45f32fd3f2b1b7210b180134/src/PlatformBackends/KWinWaylandImageGrabber.cpp#L145
-        QDBusInterface kwinInterface(QStringLiteral("org.kde.KWin"),
-                                     QStringLiteral("/Screenshot"),
-                                     QStringLiteral("org.kde.kwin.Screenshot"));
-        QDBusReply<QString> reply =
-          kwinInterface.call(QStringLiteral("screenshotFullscreen"));
-        res = QPixmap(reply.value());
-        if (!res.isNull()) {
-          QFile dbusResult(reply.value());
-          dbusResult.remove();
+        if (!ok) {
+            SystemNotification().sendMessage(tr("Unable to capture screen"));
         }
-        break;
-      }
-      default:
-        ok = false;
-        break;
-    }
-    if (!ok) {
-      SystemNotification().sendMessage(tr("Unable to capture screen"));
+        return res;
     }
-    return res;
-  }
 #endif
 
-  QRect geometry;
-  for (QScreen* const screen : QGuiApplication::screens()) {
-    geometry = geometry.united(screen->geometry());
-  }
+    QRect geometry;
+    for (QScreen* const screen : QGuiApplication::screens()) {
+        geometry = geometry.united(screen->geometry());
+    }
 
-  QPixmap p(
-    QApplication::primaryScreen()->grabWindow(QApplication::desktop()->winId(),
-                                              geometry.x(),
-                                              geometry.y(),
-                                              geometry.width(),
-                                              geometry.height()));
-  auto screenNumber = QApplication::desktop()->screenNumber();
-  QScreen* screen = QApplication::screens()[screenNumber];
-  p.setDevicePixelRatio(screen->devicePixelRatio());
-  return p;
+    QPixmap p(QApplication::primaryScreen()->grabWindow(
+      QApplication::desktop()->winId(),
+      geometry.x(),
+      geometry.y(),
+      geometry.width(),
+      geometry.height()));
+    auto screenNumber = QApplication::desktop()->screenNumber();
+    QScreen* screen = QApplication::screens()[screenNumber];
+    p.setDevicePixelRatio(screen->devicePixelRatio());
+    return p;
 }
 
-QPixmap
-ScreenGrabber::grabScreen(int screenNumber, bool& ok)
+QPixmap ScreenGrabber::grabScreen(int screenNumber, bool& ok)
 {
-  QPixmap p;
-  bool isVirtual = QApplication::desktop()->isVirtualDesktop();
-  if (isVirtual || m_info.waylandDectected()) {
-    p = grabEntireDesktop(ok);
-    if (ok) {
-      QPoint topLeft(0, 0);
+    QPixmap p;
+    bool isVirtual = QApplication::desktop()->isVirtualDesktop();
+    if (isVirtual || m_info.waylandDectected()) {
+        p = grabEntireDesktop(ok);
+        if (ok) {
+            QPoint topLeft(0, 0);
 #ifdef Q_OS_WIN
-      for (QScreen* const screen : QGuiApplication::screens()) {
-        QPoint topLeftScreen = screen->geometry().topLeft();
-        if (topLeft.x() > topLeftScreen.x() ||
-            topLeft.y() > topLeftScreen.y()) {
-          topLeft = topLeftScreen;
-        }
-      }
+            for (QScreen* const screen : QGuiApplication::screens()) {
+                QPoint topLeftScreen = screen->geometry().topLeft();
+                if (topLeft.x() > topLeftScreen.x() ||
+                    topLeft.y() > topLeftScreen.y()) {
+                    topLeft = topLeftScreen;
+                }
+            }
 #endif
-      QRect geometry = QApplication::desktop()->screenGeometry(screenNumber);
-      geometry.moveTo(geometry.topLeft() - topLeft);
-      p = p.copy(geometry);
+            QRect geometry =
+              QApplication::desktop()->screenGeometry(screenNumber);
+            geometry.moveTo(geometry.topLeft() - topLeft);
+            p = p.copy(geometry);
+        }
+    } else {
+        p = QApplication::desktop()->screen(screenNumber)->grab();
+        ok = true;
     }
-  } else {
-    p = QApplication::desktop()->screen(screenNumber)->grab();
-    ok = true;
-  }
-  return p;
+    return p;
 }
diff --git a/src/utils/screengrabber.h b/src/utils/screengrabber.h
index dd0f116b..b31bff1f 100644
--- a/src/utils/screengrabber.h
+++ b/src/utils/screengrabber.h
@@ -22,12 +22,12 @@
 
 class ScreenGrabber : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ScreenGrabber(QObject* parent = nullptr);
-  QPixmap grabEntireDesktop(bool& ok);
-  QPixmap grabScreen(int screenNumber, bool& ok);
+    explicit ScreenGrabber(QObject* parent = nullptr);
+    QPixmap grabEntireDesktop(bool& ok);
+    QPixmap grabScreen(int screenNumber, bool& ok);
 
 private:
-  DesktopInfo m_info;
+    DesktopInfo m_info;
 };
diff --git a/src/utils/screenshotsaver.cpp b/src/utils/screenshotsaver.cpp
index c384bd45..fd5c433d 100644
--- a/src/utils/screenshotsaver.cpp
+++ b/src/utils/screenshotsaver.cpp
@@ -29,90 +29,88 @@ ScreenshotSaver::ScreenshotSaver() {}
 
 // TODO: If data is saved to the clipboard before the notification is sent via
 // dbus, the application freezes.
-void
-ScreenshotSaver::saveToClipboard(const QPixmap& capture)
+void ScreenshotSaver::saveToClipboard(const QPixmap& capture)
 {
 
-  // If we are able to properly save the file, save the file and copy to
-  // clipboard.
-  if ((ConfigHandler().saveAfterCopyValue()) &&
-      (!ConfigHandler().saveAfterCopyPathValue().isEmpty())) {
-    saveToFilesystem(capture,
-                     ConfigHandler().saveAfterCopyPathValue(),
-                     QObject::tr("Capture saved to clipboard."));
-    QApplication::clipboard()->setPixmap(capture);
-  }
-  // Otherwise only save to clipboard
-  else {
-    SystemNotification().sendMessage(QObject::tr("Capture saved to clipboard"));
-    QApplication::clipboard()->setPixmap(capture);
-  }
+    // If we are able to properly save the file, save the file and copy to
+    // clipboard.
+    if ((ConfigHandler().saveAfterCopyValue()) &&
+        (!ConfigHandler().saveAfterCopyPathValue().isEmpty())) {
+        saveToFilesystem(capture,
+                         ConfigHandler().saveAfterCopyPathValue(),
+                         QObject::tr("Capture saved to clipboard."));
+        QApplication::clipboard()->setPixmap(capture);
+    }
+    // Otherwise only save to clipboard
+    else {
+        SystemNotification().sendMessage(
+          QObject::tr("Capture saved to clipboard"));
+        QApplication::clipboard()->setPixmap(capture);
+    }
 }
 
-bool
-ScreenshotSaver::saveToFilesystem(const QPixmap& capture,
-                                  const QString& path,
-                                  const QString& messagePrefix)
+bool ScreenshotSaver::saveToFilesystem(const QPixmap& capture,
+                                       const QString& path,
+                                       const QString& messagePrefix)
 {
-  QString completePath = FileNameHandler().generateAbsolutePath(path);
-  completePath += QLatin1String(".png");
-  bool ok = capture.save(completePath);
-  QString saveMessage;
-  QString notificationPath = completePath;
+    QString completePath = FileNameHandler().generateAbsolutePath(path);
+    completePath += QLatin1String(".png");
+    bool ok = capture.save(completePath);
+    QString saveMessage;
+    QString notificationPath = completePath;
 
-  if (ok) {
-    ConfigHandler().setSavePath(path);
-    saveMessage =
-      messagePrefix + QObject::tr("Capture saved as ") + completePath;
-  } else {
-    saveMessage =
-      messagePrefix + QObject::tr("Error trying to save as ") + completePath;
-    notificationPath = "";
-  }
+    if (ok) {
+        ConfigHandler().setSavePath(path);
+        saveMessage =
+          messagePrefix + QObject::tr("Capture saved as ") + completePath;
+    } else {
+        saveMessage = messagePrefix + QObject::tr("Error trying to save as ") +
+                      completePath;
+        notificationPath = "";
+    }
 
-  SystemNotification().sendMessage(saveMessage, notificationPath);
-  return ok;
+    SystemNotification().sendMessage(saveMessage, notificationPath);
+    return ok;
 }
 
-bool
-ScreenshotSaver::saveToFilesystemGUI(const QPixmap& capture)
+bool ScreenshotSaver::saveToFilesystemGUI(const QPixmap& capture)
 {
-  bool ok = false;
+    bool ok = false;
 
-  while (!ok) {
-    QString savePath = QFileDialog::getSaveFileName(
-      nullptr,
-      QString(),
-      FileNameHandler().absoluteSavePath() + ".png",
-      QLatin1String("Portable Network Graphic file (PNG) (*.png);;BMP file "
-                    "(*.bmp);;JPEG file (*.jpg)"));
+    while (!ok) {
+        QString savePath = QFileDialog::getSaveFileName(
+          nullptr,
+          QString(),
+          FileNameHandler().absoluteSavePath() + ".png",
+          QLatin1String("Portable Network Graphic file (PNG) (*.png);;BMP file "
+                        "(*.bmp);;JPEG file (*.jpg)"));
 
-    if (savePath.isNull()) {
-      break;
-    }
+        if (savePath.isNull()) {
+            break;
+        }
 
-    if (!savePath.endsWith(QLatin1String(".png"), Qt::CaseInsensitive) &&
-        !savePath.endsWith(QLatin1String(".bmp"), Qt::CaseInsensitive) &&
-        !savePath.endsWith(QLatin1String(".jpg"), Qt::CaseInsensitive)) {
+        if (!savePath.endsWith(QLatin1String(".png"), Qt::CaseInsensitive) &&
+            !savePath.endsWith(QLatin1String(".bmp"), Qt::CaseInsensitive) &&
+            !savePath.endsWith(QLatin1String(".jpg"), Qt::CaseInsensitive)) {
 
-      savePath += QLatin1String(".png");
-    }
+            savePath += QLatin1String(".png");
+        }
 
-    ok = capture.save(savePath);
+        ok = capture.save(savePath);
 
-    if (ok) {
-      QString pathNoFile =
-        savePath.left(savePath.lastIndexOf(QLatin1String("/")));
-      ConfigHandler().setSavePath(pathNoFile);
-      QString msg = QObject::tr("Capture saved as ") + savePath;
-      SystemNotification().sendMessage(msg, savePath);
-    } else {
-      QString msg = QObject::tr("Error trying to save as ") + savePath;
-      QMessageBox saveErrBox(
-        QMessageBox::Warning, QObject::tr("Save Error"), msg);
-      saveErrBox.setWindowIcon(QIcon(":img/app/flameshot.svg"));
-      saveErrBox.exec();
+        if (ok) {
+            QString pathNoFile =
+              savePath.left(savePath.lastIndexOf(QLatin1String("/")));
+            ConfigHandler().setSavePath(pathNoFile);
+            QString msg = QObject::tr("Capture saved as ") + savePath;
+            SystemNotification().sendMessage(msg, savePath);
+        } else {
+            QString msg = QObject::tr("Error trying to save as ") + savePath;
+            QMessageBox saveErrBox(
+              QMessageBox::Warning, QObject::tr("Save Error"), msg);
+            saveErrBox.setWindowIcon(QIcon(":img/app/flameshot.svg"));
+            saveErrBox.exec();
+        }
     }
-  }
-  return ok;
+    return ok;
 }
diff --git a/src/utils/screenshotsaver.h b/src/utils/screenshotsaver.h
index 99410e94..b528cbd7 100644
--- a/src/utils/screenshotsaver.h
+++ b/src/utils/screenshotsaver.h
@@ -23,11 +23,11 @@ class QString;
 class ScreenshotSaver
 {
 public:
-  ScreenshotSaver();
+    ScreenshotSaver();
 
-  void saveToClipboard(const QPixmap& capture);
-  bool saveToFilesystem(const QPixmap& capture,
-                        const QString& path,
-                        const QString& messagePrefix);
-  bool saveToFilesystemGUI(const QPixmap& capture);
+    void saveToClipboard(const QPixmap& capture);
+    bool saveToFilesystem(const QPixmap& capture,
+                          const QString& path,
+                          const QString& messagePrefix);
+    bool saveToFilesystemGUI(const QPixmap& capture);
 };
diff --git a/src/utils/systemnotification.cpp b/src/utils/systemnotification.cpp
index d583f438..3df103af 100644
--- a/src/utils/systemnotification.cpp
+++ b/src/utils/systemnotification.cpp
@@ -15,58 +15,57 @@
 SystemNotification::SystemNotification(QObject* parent)
   : QObject(parent)
 {
-  m_interface =
-    new QDBusInterface(QStringLiteral("org.freedesktop.Notifications"),
-                       QStringLiteral("/org/freedesktop/Notifications"),
-                       QStringLiteral("org.freedesktop.Notifications"),
-                       QDBusConnection::sessionBus(),
-                       this);
+    m_interface =
+      new QDBusInterface(QStringLiteral("org.freedesktop.Notifications"),
+                         QStringLiteral("/org/freedesktop/Notifications"),
+                         QStringLiteral("org.freedesktop.Notifications"),
+                         QDBusConnection::sessionBus(),
+                         this);
 }
 #else
 SystemNotification::SystemNotification(QObject* parent)
   : QObject(parent)
 {
-  m_interface = nullptr;
+    m_interface = nullptr;
 }
 #endif
 
-void
-SystemNotification::sendMessage(const QString& text, const QString& savePath)
+void SystemNotification::sendMessage(const QString& text,
+                                     const QString& savePath)
 {
-  sendMessage(text, tr("Flameshot Info"), savePath);
+    sendMessage(text, tr("Flameshot Info"), savePath);
 }
 
-void
-SystemNotification::sendMessage(const QString& text,
-                                const QString& title,
-                                const QString& savePath,
-                                const int timeout)
+void SystemNotification::sendMessage(const QString& text,
+                                     const QString& title,
+                                     const QString& savePath,
+                                     const int timeout)
 {
-  if (!ConfigHandler().desktopNotificationValue()) {
-    return;
-  }
+    if (!ConfigHandler().desktopNotificationValue()) {
+        return;
+    }
 
 #ifndef Q_OS_WIN
-  QList<QVariant> args;
-  QVariantMap hintsMap;
-  if (!savePath.isEmpty()) {
-    QUrl fullPath = QUrl::fromLocalFile(savePath);
-    // allows the notification to be dragged and dropped
-    hintsMap[QStringLiteral("x-kde-urls")] =
-      QStringList({ fullPath.toString() });
-  }
-  args << (qAppName())                 // appname
-       << static_cast<unsigned int>(0) // id
-       << "flameshot"                  // icon
-       << title                        // summary
-       << text                         // body
-       << QStringList()                // actions
-       << hintsMap                     // hints
-       << timeout;                     // timeout
-  m_interface->callWithArgumentList(
-    QDBus::AutoDetect, QStringLiteral("Notify"), args);
+    QList<QVariant> args;
+    QVariantMap hintsMap;
+    if (!savePath.isEmpty()) {
+        QUrl fullPath = QUrl::fromLocalFile(savePath);
+        // allows the notification to be dragged and dropped
+        hintsMap[QStringLiteral("x-kde-urls")] =
+          QStringList({ fullPath.toString() });
+    }
+    args << (qAppName())                 // appname
+         << static_cast<unsigned int>(0) // id
+         << "flameshot"                  // icon
+         << title                        // summary
+         << text                         // body
+         << QStringList()                // actions
+         << hintsMap                     // hints
+         << timeout;                     // timeout
+    m_interface->callWithArgumentList(
+      QDBus::AutoDetect, QStringLiteral("Notify"), args);
 #else
-  auto c = Controller::getInstance();
-  c->sendTrayNotification(text, title, timeout);
+    auto c = Controller::getInstance();
+    c->sendTrayNotification(text, title, timeout);
 #endif
 }
diff --git a/src/utils/systemnotification.h b/src/utils/systemnotification.h
index 171c1349..0cfb24fa 100644
--- a/src/utils/systemnotification.h
+++ b/src/utils/systemnotification.h
@@ -23,17 +23,17 @@ class QDBusInterface;
 
 class SystemNotification : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit SystemNotification(QObject* parent = nullptr);
+    explicit SystemNotification(QObject* parent = nullptr);
 
-  void sendMessage(const QString& text, const QString& savePath = {});
+    void sendMessage(const QString& text, const QString& savePath = {});
 
-  void sendMessage(const QString& text,
-                   const QString& title,
-                   const QString& savePath,
-                   const int timeout = 5000);
+    void sendMessage(const QString& text,
+                     const QString& title,
+                     const QString& savePath,
+                     const int timeout = 5000);
 
 private:
-  QDBusInterface* m_interface;
+    QDBusInterface* m_interface;
 };
diff --git a/src/utils/waylandutils.cpp b/src/utils/waylandutils.cpp
index f0932472..a46e59f2 100644
--- a/src/utils/waylandutils.cpp
+++ b/src/utils/waylandutils.cpp
@@ -2,6 +2,4 @@
 
 WaylandUtils::WaylandUtils() {}
 
-bool
-WaylandUtils::waylandDetected()
-{}
+bool WaylandUtils::waylandDetected() {}
diff --git a/src/utils/waylandutils.h b/src/utils/waylandutils.h
index f6e77658..32fe512b 100644
--- a/src/utils/waylandutils.h
+++ b/src/utils/waylandutils.h
@@ -4,9 +4,9 @@
 class WaylandUtils
 {
 public:
-  WaylandUtils();
+    WaylandUtils();
 
-  static bool waylandDetected();
+    static bool waylandDetected();
 
 private:
 };
diff --git a/src/widgets/capture/buttonhandler.cpp b/src/widgets/capture/buttonhandler.cpp
index e5ebb366..cc6b9a2c 100644
--- a/src/widgets/capture/buttonhandler.cpp
+++ b/src/widgets/capture/buttonhandler.cpp
@@ -28,386 +28,374 @@ ButtonHandler::ButtonHandler(const QVector<CaptureToolButton*>& v,
                              QObject* parent)
   : QObject(parent)
 {
-  setButtons(v);
-  init();
+    setButtons(v);
+    init();
 }
 
 ButtonHandler::ButtonHandler(QObject* parent)
   : QObject(parent)
 {
-  init();
+    init();
 }
 
-void
-ButtonHandler::hide()
+void ButtonHandler::hide()
 {
-  for (CaptureToolButton* b : m_vectorButtons)
-    b->hide();
+    for (CaptureToolButton* b : m_vectorButtons)
+        b->hide();
 }
 
-void
-ButtonHandler::show()
+void ButtonHandler::show()
 {
-  if (m_vectorButtons.isEmpty() || m_vectorButtons.first()->isVisible()) {
-    return;
-  }
-  for (CaptureToolButton* b : m_vectorButtons)
-    b->animatedShow();
+    if (m_vectorButtons.isEmpty() || m_vectorButtons.first()->isVisible()) {
+        return;
+    }
+    for (CaptureToolButton* b : m_vectorButtons)
+        b->animatedShow();
 }
 
-bool
-ButtonHandler::isVisible() const
+bool ButtonHandler::isVisible() const
 {
-  bool ret = true;
-  for (const CaptureToolButton* b : m_vectorButtons) {
-    if (!b->isVisible()) {
-      ret = false;
-      break;
+    bool ret = true;
+    for (const CaptureToolButton* b : m_vectorButtons) {
+        if (!b->isVisible()) {
+            ret = false;
+            break;
+        }
     }
-  }
-  return ret;
+    return ret;
 }
 
-bool
-ButtonHandler::buttonsAreInside() const
+bool ButtonHandler::buttonsAreInside() const
 {
-  return m_buttonsAreInside;
+    return m_buttonsAreInside;
 }
 
-size_t
-ButtonHandler::size() const
+size_t ButtonHandler::size() const
 {
-  return m_vectorButtons.size();
+    return m_vectorButtons.size();
 }
 
 // updatePosition updates the position of the buttons around the
 // selection area. Ignores the sides blocked by the end of the screen.
 // When the selection is too small it works on a virtual selection with
 // the original in the center.
-void
-ButtonHandler::updatePosition(const QRect& selection)
+void ButtonHandler::updatePosition(const QRect& selection)
 {
-  resetRegionTrack();
-  const int vecLength = m_vectorButtons.size();
-  if (vecLength == 0) {
-    return;
-  }
-  // Copy of the selection area for internal modifications
-  m_selection = intersectWithAreas(selection);
-  updateBlockedSides();
-  ensureSelectionMinimunSize();
-  // Indicates the actual button to be moved
-  int elemIndicator = 0;
-
-  while (elemIndicator < vecLength) {
-
-    // Add them inside the area when there is no more space
-    if (m_allSidesBlocked) {
-      m_selection = selection;
-      positionButtonsInside(elemIndicator);
-      break; // the while
-    }
-    // Number of buttons per row column
-    int buttonsPerRow =
-      (m_selection.width() + m_separator) / (m_buttonExtendedSize);
-    int buttonsPerCol =
-      (m_selection.height() + m_separator) / (m_buttonExtendedSize);
-    // Buttons to be placed in the corners
-    int extraButtons =
-      (vecLength - elemIndicator) - (buttonsPerRow + buttonsPerCol) * 2;
-    int elemsAtCorners = extraButtons > 4 ? 4 : extraButtons;
-    int maxExtra = 2;
-    if (m_oneHorizontalBlocked) {
-      maxExtra = 1;
-    } else if (m_horizontalyBlocked) {
-      maxExtra = 0;
-    }
-    int elemCornersTop = qBound(0, elemsAtCorners, maxExtra);
-    elemsAtCorners -= elemCornersTop;
-    int elemCornersBotton = qBound(0, elemsAtCorners, maxExtra);
-
-    // Add buttons at the button of the seletion
-    if (!m_blockedBotton) {
-      int addCounter = buttonsPerRow + elemCornersBotton;
-      // Don't add more than we have
-      addCounter = qBound(0, addCounter, vecLength - elemIndicator);
-      QPoint center =
-        QPoint(m_selection.center().x(), m_selection.bottom() + m_separator);
-      if (addCounter > buttonsPerRow) {
-        adjustHorizontalCenter(center);
-      }
-      // ElemIndicator, elemsAtCorners
-      QVector<QPoint> positions = horizontalPoints(center, addCounter, true);
-      moveButtonsToPoints(positions, elemIndicator);
-    }
-    // Add buttons at the right side of the seletion
-    if (!m_blockedRight && elemIndicator < vecLength) {
-      int addCounter = buttonsPerCol;
-      addCounter = qBound(0, addCounter, vecLength - elemIndicator);
-
-      QPoint center =
-        QPoint(m_selection.right() + m_separator, m_selection.center().y());
-      QVector<QPoint> positions = verticalPoints(center, addCounter, false);
-      moveButtonsToPoints(positions, elemIndicator);
-    }
-    // Add buttons at the top of the seletion
-    if (!m_blockedTop && elemIndicator < vecLength) {
-      int addCounter = buttonsPerRow + elemCornersTop;
-      addCounter = qBound(0, addCounter, vecLength - elemIndicator);
-      QPoint center = QPoint(m_selection.center().x(),
-                             m_selection.top() - m_buttonExtendedSize);
-      if (addCounter == 1 + buttonsPerRow) {
-        adjustHorizontalCenter(center);
-      }
-      QVector<QPoint> positions = horizontalPoints(center, addCounter, false);
-      moveButtonsToPoints(positions, elemIndicator);
-    }
-    // Add buttons at the left side of the seletion
-    if (!m_blockedLeft && elemIndicator < vecLength) {
-      int addCounter = buttonsPerCol;
-      addCounter = qBound(0, addCounter, vecLength - elemIndicator);
-
-      QPoint center = QPoint(m_selection.left() - m_buttonExtendedSize,
-                             m_selection.center().y());
-      QVector<QPoint> positions = verticalPoints(center, addCounter, true);
-      moveButtonsToPoints(positions, elemIndicator);
-    }
-    // If there are elements for the next cycle, increase the size of the
-    // base area
-    if (elemIndicator < vecLength && !(m_allSidesBlocked)) {
-      expandSelection();
+    resetRegionTrack();
+    const int vecLength = m_vectorButtons.size();
+    if (vecLength == 0) {
+        return;
     }
+    // Copy of the selection area for internal modifications
+    m_selection = intersectWithAreas(selection);
     updateBlockedSides();
-  }
+    ensureSelectionMinimunSize();
+    // Indicates the actual button to be moved
+    int elemIndicator = 0;
+
+    while (elemIndicator < vecLength) {
+
+        // Add them inside the area when there is no more space
+        if (m_allSidesBlocked) {
+            m_selection = selection;
+            positionButtonsInside(elemIndicator);
+            break; // the while
+        }
+        // Number of buttons per row column
+        int buttonsPerRow =
+          (m_selection.width() + m_separator) / (m_buttonExtendedSize);
+        int buttonsPerCol =
+          (m_selection.height() + m_separator) / (m_buttonExtendedSize);
+        // Buttons to be placed in the corners
+        int extraButtons =
+          (vecLength - elemIndicator) - (buttonsPerRow + buttonsPerCol) * 2;
+        int elemsAtCorners = extraButtons > 4 ? 4 : extraButtons;
+        int maxExtra = 2;
+        if (m_oneHorizontalBlocked) {
+            maxExtra = 1;
+        } else if (m_horizontalyBlocked) {
+            maxExtra = 0;
+        }
+        int elemCornersTop = qBound(0, elemsAtCorners, maxExtra);
+        elemsAtCorners -= elemCornersTop;
+        int elemCornersBotton = qBound(0, elemsAtCorners, maxExtra);
+
+        // Add buttons at the button of the seletion
+        if (!m_blockedBotton) {
+            int addCounter = buttonsPerRow + elemCornersBotton;
+            // Don't add more than we have
+            addCounter = qBound(0, addCounter, vecLength - elemIndicator);
+            QPoint center = QPoint(m_selection.center().x(),
+                                   m_selection.bottom() + m_separator);
+            if (addCounter > buttonsPerRow) {
+                adjustHorizontalCenter(center);
+            }
+            // ElemIndicator, elemsAtCorners
+            QVector<QPoint> positions =
+              horizontalPoints(center, addCounter, true);
+            moveButtonsToPoints(positions, elemIndicator);
+        }
+        // Add buttons at the right side of the seletion
+        if (!m_blockedRight && elemIndicator < vecLength) {
+            int addCounter = buttonsPerCol;
+            addCounter = qBound(0, addCounter, vecLength - elemIndicator);
+
+            QPoint center = QPoint(m_selection.right() + m_separator,
+                                   m_selection.center().y());
+            QVector<QPoint> positions =
+              verticalPoints(center, addCounter, false);
+            moveButtonsToPoints(positions, elemIndicator);
+        }
+        // Add buttons at the top of the seletion
+        if (!m_blockedTop && elemIndicator < vecLength) {
+            int addCounter = buttonsPerRow + elemCornersTop;
+            addCounter = qBound(0, addCounter, vecLength - elemIndicator);
+            QPoint center = QPoint(m_selection.center().x(),
+                                   m_selection.top() - m_buttonExtendedSize);
+            if (addCounter == 1 + buttonsPerRow) {
+                adjustHorizontalCenter(center);
+            }
+            QVector<QPoint> positions =
+              horizontalPoints(center, addCounter, false);
+            moveButtonsToPoints(positions, elemIndicator);
+        }
+        // Add buttons at the left side of the seletion
+        if (!m_blockedLeft && elemIndicator < vecLength) {
+            int addCounter = buttonsPerCol;
+            addCounter = qBound(0, addCounter, vecLength - elemIndicator);
+
+            QPoint center = QPoint(m_selection.left() - m_buttonExtendedSize,
+                                   m_selection.center().y());
+            QVector<QPoint> positions =
+              verticalPoints(center, addCounter, true);
+            moveButtonsToPoints(positions, elemIndicator);
+        }
+        // If there are elements for the next cycle, increase the size of the
+        // base area
+        if (elemIndicator < vecLength && !(m_allSidesBlocked)) {
+            expandSelection();
+        }
+        updateBlockedSides();
+    }
 }
 
 // horizontalPoints is an auxiliary method for the button position computation.
 // starts from a known center and keeps adding elements horizontally
 // and returns the computed positions.
-QVector<QPoint>
-ButtonHandler::horizontalPoints(const QPoint& center,
-                                const int elements,
-                                const bool leftToRight) const
+QVector<QPoint> ButtonHandler::horizontalPoints(const QPoint& center,
+                                                const int elements,
+                                                const bool leftToRight) const
 {
-  QVector<QPoint> res;
-  // Distance from the center to start adding buttons
-  int shift = 0;
-  if (elements % 2 == 0) {
-    shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2);
-  } else {
-    shift = m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2;
-  }
-  if (!leftToRight) {
-    shift -= m_buttonBaseSize;
-  }
-  int x = leftToRight ? center.x() - shift : center.x() + shift;
-  QPoint i(x, center.y());
-  while (elements > res.length()) {
-    res.append(i);
-    leftToRight ? i.setX(i.x() + m_buttonExtendedSize)
-                : i.setX(i.x() - m_buttonExtendedSize);
-  }
-  return res;
+    QVector<QPoint> res;
+    // Distance from the center to start adding buttons
+    int shift = 0;
+    if (elements % 2 == 0) {
+        shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2);
+    } else {
+        shift =
+          m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2;
+    }
+    if (!leftToRight) {
+        shift -= m_buttonBaseSize;
+    }
+    int x = leftToRight ? center.x() - shift : center.x() + shift;
+    QPoint i(x, center.y());
+    while (elements > res.length()) {
+        res.append(i);
+        leftToRight ? i.setX(i.x() + m_buttonExtendedSize)
+                    : i.setX(i.x() - m_buttonExtendedSize);
+    }
+    return res;
 }
 
 // verticalPoints is an auxiliary method for the button position computation.
 // starts from a known center and keeps adding elements vertically
 // and returns the computed positions.
-QVector<QPoint>
-ButtonHandler::verticalPoints(const QPoint& center,
-                              const int elements,
-                              const bool upToDown) const
+QVector<QPoint> ButtonHandler::verticalPoints(const QPoint& center,
+                                              const int elements,
+                                              const bool upToDown) const
 {
-  QVector<QPoint> res;
-  // Distance from the center to start adding buttons
-  int shift = 0;
-  if (elements % 2 == 0) {
-    shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2);
-  } else {
-    shift = m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2;
-  }
-  if (!upToDown) {
-    shift -= m_buttonBaseSize;
-  }
-  int y = upToDown ? center.y() - shift : center.y() + shift;
-  QPoint i(center.x(), y);
-  while (elements > res.length()) {
-    res.append(i);
-    upToDown ? i.setY(i.y() + m_buttonExtendedSize)
-             : i.setY(i.y() - m_buttonExtendedSize);
-  }
-  return res;
+    QVector<QPoint> res;
+    // Distance from the center to start adding buttons
+    int shift = 0;
+    if (elements % 2 == 0) {
+        shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2);
+    } else {
+        shift =
+          m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2;
+    }
+    if (!upToDown) {
+        shift -= m_buttonBaseSize;
+    }
+    int y = upToDown ? center.y() - shift : center.y() + shift;
+    QPoint i(center.x(), y);
+    while (elements > res.length()) {
+        res.append(i);
+        upToDown ? i.setY(i.y() + m_buttonExtendedSize)
+                 : i.setY(i.y() - m_buttonExtendedSize);
+    }
+    return res;
 }
 
-QRect
-ButtonHandler::intersectWithAreas(const QRect& rect)
+QRect ButtonHandler::intersectWithAreas(const QRect& rect)
 {
-  QRect res;
-  for (const QRect& r : m_screenRegions) {
-    QRect temp = rect.intersected(r);
-    if (temp.height() * temp.width() > res.height() * res.width()) {
-      res = temp;
+    QRect res;
+    for (const QRect& r : m_screenRegions) {
+        QRect temp = rect.intersected(r);
+        if (temp.height() * temp.width() > res.height() * res.width()) {
+            res = temp;
+        }
     }
-  }
-  return res;
+    return res;
 }
 
-void
-ButtonHandler::init()
+void ButtonHandler::init()
 {
-  m_separator = GlobalValues::buttonBaseSize() / 4;
+    m_separator = GlobalValues::buttonBaseSize() / 4;
 }
 
-void
-ButtonHandler::resetRegionTrack()
+void ButtonHandler::resetRegionTrack()
 {
-  m_buttonsAreInside = false;
+    m_buttonsAreInside = false;
 }
 
-void
-ButtonHandler::updateBlockedSides()
+void ButtonHandler::updateBlockedSides()
 {
-  const int EXTENSION = m_separator * 2 + m_buttonBaseSize;
-  // Right
-  QPoint pointA(m_selection.right() + EXTENSION, m_selection.bottom());
-  QPoint pointB(pointA.x(), m_selection.top());
-  m_blockedRight =
-    !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
-  // Left
-  pointA.setX(m_selection.left() - EXTENSION);
-  pointB.setX(pointA.x());
-  m_blockedLeft =
-    !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
-  // Bottom
-  pointA = QPoint(m_selection.left(), m_selection.bottom() + EXTENSION);
-  pointB = QPoint(m_selection.right(), pointA.y());
-  m_blockedBotton =
-    !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
-  // Top
-  pointA.setY(m_selection.top() - EXTENSION);
-  pointB.setY(pointA.y());
-  m_blockedTop =
-    !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
-  // Auxiliary
-  m_oneHorizontalBlocked =
-    (!m_blockedRight && m_blockedLeft) || (m_blockedRight && !m_blockedLeft);
-  m_horizontalyBlocked = (m_blockedRight && m_blockedLeft);
-  m_allSidesBlocked = (m_blockedBotton && m_horizontalyBlocked && m_blockedTop);
+    const int EXTENSION = m_separator * 2 + m_buttonBaseSize;
+    // Right
+    QPoint pointA(m_selection.right() + EXTENSION, m_selection.bottom());
+    QPoint pointB(pointA.x(), m_selection.top());
+    m_blockedRight =
+      !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
+    // Left
+    pointA.setX(m_selection.left() - EXTENSION);
+    pointB.setX(pointA.x());
+    m_blockedLeft =
+      !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
+    // Bottom
+    pointA = QPoint(m_selection.left(), m_selection.bottom() + EXTENSION);
+    pointB = QPoint(m_selection.right(), pointA.y());
+    m_blockedBotton =
+      !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
+    // Top
+    pointA.setY(m_selection.top() - EXTENSION);
+    pointB.setY(pointA.y());
+    m_blockedTop =
+      !(m_screenRegions.contains(pointA) && m_screenRegions.contains(pointB));
+    // Auxiliary
+    m_oneHorizontalBlocked =
+      (!m_blockedRight && m_blockedLeft) || (m_blockedRight && !m_blockedLeft);
+    m_horizontalyBlocked = (m_blockedRight && m_blockedLeft);
+    m_allSidesBlocked =
+      (m_blockedBotton && m_horizontalyBlocked && m_blockedTop);
 }
 
-void
-ButtonHandler::expandSelection()
+void ButtonHandler::expandSelection()
 {
-  int& s = m_buttonExtendedSize;
-  m_selection = m_selection + QMargins(s, s, s, s);
-  m_selection = intersectWithAreas(m_selection);
+    int& s = m_buttonExtendedSize;
+    m_selection = m_selection + QMargins(s, s, s, s);
+    m_selection = intersectWithAreas(m_selection);
 }
 
-void
-ButtonHandler::positionButtonsInside(int index)
+void ButtonHandler::positionButtonsInside(int index)
 {
-  // Position the buttons in the botton-center of the main but inside of the
-  // selection.
-  QRect mainArea = m_selection;
-  mainArea = intersectWithAreas(mainArea);
-  const int buttonsPerRow = (mainArea.width()) / (m_buttonExtendedSize);
-  if (buttonsPerRow == 0) {
-    return;
-  }
-  QPoint center =
-    QPoint(mainArea.center().x(), mainArea.bottom() - m_buttonExtendedSize);
-
-  while (m_vectorButtons.size() > index) {
-    int addCounter = buttonsPerRow;
-    addCounter = qBound(0, addCounter, m_vectorButtons.size() - index);
-    QVector<QPoint> positions = horizontalPoints(center, addCounter, true);
-    moveButtonsToPoints(positions, index);
-    center.setY(center.y() - m_buttonExtendedSize);
-  }
-
-  m_buttonsAreInside = true;
+    // Position the buttons in the botton-center of the main but inside of the
+    // selection.
+    QRect mainArea = m_selection;
+    mainArea = intersectWithAreas(mainArea);
+    const int buttonsPerRow = (mainArea.width()) / (m_buttonExtendedSize);
+    if (buttonsPerRow == 0) {
+        return;
+    }
+    QPoint center =
+      QPoint(mainArea.center().x(), mainArea.bottom() - m_buttonExtendedSize);
+
+    while (m_vectorButtons.size() > index) {
+        int addCounter = buttonsPerRow;
+        addCounter = qBound(0, addCounter, m_vectorButtons.size() - index);
+        QVector<QPoint> positions = horizontalPoints(center, addCounter, true);
+        moveButtonsToPoints(positions, index);
+        center.setY(center.y() - m_buttonExtendedSize);
+    }
+
+    m_buttonsAreInside = true;
 }
 
-void
-ButtonHandler::ensureSelectionMinimunSize()
+void ButtonHandler::ensureSelectionMinimunSize()
 {
-  // Detect if a side is smaller than a button in order to prevent collision
-  // and redimension the base area the the base size of a single button per side
-  if (m_selection.width() < m_buttonBaseSize) {
-    if (!m_blockedLeft) {
-      m_selection.setX(m_selection.x() -
-                       (m_buttonBaseSize - m_selection.width()) / 2);
+    // Detect if a side is smaller than a button in order to prevent collision
+    // and redimension the base area the the base size of a single button per
+    // side
+    if (m_selection.width() < m_buttonBaseSize) {
+        if (!m_blockedLeft) {
+            m_selection.setX(m_selection.x() -
+                             (m_buttonBaseSize - m_selection.width()) / 2);
+        }
+        m_selection.setWidth(m_buttonBaseSize);
     }
-    m_selection.setWidth(m_buttonBaseSize);
-  }
-  if (m_selection.height() < m_buttonBaseSize) {
-    if (!m_blockedTop) {
-      m_selection.setY(m_selection.y() -
-                       (m_buttonBaseSize - m_selection.height()) / 2);
+    if (m_selection.height() < m_buttonBaseSize) {
+        if (!m_blockedTop) {
+            m_selection.setY(m_selection.y() -
+                             (m_buttonBaseSize - m_selection.height()) / 2);
+        }
+        m_selection.setHeight(m_buttonBaseSize);
     }
-    m_selection.setHeight(m_buttonBaseSize);
-  }
 }
 
-void
-ButtonHandler::moveButtonsToPoints(const QVector<QPoint>& points, int& index)
+void ButtonHandler::moveButtonsToPoints(const QVector<QPoint>& points,
+                                        int& index)
 {
-  for (const QPoint& p : points) {
-    auto button = m_vectorButtons[index];
-    button->move(p);
-    ++index;
-  }
+    for (const QPoint& p : points) {
+        auto button = m_vectorButtons[index];
+        button->move(p);
+        ++index;
+    }
 }
 
-void
-ButtonHandler::adjustHorizontalCenter(QPoint& center)
+void ButtonHandler::adjustHorizontalCenter(QPoint& center)
 {
-  if (m_blockedLeft) {
-    center.setX(center.x() + m_buttonExtendedSize / 2);
-  } else if (m_blockedRight) {
-    center.setX(center.x() - m_buttonExtendedSize / 2);
-  }
+    if (m_blockedLeft) {
+        center.setX(center.x() + m_buttonExtendedSize / 2);
+    } else if (m_blockedRight) {
+        center.setX(center.x() - m_buttonExtendedSize / 2);
+    }
 }
 
 // setButtons redefines the buttons of the button handler
-void
-ButtonHandler::setButtons(const QVector<CaptureToolButton*> v)
+void ButtonHandler::setButtons(const QVector<CaptureToolButton*> v)
 {
-  if (v.isEmpty())
-    return;
-
-  for (CaptureToolButton* b : m_vectorButtons)
-    delete (b);
-  m_vectorButtons = v;
-  m_buttonBaseSize = GlobalValues::buttonBaseSize();
-  m_buttonExtendedSize = m_buttonBaseSize + m_separator;
+    if (v.isEmpty())
+        return;
+
+    for (CaptureToolButton* b : m_vectorButtons)
+        delete (b);
+    m_vectorButtons = v;
+    m_buttonBaseSize = GlobalValues::buttonBaseSize();
+    m_buttonExtendedSize = m_buttonBaseSize + m_separator;
 }
 
-bool
-ButtonHandler::contains(const QPoint& p) const
+bool ButtonHandler::contains(const QPoint& p) const
 {
-  QPoint first(m_vectorButtons.first()->pos());
-  QPoint last(m_vectorButtons.last()->pos());
-  bool firstIsTopLeft = (first.x() <= last.x() && first.y() <= last.y());
-  QPoint topLeft = firstIsTopLeft ? first : last;
-  QPoint bottonRight = firstIsTopLeft ? last : first;
-  topLeft += QPoint(-m_separator, -m_separator);
-  bottonRight += QPoint(m_buttonExtendedSize, m_buttonExtendedSize);
-  QRegion r(QRect(topLeft, bottonRight).normalized());
-  return r.contains(p);
+    QPoint first(m_vectorButtons.first()->pos());
+    QPoint last(m_vectorButtons.last()->pos());
+    bool firstIsTopLeft = (first.x() <= last.x() && first.y() <= last.y());
+    QPoint topLeft = firstIsTopLeft ? first : last;
+    QPoint bottonRight = firstIsTopLeft ? last : first;
+    topLeft += QPoint(-m_separator, -m_separator);
+    bottonRight += QPoint(m_buttonExtendedSize, m_buttonExtendedSize);
+    QRegion r(QRect(topLeft, bottonRight).normalized());
+    return r.contains(p);
 }
 
-void
-ButtonHandler::updateScreenRegions(const QVector<QRect>& rects)
+void ButtonHandler::updateScreenRegions(const QVector<QRect>& rects)
 {
-  m_screenRegions = QRegion();
-  for (const QRect& rect : rects) {
-    m_screenRegions += rect;
-  }
+    m_screenRegions = QRegion();
+    for (const QRect& rect : rects) {
+        m_screenRegions += rect;
+    }
 }
 
-void
-ButtonHandler::updateScreenRegions(const QRect& rect)
+void ButtonHandler::updateScreenRegions(const QRect& rect)
 {
-  m_screenRegions = QRegion(rect);
+    m_screenRegions = QRegion(rect);
 }
diff --git a/src/widgets/capture/buttonhandler.h b/src/widgets/capture/buttonhandler.h
index be40b9b4..ec76edd4 100644
--- a/src/widgets/capture/buttonhandler.h
+++ b/src/widgets/capture/buttonhandler.h
@@ -28,63 +28,64 @@ class QPoint;
 
 class ButtonHandler : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  ButtonHandler(const QVector<CaptureToolButton*>&, QObject* parent = nullptr);
-  explicit ButtonHandler(QObject* parent = nullptr);
+    ButtonHandler(const QVector<CaptureToolButton*>&,
+                  QObject* parent = nullptr);
+    explicit ButtonHandler(QObject* parent = nullptr);
 
-  void hideSectionUnderMouse(const QPoint& p);
+    void hideSectionUnderMouse(const QPoint& p);
 
-  bool isVisible() const;
-  bool buttonsAreInside() const;
-  size_t size() const;
+    bool isVisible() const;
+    bool buttonsAreInside() const;
+    size_t size() const;
 
-  void setButtons(const QVector<CaptureToolButton*>);
-  bool contains(const QPoint& p) const;
-  void updateScreenRegions(const QVector<QRect>& rects);
-  void updateScreenRegions(const QRect& rect);
+    void setButtons(const QVector<CaptureToolButton*>);
+    bool contains(const QPoint& p) const;
+    void updateScreenRegions(const QVector<QRect>& rects);
+    void updateScreenRegions(const QRect& rect);
 
 public slots:
-  void updatePosition(const QRect& selection);
-  void hide();
-  void show();
+    void updatePosition(const QRect& selection);
+    void hide();
+    void show();
 
 private:
-  QVector<QPoint> horizontalPoints(const QPoint& center,
+    QVector<QPoint> horizontalPoints(const QPoint& center,
+                                     const int elements,
+                                     const bool leftToRight) const;
+    QVector<QPoint> verticalPoints(const QPoint& center,
                                    const int elements,
-                                   const bool leftToRight) const;
-  QVector<QPoint> verticalPoints(const QPoint& center,
-                                 const int elements,
-                                 const bool upToDown) const;
-
-  QRect intersectWithAreas(const QRect& rect);
-
-  QVector<CaptureToolButton*> m_vectorButtons;
-
-  QRegion m_screenRegions;
-
-  QRect m_selection;
-
-  int m_separator;
-  int m_buttonExtendedSize;
-  int m_buttonBaseSize;
-
-  bool m_buttonsAreInside;
-  bool m_blockedRight;
-  bool m_blockedLeft;
-  bool m_blockedBotton;
-  bool m_blockedTop;
-  bool m_oneHorizontalBlocked;
-  bool m_horizontalyBlocked;
-  bool m_allSidesBlocked;
-
-  // aux methods
-  void init();
-  void resetRegionTrack();
-  void updateBlockedSides();
-  void expandSelection();
-  void positionButtonsInside(int index);
-  void ensureSelectionMinimunSize();
-  void moveButtonsToPoints(const QVector<QPoint>& points, int& index);
-  void adjustHorizontalCenter(QPoint& center);
+                                   const bool upToDown) const;
+
+    QRect intersectWithAreas(const QRect& rect);
+
+    QVector<CaptureToolButton*> m_vectorButtons;
+
+    QRegion m_screenRegions;
+
+    QRect m_selection;
+
+    int m_separator;
+    int m_buttonExtendedSize;
+    int m_buttonBaseSize;
+
+    bool m_buttonsAreInside;
+    bool m_blockedRight;
+    bool m_blockedLeft;
+    bool m_blockedBotton;
+    bool m_blockedTop;
+    bool m_oneHorizontalBlocked;
+    bool m_horizontalyBlocked;
+    bool m_allSidesBlocked;
+
+    // aux methods
+    void init();
+    void resetRegionTrack();
+    void updateBlockedSides();
+    void expandSelection();
+    void positionButtonsInside(int index);
+    void ensureSelectionMinimunSize();
+    void moveButtonsToPoints(const QVector<QPoint>& points, int& index);
+    void adjustHorizontalCenter(QPoint& center);
 };
diff --git a/src/widgets/capture/capturebutton.cpp b/src/widgets/capture/capturebutton.cpp
index f6d9b6f0..d49b49da 100644
--- a/src/widgets/capture/capturebutton.cpp
+++ b/src/widgets/capture/capturebutton.cpp
@@ -24,13 +24,13 @@
 CaptureButton::CaptureButton(QWidget* parent)
   : QPushButton(parent)
 {
-  init();
+    init();
 }
 
 CaptureButton::CaptureButton(const QString& text, QWidget* parent)
   : QPushButton(text, parent)
 {
-  init();
+    init();
 }
 
 CaptureButton::CaptureButton(const QIcon& icon,
@@ -38,56 +38,52 @@ CaptureButton::CaptureButton(const QIcon& icon,
                              QWidget* parent)
   : QPushButton(icon, text, parent)
 {
-  init();
+    init();
 }
 
-void
-CaptureButton::init()
+void CaptureButton::init()
 {
-  setCursor(Qt::ArrowCursor);
-  setFocusPolicy(Qt::NoFocus);
+    setCursor(Qt::ArrowCursor);
+    setFocusPolicy(Qt::NoFocus);
 
-  auto dsEffect = new QGraphicsDropShadowEffect(this);
-  dsEffect->setBlurRadius(5);
-  dsEffect->setOffset(0);
-  dsEffect->setColor(QColor(Qt::black));
+    auto dsEffect = new QGraphicsDropShadowEffect(this);
+    dsEffect->setBlurRadius(5);
+    dsEffect->setOffset(0);
+    dsEffect->setColor(QColor(Qt::black));
 
-  setGraphicsEffect(dsEffect);
+    setGraphicsEffect(dsEffect);
 }
 
-QString
-CaptureButton::globalStyleSheet()
+QString CaptureButton::globalStyleSheet()
 {
-  return CaptureButton(nullptr).styleSheet();
+    return CaptureButton(nullptr).styleSheet();
 }
 
-QString
-CaptureButton::styleSheet() const
+QString CaptureButton::styleSheet() const
 {
-  QString baseSheet = "CaptureButton { border: none;"
-                      "padding: 3px 8px;"
-                      "background-color: %1; color: %4 }"
-                      "CaptureToolButton { border-radius: %3;"
-                      "padding: 0; }"
-                      "CaptureButton:hover { background-color: %2; }"
-                      "CaptureButton:pressed:!hover { "
-                      "background-color: %1; }";
-  // define color when mouse is hovering
-  QColor contrast = ColorUtils::contrastColor(m_mainColor);
-  // foreground color
-  QColor color = ColorUtils::colorIsDark(m_mainColor) ? Qt::white : Qt::black;
+    QString baseSheet = "CaptureButton { border: none;"
+                        "padding: 3px 8px;"
+                        "background-color: %1; color: %4 }"
+                        "CaptureToolButton { border-radius: %3;"
+                        "padding: 0; }"
+                        "CaptureButton:hover { background-color: %2; }"
+                        "CaptureButton:pressed:!hover { "
+                        "background-color: %1; }";
+    // define color when mouse is hovering
+    QColor contrast = ColorUtils::contrastColor(m_mainColor);
+    // foreground color
+    QColor color = ColorUtils::colorIsDark(m_mainColor) ? Qt::white : Qt::black;
 
-  return baseSheet.arg(m_mainColor.name())
-    .arg(contrast.name())
-    .arg(GlobalValues::buttonBaseSize() / 2)
-    .arg(color.name());
+    return baseSheet.arg(m_mainColor.name())
+      .arg(contrast.name())
+      .arg(GlobalValues::buttonBaseSize() / 2)
+      .arg(color.name());
 }
 
-void
-CaptureButton::setColor(const QColor& c)
+void CaptureButton::setColor(const QColor& c)
 {
-  m_mainColor = c;
-  setStyleSheet(styleSheet());
+    m_mainColor = c;
+    setStyleSheet(styleSheet());
 }
 
 QColor CaptureButton::m_mainColor = ConfigHandler().uiMainColorValue();
diff --git a/src/widgets/capture/capturebutton.h b/src/widgets/capture/capturebutton.h
index b5496176..dc4991d4 100644
--- a/src/widgets/capture/capturebutton.h
+++ b/src/widgets/capture/capturebutton.h
@@ -21,24 +21,24 @@
 
 class CaptureButton : public QPushButton
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  CaptureButton() = delete;
-  CaptureButton(QWidget* parent = nullptr);
-  CaptureButton(const QString& text, QWidget* parent = nullptr);
-  CaptureButton(const QIcon& icon,
-                const QString& text,
-                QWidget* parent = nullptr);
+    CaptureButton() = delete;
+    CaptureButton(QWidget* parent = nullptr);
+    CaptureButton(const QString& text, QWidget* parent = nullptr);
+    CaptureButton(const QIcon& icon,
+                  const QString& text,
+                  QWidget* parent = nullptr);
 
-  static QString globalStyleSheet();
+    static QString globalStyleSheet();
 
-  QString styleSheet() const;
+    QString styleSheet() const;
 
-  void setColor(const QColor& c);
+    void setColor(const QColor& c);
 
 private:
-  static QColor m_mainColor;
+    static QColor m_mainColor;
 
-  void init();
+    void init();
 };
diff --git a/src/widgets/capture/capturetoolbutton.cpp b/src/widgets/capture/capturetoolbutton.cpp
index 71959933..a102cc16 100644
--- a/src/widgets/capture/capturetoolbutton.cpp
+++ b/src/widgets/capture/capturetoolbutton.cpp
@@ -35,142 +35,135 @@ CaptureToolButton::CaptureToolButton(const ButtonType t, QWidget* parent)
   : CaptureButton(parent)
   , m_buttonType(t)
 {
-  initButton();
-  if (t == TYPE_SELECTIONINDICATOR) {
-    QFont f = this->font();
-    setFont(QFont(f.family(), 7, QFont::Bold));
-  } else {
-    updateIcon();
-  }
+    initButton();
+    if (t == TYPE_SELECTIONINDICATOR) {
+        QFont f = this->font();
+        setFont(QFont(f.family(), 7, QFont::Bold));
+    } else {
+        updateIcon();
+    }
 }
 
-void
-CaptureToolButton::initButton()
+void CaptureToolButton::initButton()
 {
-  m_tool = ToolFactory().CreateTool(m_buttonType, this);
-
-  resize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize());
-  setMask(QRegion(QRect(-1,
-                        -1,
-                        GlobalValues::buttonBaseSize() + 2,
-                        GlobalValues::buttonBaseSize() + 2),
-                  QRegion::Ellipse));
-
-  setToolTip(m_tool->description());
-
-  m_emergeAnimation = new QPropertyAnimation(this, "size", this);
-  m_emergeAnimation->setEasingCurve(QEasingCurve::InOutQuad);
-  m_emergeAnimation->setDuration(80);
-  m_emergeAnimation->setStartValue(QSize(0, 0));
-  m_emergeAnimation->setEndValue(
-    QSize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize()));
+    m_tool = ToolFactory().CreateTool(m_buttonType, this);
+
+    resize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize());
+    setMask(QRegion(QRect(-1,
+                          -1,
+                          GlobalValues::buttonBaseSize() + 2,
+                          GlobalValues::buttonBaseSize() + 2),
+                    QRegion::Ellipse));
+
+    setToolTip(m_tool->description());
+
+    m_emergeAnimation = new QPropertyAnimation(this, "size", this);
+    m_emergeAnimation->setEasingCurve(QEasingCurve::InOutQuad);
+    m_emergeAnimation->setDuration(80);
+    m_emergeAnimation->setStartValue(QSize(0, 0));
+    m_emergeAnimation->setEndValue(
+      QSize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize()));
 }
 
-void
-CaptureToolButton::updateIcon()
+void CaptureToolButton::updateIcon()
 {
-  setIcon(icon());
-  setIconSize(size() * 0.6);
+    setIcon(icon());
+    setIconSize(size() * 0.6);
 }
 
 QVector<CaptureToolButton::ButtonType>
 CaptureToolButton::getIterableButtonTypes()
 {
-  return iterableButtonTypes;
+    return iterableButtonTypes;
 }
 
 // get icon returns the icon for the type of button
-QIcon
-CaptureToolButton::icon() const
+QIcon CaptureToolButton::icon() const
 {
-  return m_tool->icon(m_mainColor, true);
+    return m_tool->icon(m_mainColor, true);
 }
 
-void
-CaptureToolButton::mousePressEvent(QMouseEvent* e)
+void CaptureToolButton::mousePressEvent(QMouseEvent* e)
 {
-  if (e->button() == Qt::LeftButton) {
-    emit pressedButton(this);
-    emit pressed();
-  }
+    if (e->button() == Qt::LeftButton) {
+        emit pressedButton(this);
+        emit pressed();
+    }
 }
 
-void
-CaptureToolButton::animatedShow()
+void CaptureToolButton::animatedShow()
 {
-  if (!isVisible()) {
-    show();
-    m_emergeAnimation->start();
-    connect(m_emergeAnimation, &QPropertyAnimation::finished, this, []() {});
-  }
+    if (!isVisible()) {
+        show();
+        m_emergeAnimation->start();
+        connect(
+          m_emergeAnimation, &QPropertyAnimation::finished, this, []() {});
+    }
 }
 
-CaptureTool*
-CaptureToolButton::tool() const
+CaptureTool* CaptureToolButton::tool() const
 {
-  return m_tool;
+    return m_tool;
 }
 
-void
-CaptureToolButton::setColor(const QColor& c)
+void CaptureToolButton::setColor(const QColor& c)
 {
-  CaptureButton::setColor(c);
-  updateIcon();
+    CaptureButton::setColor(c);
+    updateIcon();
 }
 
 QColor CaptureToolButton::m_mainColor = ConfigHandler().uiMainColorValue();
 
 static std::map<CaptureToolButton::ButtonType, int> buttonTypeOrder{
-  { CaptureToolButton::TYPE_PENCIL, 0 },
-  { CaptureToolButton::TYPE_DRAWER, 1 },
-  { CaptureToolButton::TYPE_ARROW, 2 },
-  { CaptureToolButton::TYPE_SELECTION, 3 },
-  { CaptureToolButton::TYPE_RECTANGLE, 4 },
-  { CaptureToolButton::TYPE_CIRCLE, 5 },
-  { CaptureToolButton::TYPE_MARKER, 6 },
-  { CaptureToolButton::TYPE_TEXT, 7 },
-  { CaptureToolButton::TYPE_PIXELATE, 8 },
-  { CaptureToolButton::TYPE_CIRCLECOUNT, 9 },
-  { CaptureToolButton::TYPE_SELECTIONINDICATOR, 10 },
-  { CaptureToolButton::TYPE_MOVESELECTION, 11 },
-  { CaptureToolButton::TYPE_UNDO, 12 },
-  { CaptureToolButton::TYPE_REDO, 13 },
-  { CaptureToolButton::TYPE_COPY, 14 },
-  { CaptureToolButton::TYPE_SAVE, 15 },
-  { CaptureToolButton::TYPE_EXIT, 16 },
-  { CaptureToolButton::TYPE_IMAGEUPLOADER, 17 },
-  { CaptureToolButton::TYPE_OPEN_APP, 18 },
-  { CaptureToolButton::TYPE_PIN, 19 },
+    { CaptureToolButton::TYPE_PENCIL, 0 },
+    { CaptureToolButton::TYPE_DRAWER, 1 },
+    { CaptureToolButton::TYPE_ARROW, 2 },
+    { CaptureToolButton::TYPE_SELECTION, 3 },
+    { CaptureToolButton::TYPE_RECTANGLE, 4 },
+    { CaptureToolButton::TYPE_CIRCLE, 5 },
+    { CaptureToolButton::TYPE_MARKER, 6 },
+    { CaptureToolButton::TYPE_TEXT, 7 },
+    { CaptureToolButton::TYPE_PIXELATE, 8 },
+    { CaptureToolButton::TYPE_CIRCLECOUNT, 9 },
+    { CaptureToolButton::TYPE_SELECTIONINDICATOR, 10 },
+    { CaptureToolButton::TYPE_MOVESELECTION, 11 },
+    { CaptureToolButton::TYPE_UNDO, 12 },
+    { CaptureToolButton::TYPE_REDO, 13 },
+    { CaptureToolButton::TYPE_COPY, 14 },
+    { CaptureToolButton::TYPE_SAVE, 15 },
+    { CaptureToolButton::TYPE_EXIT, 16 },
+    { CaptureToolButton::TYPE_IMAGEUPLOADER, 17 },
+    { CaptureToolButton::TYPE_OPEN_APP, 18 },
+    { CaptureToolButton::TYPE_PIN, 19 },
 };
 
-int
-CaptureToolButton::getPriorityByButton(CaptureToolButton::ButtonType b)
+int CaptureToolButton::getPriorityByButton(CaptureToolButton::ButtonType b)
 {
-  auto it = buttonTypeOrder.find(b);
-  return it == buttonTypeOrder.cend() ? (int)buttonTypeOrder.size()
-                                      : it->second;
+    auto it = buttonTypeOrder.find(b);
+    return it == buttonTypeOrder.cend() ? (int)buttonTypeOrder.size()
+                                        : it->second;
 }
 
 QVector<CaptureToolButton::ButtonType>
   CaptureToolButton::iterableButtonTypes = {
-    CaptureToolButton::TYPE_PENCIL,
-    CaptureToolButton::TYPE_DRAWER,
-    CaptureToolButton::TYPE_ARROW,
-    CaptureToolButton::TYPE_SELECTION,
-    CaptureToolButton::TYPE_RECTANGLE,
-    CaptureToolButton::TYPE_CIRCLE,
-    CaptureToolButton::TYPE_MARKER,
-    CaptureToolButton::TYPE_TEXT,
-    CaptureToolButton::TYPE_PIXELATE,
-    CaptureToolButton::TYPE_SELECTIONINDICATOR,
-    CaptureToolButton::TYPE_MOVESELECTION,
-    CaptureToolButton::TYPE_UNDO,
-    CaptureToolButton::TYPE_REDO,
-    CaptureToolButton::TYPE_COPY,
-    CaptureToolButton::TYPE_SAVE,
-    CaptureToolButton::TYPE_EXIT,
-    CaptureToolButton::TYPE_IMAGEUPLOADER,
-    CaptureToolButton::TYPE_OPEN_APP,
-    CaptureToolButton::TYPE_PIN,
-    CaptureToolButton::TYPE_CIRCLECOUNT,
+      CaptureToolButton::TYPE_PENCIL,
+      CaptureToolButton::TYPE_DRAWER,
+      CaptureToolButton::TYPE_ARROW,
+      CaptureToolButton::TYPE_SELECTION,
+      CaptureToolButton::TYPE_RECTANGLE,
+      CaptureToolButton::TYPE_CIRCLE,
+      CaptureToolButton::TYPE_MARKER,
+      CaptureToolButton::TYPE_TEXT,
+      CaptureToolButton::TYPE_PIXELATE,
+      CaptureToolButton::TYPE_SELECTIONINDICATOR,
+      CaptureToolButton::TYPE_MOVESELECTION,
+      CaptureToolButton::TYPE_UNDO,
+      CaptureToolButton::TYPE_REDO,
+      CaptureToolButton::TYPE_COPY,
+      CaptureToolButton::TYPE_SAVE,
+      CaptureToolButton::TYPE_EXIT,
+      CaptureToolButton::TYPE_IMAGEUPLOADER,
+      CaptureToolButton::TYPE_OPEN_APP,
+      CaptureToolButton::TYPE_PIN,
+      CaptureToolButton::TYPE_CIRCLECOUNT,
   };
diff --git a/src/widgets/capture/capturetoolbutton.h b/src/widgets/capture/capturetoolbutton.h
index bb5a3aab..2a2908da 100644
--- a/src/widgets/capture/capturetoolbutton.h
+++ b/src/widgets/capture/capturetoolbutton.h
@@ -27,67 +27,67 @@ class CaptureTool;
 
 class CaptureToolButton : public CaptureButton
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  // Don't forget to add the new types to CaptureButton::iterableButtonTypes
-  // in the .cpp and the order value in the private array buttonTypeOrder
-  enum ButtonType
-  {
-    TYPE_PENCIL = 0,
-    TYPE_DRAWER = 1,
-    TYPE_ARROW = 2,
-    TYPE_SELECTION = 3,
-    TYPE_RECTANGLE = 4,
-    TYPE_CIRCLE = 5,
-    TYPE_MARKER = 6,
-    TYPE_SELECTIONINDICATOR = 7,
-    TYPE_MOVESELECTION = 8,
-    TYPE_UNDO = 9,
-    TYPE_COPY = 10,
-    TYPE_SAVE = 11,
-    TYPE_EXIT = 12,
-    TYPE_IMAGEUPLOADER = 13,
-    TYPE_OPEN_APP = 14,
-    TYPE_PIXELATE = 15,
-    TYPE_REDO = 16,
-    TYPE_PIN = 17,
-    TYPE_TEXT = 18,
-    TYPE_CIRCLECOUNT = 19,
-
-  };
-  Q_ENUM(ButtonType)
-
-  explicit CaptureToolButton(const ButtonType, QWidget* parent = nullptr);
-
-  static QVector<CaptureToolButton::ButtonType> getIterableButtonTypes();
-  static int getPriorityByButton(CaptureToolButton::ButtonType);
-
-  QString name() const;
-  QString description() const;
-  QIcon icon() const;
-  CaptureTool* tool() const;
-
-  void setColor(const QColor& c);
-  void animatedShow();
+    // Don't forget to add the new types to CaptureButton::iterableButtonTypes
+    // in the .cpp and the order value in the private array buttonTypeOrder
+    enum ButtonType
+    {
+        TYPE_PENCIL = 0,
+        TYPE_DRAWER = 1,
+        TYPE_ARROW = 2,
+        TYPE_SELECTION = 3,
+        TYPE_RECTANGLE = 4,
+        TYPE_CIRCLE = 5,
+        TYPE_MARKER = 6,
+        TYPE_SELECTIONINDICATOR = 7,
+        TYPE_MOVESELECTION = 8,
+        TYPE_UNDO = 9,
+        TYPE_COPY = 10,
+        TYPE_SAVE = 11,
+        TYPE_EXIT = 12,
+        TYPE_IMAGEUPLOADER = 13,
+        TYPE_OPEN_APP = 14,
+        TYPE_PIXELATE = 15,
+        TYPE_REDO = 16,
+        TYPE_PIN = 17,
+        TYPE_TEXT = 18,
+        TYPE_CIRCLECOUNT = 19,
+
+    };
+    Q_ENUM(ButtonType)
+
+    explicit CaptureToolButton(const ButtonType, QWidget* parent = nullptr);
+
+    static QVector<CaptureToolButton::ButtonType> getIterableButtonTypes();
+    static int getPriorityByButton(CaptureToolButton::ButtonType);
+
+    QString name() const;
+    QString description() const;
+    QIcon icon() const;
+    CaptureTool* tool() const;
+
+    void setColor(const QColor& c);
+    void animatedShow();
 
 protected:
-  void mousePressEvent(QMouseEvent* e) override;
-  static QVector<ButtonType> iterableButtonTypes;
+    void mousePressEvent(QMouseEvent* e) override;
+    static QVector<ButtonType> iterableButtonTypes;
 
-  CaptureTool* m_tool;
+    CaptureTool* m_tool;
 
 signals:
-  void pressedButton(CaptureToolButton*);
+    void pressedButton(CaptureToolButton*);
 
 private:
-  CaptureToolButton(QWidget* parent = nullptr);
-  ButtonType m_buttonType;
+    CaptureToolButton(QWidget* parent = nullptr);
+    ButtonType m_buttonType;
 
-  QPropertyAnimation* m_emergeAnimation;
+    QPropertyAnimation* m_emergeAnimation;
 
-  static QColor m_mainColor;
+    static QColor m_mainColor;
 
-  void initButton();
-  void updateIcon();
+    void initButton();
+    void updateIcon();
 };
diff --git a/src/widgets/capture/capturewidget.cpp b/src/widgets/capture/capturewidget.cpp
index b85883a3..edbd33e1 100644
--- a/src/widgets/capture/capturewidget.cpp
+++ b/src/widgets/capture/capturewidget.cpp
@@ -70,1002 +70,974 @@ CaptureWidget::CaptureWidget(const uint id,
   , m_mouseOverHandle(SelectionWidget::NO_SIDE)
   , m_id(id)
 {
-  // Base config of the widget
-  m_eventFilter = new HoverEventFilter(this);
-  connect(m_eventFilter,
-          &HoverEventFilter::hoverIn,
-          this,
-          &CaptureWidget::childEnter);
-  connect(m_eventFilter,
-          &HoverEventFilter::hoverOut,
-          this,
-          &CaptureWidget::childLeave);
-  setAttribute(Qt::WA_DeleteOnClose);
-  m_showInitialMsg = m_config.showHelpValue();
-  m_opacity = m_config.contrastOpacityValue();
-  setMouseTracking(true);
-  initContext(savePath, fullScreen);
-  initShortcuts();
-  m_context.circleCount = 1;
+    // Base config of the widget
+    m_eventFilter = new HoverEventFilter(this);
+    connect(m_eventFilter,
+            &HoverEventFilter::hoverIn,
+            this,
+            &CaptureWidget::childEnter);
+    connect(m_eventFilter,
+            &HoverEventFilter::hoverOut,
+            this,
+            &CaptureWidget::childLeave);
+    setAttribute(Qt::WA_DeleteOnClose);
+    m_showInitialMsg = m_config.showHelpValue();
+    m_opacity = m_config.contrastOpacityValue();
+    setMouseTracking(true);
+    initContext(savePath, fullScreen);
+    initShortcuts();
+    m_context.circleCount = 1;
 #ifdef Q_OS_WIN
-  // Top left of the whole set of screens
-  QPoint topLeft(0, 0);
+    // Top left of the whole set of screens
+    QPoint topLeft(0, 0);
 #endif
-  if (fullScreen) {
-    // Grab Screenshot
-    bool ok = true;
-    m_context.screenshot = ScreenGrabber().grabEntireDesktop(ok);
-    if (!ok) {
-      SystemNotification().sendMessage(tr("Unable to capture screen"));
-      this->close();
-    }
-    m_context.origScreenshot = m_context.screenshot;
+    if (fullScreen) {
+        // Grab Screenshot
+        bool ok = true;
+        m_context.screenshot = ScreenGrabber().grabEntireDesktop(ok);
+        if (!ok) {
+            SystemNotification().sendMessage(tr("Unable to capture screen"));
+            this->close();
+        }
+        m_context.origScreenshot = m_context.screenshot;
 
 #ifdef Q_OS_WIN
-    setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint |
-                   Qt::Popup);
-
-    for (QScreen* const screen : QGuiApplication::screens()) {
-      QPoint topLeftScreen = screen->geometry().topLeft();
-      if (topLeft.x() > topLeftScreen.x() || topLeft.y() > topLeftScreen.y()) {
-        topLeft = topLeftScreen;
-      }
-    }
-    move(topLeft);
+        setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint |
+                       Qt::Popup);
+
+        for (QScreen* const screen : QGuiApplication::screens()) {
+            QPoint topLeftScreen = screen->geometry().topLeft();
+            if (topLeft.x() > topLeftScreen.x() ||
+                topLeft.y() > topLeftScreen.y()) {
+                topLeft = topLeftScreen;
+            }
+        }
+        move(topLeft);
 #else
-    setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint |
-                   Qt::FramelessWindowHint | Qt::Tool);
+        setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint |
+                       Qt::FramelessWindowHint | Qt::Tool);
 #endif
-    resize(pixmap().size());
-  }
-  // Create buttons
-  m_buttonHandler = new ButtonHandler(this);
-  updateButtons();
-  QVector<QRect> areas;
-  if (m_context.fullscreen) {
-    for (QScreen* const screen : QGuiApplication::screens()) {
-      QRect r = screen->geometry();
+        resize(pixmap().size());
+    }
+    // Create buttons
+    m_buttonHandler = new ButtonHandler(this);
+    updateButtons();
+    QVector<QRect> areas;
+    if (m_context.fullscreen) {
+        for (QScreen* const screen : QGuiApplication::screens()) {
+            QRect r = screen->geometry();
 #ifdef Q_OS_WIN
-      r.moveTo(r.topLeft() - topLeft);
+            r.moveTo(r.topLeft() - topLeft);
 #endif
-      areas.append(r);
+            areas.append(r);
+        }
+    } else {
+        areas.append(rect());
     }
-  } else {
-    areas.append(rect());
-  }
-  m_buttonHandler->updateScreenRegions(areas);
-  m_buttonHandler->hide();
-
-  initSelection();
-  updateCursor();
-
-  // Init color picker
-  m_colorPicker = new ColorPicker(this);
-  connect(m_colorPicker,
-          &ColorPicker::colorSelected,
-          this,
-          &CaptureWidget::setDrawColor);
-  m_colorPicker->hide();
-
-  // Init notification widget
-  m_notifierBox = new NotifierBox(this);
-  m_notifierBox->hide();
-
-  connect(&m_undoStack, &QUndoStack::indexChanged, this, [this](int) {
-    this->update();
-  });
-  initPanel();
+    m_buttonHandler->updateScreenRegions(areas);
+    m_buttonHandler->hide();
+
+    initSelection();
+    updateCursor();
+
+    // Init color picker
+    m_colorPicker = new ColorPicker(this);
+    connect(m_colorPicker,
+            &ColorPicker::colorSelected,
+            this,
+            &CaptureWidget::setDrawColor);
+    m_colorPicker->hide();
+
+    // Init notification widget
+    m_notifierBox = new NotifierBox(this);
+    m_notifierBox->hide();
+
+    connect(&m_undoStack, &QUndoStack::indexChanged, this, [this](int) {
+        this->update();
+    });
+    initPanel();
 }
 
 CaptureWidget::~CaptureWidget()
 {
-  if (m_captureDone) {
-    emit captureTaken(m_id, this->pixmap());
-  } else {
-    emit captureFailed(m_id);
-  }
-  m_config.setdrawThickness(m_context.thickness);
+    if (m_captureDone) {
+        emit captureTaken(m_id, this->pixmap());
+    } else {
+        emit captureFailed(m_id);
+    }
+    m_config.setdrawThickness(m_context.thickness);
 }
 
 // redefineButtons retrieves the buttons configured to be shown with the
 // selection in the capture
-void
-CaptureWidget::updateButtons()
+void CaptureWidget::updateButtons()
 {
-  m_uiColor = m_config.uiMainColorValue();
-  m_contrastUiColor = m_config.uiContrastColorValue();
+    m_uiColor = m_config.uiMainColorValue();
+    m_contrastUiColor = m_config.uiContrastColorValue();
 
-  auto buttons = m_config.getButtons();
-  QVector<CaptureToolButton*> vectorButtons;
+    auto buttons = m_config.getButtons();
+    QVector<CaptureToolButton*> vectorButtons;
 
-  for (const CaptureToolButton::ButtonType& t : buttons) {
-    CaptureToolButton* b = new CaptureToolButton(t, this);
-    if (t == CaptureToolButton::TYPE_SELECTIONINDICATOR) {
-      m_sizeIndButton = b;
+    for (const CaptureToolButton::ButtonType& t : buttons) {
+        CaptureToolButton* b = new CaptureToolButton(t, this);
+        if (t == CaptureToolButton::TYPE_SELECTIONINDICATOR) {
+            m_sizeIndButton = b;
+        }
+        b->setColor(m_uiColor);
+        makeChild(b);
+
+        connect(
+          b, &CaptureToolButton::pressedButton, this, &CaptureWidget::setState);
+        connect(b->tool(),
+                &CaptureTool::requestAction,
+                this,
+                &CaptureWidget::handleButtonSignal);
+        vectorButtons << b;
     }
-    b->setColor(m_uiColor);
-    makeChild(b);
-
-    connect(
-      b, &CaptureToolButton::pressedButton, this, &CaptureWidget::setState);
-    connect(b->tool(),
-            &CaptureTool::requestAction,
-            this,
-            &CaptureWidget::handleButtonSignal);
-    vectorButtons << b;
-  }
-  m_buttonHandler->setButtons(vectorButtons);
+    m_buttonHandler->setButtons(vectorButtons);
 }
 
-QPixmap
-CaptureWidget::pixmap()
+QPixmap CaptureWidget::pixmap()
 {
-  QPixmap p;
-  if (m_toolWidget && m_activeTool) {
-    p = m_context.selectedScreenshotArea().copy();
-    QPainter painter(&p);
-    m_activeTool->process(painter, p);
-  } else {
-    p = m_context.selectedScreenshotArea();
-  }
-  return m_context.selectedScreenshotArea();
+    QPixmap p;
+    if (m_toolWidget && m_activeTool) {
+        p = m_context.selectedScreenshotArea().copy();
+        QPainter painter(&p);
+        m_activeTool->process(painter, p);
+    } else {
+        p = m_context.selectedScreenshotArea();
+    }
+    return m_context.selectedScreenshotArea();
 }
 
-void
-CaptureWidget::deleteToolwidgetOrClose()
+void CaptureWidget::deleteToolwidgetOrClose()
 {
-  if (m_toolWidget) {
-    m_toolWidget->deleteLater();
-    m_toolWidget = nullptr;
-  } else {
-    close();
-  }
+    if (m_toolWidget) {
+        m_toolWidget->deleteLater();
+        m_toolWidget = nullptr;
+    } else {
+        close();
+    }
 }
 
-void
-CaptureWidget::paintEvent(QPaintEvent*)
+void CaptureWidget::paintEvent(QPaintEvent*)
 {
-  QPainter painter(this);
-  painter.drawPixmap(0, 0, m_context.screenshot);
-
-  if (m_activeTool && m_mouseIsClicked) {
-    painter.save();
-    m_activeTool->process(painter, m_context.screenshot);
-    painter.restore();
-  } else if (m_activeButton && m_activeButton->tool()->showMousePreview() &&
-             m_previewEnabled) {
-    painter.save();
-    m_activeButton->tool()->paintMousePreview(painter, m_context);
-    painter.restore();
-  }
-
-  QColor overlayColor(0, 0, 0, m_opacity);
-  painter.setBrush(overlayColor);
-  QRect r;
-  if (m_selection->isVisible()) {
-    r = m_selection->geometry().normalized().adjusted(0, 0, -1, -1);
-  }
-  QRegion grey(rect());
-  grey = grey.subtracted(r);
-
-  painter.setClipRegion(grey);
-  painter.drawRect(-1, -1, rect().width() + 1, rect().height() + 1);
-  painter.setClipRect(rect());
-
-  if (m_showInitialMsg) {
-    QRect helpRect = QGuiApplication::primaryScreen()->geometry();
-    helpRect.moveTo(mapFromGlobal(helpRect.topLeft()));
-
-    QString helpTxt =
-      tr("Select an area with the mouse, or press Esc to exit."
-         "\nPress Enter to capture the screen."
-         "\nPress Right Click to show the color picker."
-         "\nUse the Mouse Wheel to change the thickness of your tool."
-         "\nPress Space to open the side panel.");
-
-    // We draw the white contrasting background for the text, using the
-    // same text and options to get the boundingRect that the text will have.
-    QRectF bRect = painter.boundingRect(helpRect, Qt::AlignCenter, helpTxt);
-
-    // These four calls provide padding for the rect
-    const int margin = QApplication::fontMetrics().height() / 2;
-    bRect.setWidth(bRect.width() + margin);
-    bRect.setHeight(bRect.height() + margin);
-    bRect.setX(bRect.x() - margin);
-    bRect.setY(bRect.y() - margin);
-
-    QColor rectColor(m_uiColor);
-    rectColor.setAlpha(180);
-    QColor textColor(
-      (ColorUtils::colorIsDark(rectColor) ? Qt::white : Qt::black));
-
-    painter.setBrush(QBrush(rectColor, Qt::SolidPattern));
-    painter.setPen(QPen(textColor));
-
-    painter.drawRect(bRect);
-    painter.drawText(helpRect, Qt::AlignCenter, helpTxt);
-  }
-
-  if (m_selection->isVisible()) {
-    // paint handlers
-    painter.setPen(m_uiColor);
-    painter.setRenderHint(QPainter::Antialiasing);
-    painter.setBrush(m_uiColor);
-    for (auto r : m_selection->handlerAreas()) {
-      painter.drawRoundedRect(r, 100, 100);
+    QPainter painter(this);
+    painter.drawPixmap(0, 0, m_context.screenshot);
+
+    if (m_activeTool && m_mouseIsClicked) {
+        painter.save();
+        m_activeTool->process(painter, m_context.screenshot);
+        painter.restore();
+    } else if (m_activeButton && m_activeButton->tool()->showMousePreview() &&
+               m_previewEnabled) {
+        painter.save();
+        m_activeButton->tool()->paintMousePreview(painter, m_context);
+        painter.restore();
+    }
+
+    QColor overlayColor(0, 0, 0, m_opacity);
+    painter.setBrush(overlayColor);
+    QRect r;
+    if (m_selection->isVisible()) {
+        r = m_selection->geometry().normalized().adjusted(0, 0, -1, -1);
+    }
+    QRegion grey(rect());
+    grey = grey.subtracted(r);
+
+    painter.setClipRegion(grey);
+    painter.drawRect(-1, -1, rect().width() + 1, rect().height() + 1);
+    painter.setClipRect(rect());
+
+    if (m_showInitialMsg) {
+        QRect helpRect = QGuiApplication::primaryScreen()->geometry();
+        helpRect.moveTo(mapFromGlobal(helpRect.topLeft()));
+
+        QString helpTxt =
+          tr("Select an area with the mouse, or press Esc to exit."
+             "\nPress Enter to capture the screen."
+             "\nPress Right Click to show the color picker."
+             "\nUse the Mouse Wheel to change the thickness of your tool."
+             "\nPress Space to open the side panel.");
+
+        // We draw the white contrasting background for the text, using the
+        // same text and options to get the boundingRect that the text will
+        // have.
+        QRectF bRect = painter.boundingRect(helpRect, Qt::AlignCenter, helpTxt);
+
+        // These four calls provide padding for the rect
+        const int margin = QApplication::fontMetrics().height() / 2;
+        bRect.setWidth(bRect.width() + margin);
+        bRect.setHeight(bRect.height() + margin);
+        bRect.setX(bRect.x() - margin);
+        bRect.setY(bRect.y() - margin);
+
+        QColor rectColor(m_uiColor);
+        rectColor.setAlpha(180);
+        QColor textColor(
+          (ColorUtils::colorIsDark(rectColor) ? Qt::white : Qt::black));
+
+        painter.setBrush(QBrush(rectColor, Qt::SolidPattern));
+        painter.setPen(QPen(textColor));
+
+        painter.drawRect(bRect);
+        painter.drawText(helpRect, Qt::AlignCenter, helpTxt);
+    }
+
+    if (m_selection->isVisible()) {
+        // paint handlers
+        painter.setPen(m_uiColor);
+        painter.setRenderHint(QPainter::Antialiasing);
+        painter.setBrush(m_uiColor);
+        for (auto r : m_selection->handlerAreas()) {
+            painter.drawRoundedRect(r, 100, 100);
+        }
     }
-  }
 }
 
-void
-CaptureWidget::mousePressEvent(QMouseEvent* e)
+void CaptureWidget::mousePressEvent(QMouseEvent* e)
 {
-  if (e->button() == Qt::RightButton) {
-    m_rightClick = true;
-    m_colorPicker->move(e->pos().x() - m_colorPicker->width() / 2,
-                        e->pos().y() - m_colorPicker->height() / 2);
-    m_colorPicker->show();
-  } else if (e->button() == Qt::LeftButton) {
-    m_showInitialMsg = false;
-    m_mouseIsClicked = true;
-    // Click using a tool
-    if (m_activeButton) {
-      if (m_activeTool) {
-        if (m_activeTool->isValid() && m_toolWidget) {
-          pushToolToStack();
-        } else {
-          m_activeTool->deleteLater();
+    if (e->button() == Qt::RightButton) {
+        m_rightClick = true;
+        m_colorPicker->move(e->pos().x() - m_colorPicker->width() / 2,
+                            e->pos().y() - m_colorPicker->height() / 2);
+        m_colorPicker->show();
+    } else if (e->button() == Qt::LeftButton) {
+        m_showInitialMsg = false;
+        m_mouseIsClicked = true;
+        // Click using a tool
+        if (m_activeButton) {
+            if (m_activeTool) {
+                if (m_activeTool->isValid() && m_toolWidget) {
+                    pushToolToStack();
+                } else {
+                    m_activeTool->deleteLater();
+                }
+                if (m_toolWidget) {
+                    m_toolWidget->deleteLater();
+                    return;
+                }
+            }
+            m_activeTool = m_activeButton->tool()->copy(this);
+
+            connect(this,
+                    &CaptureWidget::colorChanged,
+                    m_activeTool,
+                    &CaptureTool::colorChanged);
+            connect(this,
+                    &CaptureWidget::thicknessChanged,
+                    m_activeTool,
+                    &CaptureTool::thicknessChanged);
+            connect(m_activeTool,
+                    &CaptureTool::requestAction,
+                    this,
+                    &CaptureWidget::handleButtonSignal);
+            m_activeTool->drawStart(m_context);
+            return;
         }
-        if (m_toolWidget) {
-          m_toolWidget->deleteLater();
-          return;
-        }
-      }
-      m_activeTool = m_activeButton->tool()->copy(this);
-
-      connect(this,
-              &CaptureWidget::colorChanged,
-              m_activeTool,
-              &CaptureTool::colorChanged);
-      connect(this,
-              &CaptureWidget::thicknessChanged,
-              m_activeTool,
-              &CaptureTool::thicknessChanged);
-      connect(m_activeTool,
-              &CaptureTool::requestAction,
-              this,
-              &CaptureWidget::handleButtonSignal);
-      m_activeTool->drawStart(m_context);
-      return;
-    }
 
-    m_dragStartPoint = e->pos();
-    m_selection->saveGeometry();
-    // New selection
-    if (!m_selection->geometry().contains(e->pos()) &&
-        m_mouseOverHandle == SelectionWidget::NO_SIDE) {
-      m_selection->setGeometry(QRect(e->pos(), e->pos()));
-      m_selection->setVisible(false);
-      m_newSelection = true;
-      m_buttonHandler->hide();
-      update();
-    } else {
-      m_grabbing = true;
+        m_dragStartPoint = e->pos();
+        m_selection->saveGeometry();
+        // New selection
+        if (!m_selection->geometry().contains(e->pos()) &&
+            m_mouseOverHandle == SelectionWidget::NO_SIDE) {
+            m_selection->setGeometry(QRect(e->pos(), e->pos()));
+            m_selection->setVisible(false);
+            m_newSelection = true;
+            m_buttonHandler->hide();
+            update();
+        } else {
+            m_grabbing = true;
+        }
     }
-  }
-  updateCursor();
+    updateCursor();
 }
 
-void
-CaptureWidget::mouseMoveEvent(QMouseEvent* e)
+void CaptureWidget::mouseMoveEvent(QMouseEvent* e)
 {
-  m_context.mousePos = e->pos();
+    m_context.mousePos = e->pos();
 
-  if (m_mouseIsClicked && !m_activeButton) {
-    if (m_buttonHandler->isVisible()) {
-      m_buttonHandler->hide();
-    }
-    if (m_newSelection) {
-      m_selection->setVisible(true);
-      m_selection->setGeometry(
-        QRect(m_dragStartPoint, m_context.mousePos).normalized());
-      update();
-    } else if (m_mouseOverHandle == SelectionWidget::NO_SIDE) {
-      // Moving the whole selection
-      QRect initialRect = m_selection->savedGeometry().normalized();
-      QPoint newTopLeft = initialRect.topLeft() + (e->pos() - m_dragStartPoint);
-      QRect finalRect(newTopLeft, initialRect.size());
-
-      if (finalRect.left() < rect().left()) {
-        finalRect.setLeft(rect().left());
-      } else if (finalRect.right() > rect().right()) {
-        finalRect.setRight(rect().right());
-      }
-      if (finalRect.top() < rect().top()) {
-        finalRect.setTop(rect().top());
-      } else if (finalRect.bottom() > rect().bottom()) {
-        finalRect.setBottom(rect().bottom());
-      }
-      m_selection->setGeometry(finalRect.normalized().intersected(rect()));
-      update();
-    } else {
-      // Dragging a handle
-      QRect r = m_selection->savedGeometry();
-      QPoint offset = e->pos() - m_dragStartPoint;
-      bool symmetryMod = qApp->keyboardModifiers() & Qt::ShiftModifier;
-
-      using sw = SelectionWidget;
-      if (m_mouseOverHandle == sw::TOPLEFT_SIDE ||
-          m_mouseOverHandle == sw::TOP_SIDE ||
-          m_mouseOverHandle ==
-            sw::TOPRIGHT_SIDE) { // dragging one of the top handles
-        r.setTop(r.top() + offset.y());
-        if (symmetryMod) {
-          r.setBottom(r.bottom() - offset.y());
+    if (m_mouseIsClicked && !m_activeButton) {
+        if (m_buttonHandler->isVisible()) {
+            m_buttonHandler->hide();
         }
-      }
-      if (m_mouseOverHandle == sw::TOPLEFT_SIDE ||
-          m_mouseOverHandle == sw::LEFT_SIDE ||
-          m_mouseOverHandle ==
-            sw::BOTTONLEFT_SIDE) { // dragging one of the left handles
-        r.setLeft(r.left() + offset.x());
-        if (symmetryMod) {
-          r.setRight(r.right() - offset.x());
+        if (m_newSelection) {
+            m_selection->setVisible(true);
+            m_selection->setGeometry(
+              QRect(m_dragStartPoint, m_context.mousePos).normalized());
+            update();
+        } else if (m_mouseOverHandle == SelectionWidget::NO_SIDE) {
+            // Moving the whole selection
+            QRect initialRect = m_selection->savedGeometry().normalized();
+            QPoint newTopLeft =
+              initialRect.topLeft() + (e->pos() - m_dragStartPoint);
+            QRect finalRect(newTopLeft, initialRect.size());
+
+            if (finalRect.left() < rect().left()) {
+                finalRect.setLeft(rect().left());
+            } else if (finalRect.right() > rect().right()) {
+                finalRect.setRight(rect().right());
+            }
+            if (finalRect.top() < rect().top()) {
+                finalRect.setTop(rect().top());
+            } else if (finalRect.bottom() > rect().bottom()) {
+                finalRect.setBottom(rect().bottom());
+            }
+            m_selection->setGeometry(
+              finalRect.normalized().intersected(rect()));
+            update();
+        } else {
+            // Dragging a handle
+            QRect r = m_selection->savedGeometry();
+            QPoint offset = e->pos() - m_dragStartPoint;
+            bool symmetryMod = qApp->keyboardModifiers() & Qt::ShiftModifier;
+
+            using sw = SelectionWidget;
+            if (m_mouseOverHandle == sw::TOPLEFT_SIDE ||
+                m_mouseOverHandle == sw::TOP_SIDE ||
+                m_mouseOverHandle ==
+                  sw::TOPRIGHT_SIDE) { // dragging one of the top handles
+                r.setTop(r.top() + offset.y());
+                if (symmetryMod) {
+                    r.setBottom(r.bottom() - offset.y());
+                }
+            }
+            if (m_mouseOverHandle == sw::TOPLEFT_SIDE ||
+                m_mouseOverHandle == sw::LEFT_SIDE ||
+                m_mouseOverHandle ==
+                  sw::BOTTONLEFT_SIDE) { // dragging one of the left handles
+                r.setLeft(r.left() + offset.x());
+                if (symmetryMod) {
+                    r.setRight(r.right() - offset.x());
+                }
+            }
+            if (m_mouseOverHandle == sw::BOTTONLEFT_SIDE ||
+                m_mouseOverHandle == sw::BOTTON_SIDE ||
+                m_mouseOverHandle ==
+                  sw::BOTTONRIGHT_SIDE) { // dragging one of the bottom handles
+                r.setBottom(r.bottom() + offset.y());
+                if (symmetryMod) {
+                    r.setTop(r.top() - offset.y());
+                }
+            }
+            if (m_mouseOverHandle == sw::TOPRIGHT_SIDE ||
+                m_mouseOverHandle == sw::RIGHT_SIDE ||
+                m_mouseOverHandle ==
+                  sw::BOTTONRIGHT_SIDE) { // dragging one of the right handles
+                r.setRight(r.right() + offset.x());
+                if (symmetryMod) {
+                    r.setLeft(r.left() - offset.x());
+                }
+            }
+            m_selection->setGeometry(r.intersected(rect()).normalized());
+            update();
         }
-      }
-      if (m_mouseOverHandle == sw::BOTTONLEFT_SIDE ||
-          m_mouseOverHandle == sw::BOTTON_SIDE ||
-          m_mouseOverHandle ==
-            sw::BOTTONRIGHT_SIDE) { // dragging one of the bottom handles
-        r.setBottom(r.bottom() + offset.y());
-        if (symmetryMod) {
-          r.setTop(r.top() - offset.y());
+    } else if (m_mouseIsClicked && m_activeTool) {
+        // drawing with a tool
+        if (m_adjustmentButtonPressed) {
+            m_activeTool->drawMoveWithAdjustment(e->pos());
+        } else {
+            m_activeTool->drawMove(e->pos());
         }
-      }
-      if (m_mouseOverHandle == sw::TOPRIGHT_SIDE ||
-          m_mouseOverHandle == sw::RIGHT_SIDE ||
-          m_mouseOverHandle ==
-            sw::BOTTONRIGHT_SIDE) { // dragging one of the right handles
-        r.setRight(r.right() + offset.x());
-        if (symmetryMod) {
-          r.setLeft(r.left() - offset.x());
+        update();
+        // Hides the buttons under the mouse. If the mouse leaves, it shows
+        // them.
+        if (m_buttonHandler->buttonsAreInside()) {
+            const bool containsMouse =
+              m_buttonHandler->contains(m_context.mousePos);
+            if (containsMouse) {
+                m_buttonHandler->hide();
+            } else {
+                m_buttonHandler->show();
+            }
         }
-      }
-      m_selection->setGeometry(r.intersected(rect()).normalized());
-      update();
-    }
-  } else if (m_mouseIsClicked && m_activeTool) {
-    // drawing with a tool
-    if (m_adjustmentButtonPressed) {
-      m_activeTool->drawMoveWithAdjustment(e->pos());
+    } else if (m_activeButton && m_activeButton->tool()->showMousePreview()) {
+        update();
     } else {
-      m_activeTool->drawMove(e->pos());
-    }
-    update();
-    // Hides the buttons under the mouse. If the mouse leaves, it shows them.
-    if (m_buttonHandler->buttonsAreInside()) {
-      const bool containsMouse = m_buttonHandler->contains(m_context.mousePos);
-      if (containsMouse) {
-        m_buttonHandler->hide();
-      } else {
-        m_buttonHandler->show();
-      }
-    }
-  } else if (m_activeButton && m_activeButton->tool()->showMousePreview()) {
-    update();
-  } else {
-    if (!m_selection->isVisible()) {
-      return;
+        if (!m_selection->isVisible()) {
+            return;
+        }
+        m_mouseOverHandle = m_selection->getMouseSide(m_context.mousePos);
+        updateCursor();
     }
-    m_mouseOverHandle = m_selection->getMouseSide(m_context.mousePos);
-    updateCursor();
-  }
 }
 
-void
-CaptureWidget::mouseReleaseEvent(QMouseEvent* e)
+void CaptureWidget::mouseReleaseEvent(QMouseEvent* e)
 {
-  if (e->button() == Qt::RightButton) {
-    m_colorPicker->hide();
-    m_rightClick = false;
-    // when we end the drawing we have to register the last  point and
-    // add the temp modification to the list of modifications
-  } else if (m_mouseIsClicked && m_activeTool) {
-    m_activeTool->drawEnd(m_context.mousePos);
-    if (m_activeTool->isValid()) {
-      pushToolToStack();
-    } else if (!m_toolWidget) {
-      m_activeTool->deleteLater();
-      m_activeTool = nullptr;
-    }
-  }
-
-  // Show the buttons after the resize of the selection or the creation
-  // of a new one.
-  if (!m_buttonHandler->isVisible() && m_selection->isVisible()) {
-    // Don't go outside
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    // normalize
-    if (newGeometry.width() <= 0) {
-      int left = newGeometry.left();
-      newGeometry.setLeft(newGeometry.right());
-      newGeometry.setRight(left);
+    if (e->button() == Qt::RightButton) {
+        m_colorPicker->hide();
+        m_rightClick = false;
+        // when we end the drawing we have to register the last  point and
+        // add the temp modification to the list of modifications
+    } else if (m_mouseIsClicked && m_activeTool) {
+        m_activeTool->drawEnd(m_context.mousePos);
+        if (m_activeTool->isValid()) {
+            pushToolToStack();
+        } else if (!m_toolWidget) {
+            m_activeTool->deleteLater();
+            m_activeTool = nullptr;
+        }
     }
-    if (newGeometry.height() <= 0) {
-      int top = newGeometry.top();
-      newGeometry.setTop(newGeometry.bottom());
-      newGeometry.setBottom(top);
+
+    // Show the buttons after the resize of the selection or the creation
+    // of a new one.
+    if (!m_buttonHandler->isVisible() && m_selection->isVisible()) {
+        // Don't go outside
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        // normalize
+        if (newGeometry.width() <= 0) {
+            int left = newGeometry.left();
+            newGeometry.setLeft(newGeometry.right());
+            newGeometry.setRight(left);
+        }
+        if (newGeometry.height() <= 0) {
+            int top = newGeometry.top();
+            newGeometry.setTop(newGeometry.bottom());
+            newGeometry.setBottom(top);
+        }
+        m_selection->setGeometry(newGeometry);
+        m_context.selection = extendedRect(&newGeometry);
+        updateSizeIndicator();
+        m_buttonHandler->updatePosition(newGeometry);
+        m_buttonHandler->show();
     }
-    m_selection->setGeometry(newGeometry);
-    m_context.selection = extendedRect(&newGeometry);
-    updateSizeIndicator();
-    m_buttonHandler->updatePosition(newGeometry);
-    m_buttonHandler->show();
-  }
-  m_mouseIsClicked = false;
-  m_newSelection = false;
-  m_grabbing = false;
-
-  updateCursor();
+    m_mouseIsClicked = false;
+    m_newSelection = false;
+    m_grabbing = false;
+
+    updateCursor();
 }
 
-void
-CaptureWidget::keyPressEvent(QKeyEvent* e)
+void CaptureWidget::keyPressEvent(QKeyEvent* e)
 {
-  if (!m_selection->isVisible()) {
-    return;
-  } else if (e->key() == Qt::Key_Up &&
-             m_selection->geometry().top() > rect().top()) {
-    m_selection->move(QPoint(m_selection->x(), m_selection->y() - 1));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    update();
-  } else if (e->key() == Qt::Key_Down &&
-             m_selection->geometry().bottom() < rect().bottom()) {
-    m_selection->move(QPoint(m_selection->x(), m_selection->y() + 1));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    update();
-  } else if (e->key() == Qt::Key_Left &&
-             m_selection->geometry().left() > rect().left()) {
-    m_selection->move(QPoint(m_selection->x() - 1, m_selection->y()));
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    update();
-  } else if (e->key() == Qt::Key_Right &&
-             m_selection->geometry().right() < rect().right()) {
-    m_selection->move(QPoint(m_selection->x() + 1, m_selection->y()));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    update();
-  } else if (e->key() == Qt::Key_Control) {
-    m_adjustmentButtonPressed = true;
-  }
+    if (!m_selection->isVisible()) {
+        return;
+    } else if (e->key() == Qt::Key_Up &&
+               m_selection->geometry().top() > rect().top()) {
+        m_selection->move(QPoint(m_selection->x(), m_selection->y() - 1));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        update();
+    } else if (e->key() == Qt::Key_Down &&
+               m_selection->geometry().bottom() < rect().bottom()) {
+        m_selection->move(QPoint(m_selection->x(), m_selection->y() + 1));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        update();
+    } else if (e->key() == Qt::Key_Left &&
+               m_selection->geometry().left() > rect().left()) {
+        m_selection->move(QPoint(m_selection->x() - 1, m_selection->y()));
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        update();
+    } else if (e->key() == Qt::Key_Right &&
+               m_selection->geometry().right() < rect().right()) {
+        m_selection->move(QPoint(m_selection->x() + 1, m_selection->y()));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        update();
+    } else if (e->key() == Qt::Key_Control) {
+        m_adjustmentButtonPressed = true;
+    }
 }
 
-void
-CaptureWidget::keyReleaseEvent(QKeyEvent* e)
+void CaptureWidget::keyReleaseEvent(QKeyEvent* e)
 {
-  if (e->key() == Qt::Key_Control) {
-    m_adjustmentButtonPressed = false;
-  }
+    if (e->key() == Qt::Key_Control) {
+        m_adjustmentButtonPressed = false;
+    }
 }
 
-void
-CaptureWidget::wheelEvent(QWheelEvent* e)
+void CaptureWidget::wheelEvent(QWheelEvent* e)
 {
-  m_context.thickness += e->angleDelta().y() / 120;
-  m_context.thickness = qBound(0, m_context.thickness, 100);
-  QPoint topLeft =
-    qApp->desktop()
-      ->screenGeometry(qApp->desktop()->screenNumber(QCursor::pos()))
-      .topLeft();
-  int offset = m_notifierBox->width() / 4;
-  m_notifierBox->move(mapFromGlobal(topLeft) + QPoint(offset, offset));
-  m_notifierBox->showMessage(QString::number(m_context.thickness));
-  if (m_activeButton && m_activeButton->tool()->showMousePreview()) {
-    update();
-  }
-  emit thicknessChanged(m_context.thickness);
+    m_context.thickness += e->angleDelta().y() / 120;
+    m_context.thickness = qBound(0, m_context.thickness, 100);
+    QPoint topLeft =
+      qApp->desktop()
+        ->screenGeometry(qApp->desktop()->screenNumber(QCursor::pos()))
+        .topLeft();
+    int offset = m_notifierBox->width() / 4;
+    m_notifierBox->move(mapFromGlobal(topLeft) + QPoint(offset, offset));
+    m_notifierBox->showMessage(QString::number(m_context.thickness));
+    if (m_activeButton && m_activeButton->tool()->showMousePreview()) {
+        update();
+    }
+    emit thicknessChanged(m_context.thickness);
 }
 
-void
-CaptureWidget::resizeEvent(QResizeEvent* e)
+void CaptureWidget::resizeEvent(QResizeEvent* e)
 {
-  QWidget::resizeEvent(e);
-  m_context.widgetDimensions = rect();
-  m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
-  if (!m_context.fullscreen) {
-    m_panel->setFixedHeight(height());
-    m_buttonHandler->updateScreenRegions(rect());
-  }
+    QWidget::resizeEvent(e);
+    m_context.widgetDimensions = rect();
+    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
+    if (!m_context.fullscreen) {
+        m_panel->setFixedHeight(height());
+        m_buttonHandler->updateScreenRegions(rect());
+    }
 }
 
-void
-CaptureWidget::moveEvent(QMoveEvent* e)
+void CaptureWidget::moveEvent(QMoveEvent* e)
 {
-  QWidget::moveEvent(e);
-  m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
+    QWidget::moveEvent(e);
+    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
 }
 
-void
-CaptureWidget::initContext(const QString& savePath, bool fullscreen)
+void CaptureWidget::initContext(const QString& savePath, bool fullscreen)
 {
-  m_context.widgetDimensions = rect();
-  m_context.color = m_config.drawColorValue();
-  m_context.savePath = savePath;
-  m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
-  m_context.mousePos = mapFromGlobal(QCursor::pos());
-  m_context.thickness = m_config.drawThicknessValue();
-  m_context.fullscreen = fullscreen;
+    m_context.widgetDimensions = rect();
+    m_context.color = m_config.drawColorValue();
+    m_context.savePath = savePath;
+    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));
+    m_context.mousePos = mapFromGlobal(QCursor::pos());
+    m_context.thickness = m_config.drawThicknessValue();
+    m_context.fullscreen = fullscreen;
 }
 
-void
-CaptureWidget::initPanel()
+void CaptureWidget::initPanel()
 {
-  QRect panelRect = rect();
-  if (m_context.fullscreen) {
-    panelRect = QGuiApplication::primaryScreen()->geometry();
-  }
-
-  ConfigHandler config;
-
-  if (config.showSidePanelButtonValue()) {
-    auto* panelToggleButton =
-      new OrientablePushButton(tr("Tool Settings"), this);
-    makeChild(panelToggleButton);
-    panelToggleButton->setOrientation(
-      OrientablePushButton::VerticalBottomToTop);
-    panelToggleButton->move(panelRect.x(),
-                            panelRect.y() + panelRect.height() / 2 -
-                              panelToggleButton->width() / 2);
-    panelToggleButton->setCursor(Qt::ArrowCursor);
-    (new DraggableWidgetMaker(this))->makeDraggable(panelToggleButton);
-    connect(panelToggleButton,
-            &QPushButton::clicked,
+    QRect panelRect = rect();
+    if (m_context.fullscreen) {
+        panelRect = QGuiApplication::primaryScreen()->geometry();
+    }
+
+    ConfigHandler config;
+
+    if (config.showSidePanelButtonValue()) {
+        auto* panelToggleButton =
+          new OrientablePushButton(tr("Tool Settings"), this);
+        makeChild(panelToggleButton);
+        panelToggleButton->setOrientation(
+          OrientablePushButton::VerticalBottomToTop);
+        panelToggleButton->move(panelRect.x(),
+                                panelRect.y() + panelRect.height() / 2 -
+                                  panelToggleButton->width() / 2);
+        panelToggleButton->setCursor(Qt::ArrowCursor);
+        (new DraggableWidgetMaker(this))->makeDraggable(panelToggleButton);
+        connect(panelToggleButton,
+                &QPushButton::clicked,
+                this,
+                &CaptureWidget::togglePanel);
+    }
+
+    m_panel = new UtilityPanel(this);
+    makeChild(m_panel);
+    panelRect.moveTo(mapFromGlobal(panelRect.topLeft()));
+    panelRect.setWidth(m_colorPicker->width() * 3);
+    m_panel->setGeometry(panelRect);
+
+    SidePanelWidget* sidePanel = new SidePanelWidget(&m_context.screenshot);
+    connect(sidePanel,
+            &SidePanelWidget::colorChanged,
+            this,
+            &CaptureWidget::setDrawColor);
+    connect(sidePanel,
+            &SidePanelWidget::thicknessChanged,
             this,
-            &CaptureWidget::togglePanel);
-  }
-
-  m_panel = new UtilityPanel(this);
-  makeChild(m_panel);
-  panelRect.moveTo(mapFromGlobal(panelRect.topLeft()));
-  panelRect.setWidth(m_colorPicker->width() * 3);
-  m_panel->setGeometry(panelRect);
-
-  SidePanelWidget* sidePanel = new SidePanelWidget(&m_context.screenshot);
-  connect(sidePanel,
-          &SidePanelWidget::colorChanged,
-          this,
-          &CaptureWidget::setDrawColor);
-  connect(sidePanel,
-          &SidePanelWidget::thicknessChanged,
-          this,
-          &CaptureWidget::setDrawThickness);
-  connect(this,
-          &CaptureWidget::colorChanged,
-          sidePanel,
-          &SidePanelWidget::updateColor);
-  connect(this,
-          &CaptureWidget::thicknessChanged,
-          sidePanel,
-          &SidePanelWidget::updateThickness);
-  connect(
-    sidePanel, &SidePanelWidget::togglePanel, m_panel, &UtilityPanel::toggle);
-  sidePanel->colorChanged(m_context.color);
-  sidePanel->thicknessChanged(m_context.thickness);
-  m_panel->pushWidget(sidePanel);
-  m_panel->pushWidget(new QUndoView(&m_undoStack, this));
+            &CaptureWidget::setDrawThickness);
+    connect(this,
+            &CaptureWidget::colorChanged,
+            sidePanel,
+            &SidePanelWidget::updateColor);
+    connect(this,
+            &CaptureWidget::thicknessChanged,
+            sidePanel,
+            &SidePanelWidget::updateThickness);
+    connect(
+      sidePanel, &SidePanelWidget::togglePanel, m_panel, &UtilityPanel::toggle);
+    sidePanel->colorChanged(m_context.color);
+    sidePanel->thicknessChanged(m_context.thickness);
+    m_panel->pushWidget(sidePanel);
+    m_panel->pushWidget(new QUndoView(&m_undoStack, this));
 }
 
-void
-CaptureWidget::initSelection()
+void CaptureWidget::initSelection()
 {
-  m_selection = new SelectionWidget(m_uiColor, this);
-  connect(m_selection, &SelectionWidget::animationEnded, this, [this]() {
-    this->m_buttonHandler->updatePosition(this->m_selection->geometry());
-  });
-  m_selection->setVisible(false);
-  m_selection->setGeometry(QRect());
+    m_selection = new SelectionWidget(m_uiColor, this);
+    connect(m_selection, &SelectionWidget::animationEnded, this, [this]() {
+        this->m_buttonHandler->updatePosition(this->m_selection->geometry());
+    });
+    m_selection->setVisible(false);
+    m_selection->setGeometry(QRect());
 }
 
-void
-CaptureWidget::setState(CaptureToolButton* b)
+void CaptureWidget::setState(CaptureToolButton* b)
 {
-  if (!b) {
-    return;
-  }
-  if (m_toolWidget) {
-    m_toolWidget->deleteLater();
-    if (m_activeTool->isValid()) {
-      pushToolToStack();
+    if (!b) {
+        return;
+    }
+    if (m_toolWidget) {
+        m_toolWidget->deleteLater();
+        if (m_activeTool->isValid()) {
+            pushToolToStack();
+        }
     }
-  }
-  if (m_activeButton != b) {
-    processTool(b->tool());
-  }
-  // Only close activated from button
-  if (b->tool()->closeOnButtonPressed()) {
-    close();
-  }
-
-  if (b->tool()->isSelectable()) {
     if (m_activeButton != b) {
-      QWidget* confW = b->tool()->configurationWidget();
-      m_panel->addToolWidget(confW);
-      if (m_activeButton) {
-        m_activeButton->setColor(m_uiColor);
-      }
-      m_activeButton = b;
-      m_activeButton->setColor(m_contrastUiColor);
-    } else if (m_activeButton) {
-      m_panel->clearToolWidget();
-      m_activeButton->setColor(m_uiColor);
-      m_activeButton = nullptr;
+        processTool(b->tool());
+    }
+    // Only close activated from button
+    if (b->tool()->closeOnButtonPressed()) {
+        close();
+    }
+
+    if (b->tool()->isSelectable()) {
+        if (m_activeButton != b) {
+            QWidget* confW = b->tool()->configurationWidget();
+            m_panel->addToolWidget(confW);
+            if (m_activeButton) {
+                m_activeButton->setColor(m_uiColor);
+            }
+            m_activeButton = b;
+            m_activeButton->setColor(m_contrastUiColor);
+        } else if (m_activeButton) {
+            m_panel->clearToolWidget();
+            m_activeButton->setColor(m_uiColor);
+            m_activeButton = nullptr;
+        }
+        update(); // clear mouse preview
     }
-    update(); // clear mouse preview
-  }
 }
 
-void
-CaptureWidget::processTool(CaptureTool* t)
+void CaptureWidget::processTool(CaptureTool* t)
 {
-  auto backup = m_activeTool;
-  // The tool is active during the pressed().
-  m_activeTool = t;
-  t->pressed(m_context);
-  m_activeTool = backup;
+    auto backup = m_activeTool;
+    // The tool is active during the pressed().
+    m_activeTool = t;
+    t->pressed(m_context);
+    m_activeTool = backup;
 }
 
-void
-CaptureWidget::handleButtonSignal(CaptureTool::Request r)
+void CaptureWidget::handleButtonSignal(CaptureTool::Request r)
 {
-  switch (r) {
-    case CaptureTool::REQ_CLEAR_MODIFICATIONS:
-      m_undoStack.setIndex(0);
-      update();
-      break;
-
-    case CaptureTool::REQ_INCREMENT_CIRCLE_COUNT:
-      incrementCircleCount();
-      break;
-
-    case CaptureTool::REQ_DECREMENT_CIRCLE_COUNT:
-      decrementCircleCount();
-      break;
-
-    case CaptureTool::REQ_CLOSE_GUI:
-      close();
-      break;
-    case CaptureTool::REQ_HIDE_GUI:
-      hide();
-      break;
-    case CaptureTool::REQ_HIDE_SELECTION:
-      m_newSelection = true;
-      m_selection->setVisible(false);
-      updateCursor();
-      break;
-    case CaptureTool::REQ_SELECT_ALL:
-      m_selection->setGeometryAnimated(rect());
-      break;
-    case CaptureTool::REQ_UNDO_MODIFICATION:
-      m_undoStack.undo();
-      break;
-    case CaptureTool::REQ_REDO_MODIFICATION:
-      if (m_undoStack.redoText() == "Circle Counter") {
-        this->incrementCircleCount();
-      }
-      m_undoStack.redo();
-      break;
-    case CaptureTool::REQ_REDRAW:
-      update();
-      break;
-    case CaptureTool::REQ_TOGGLE_SIDEBAR:
-      m_panel->toggle();
-      break;
-    case CaptureTool::REQ_SHOW_COLOR_PICKER:
-      // TODO
-      break;
-    case CaptureTool::REQ_MOVE_MODE:
-      setState(m_activeButton); // Disable the actual button
-      break;
-    case CaptureTool::REQ_CAPTURE_DONE_OK:
-      m_captureDone = true;
-      break;
-    case CaptureTool::REQ_ADD_CHILD_WIDGET:
-      if (!m_activeTool) {
-        break;
-      }
-      if (m_toolWidget) {
-        m_toolWidget->deleteLater();
-      }
-      m_toolWidget = m_activeTool->widget();
-      if (m_toolWidget) {
-        makeChild(m_toolWidget);
-        m_toolWidget->move(m_context.mousePos);
-        m_toolWidget->show();
-        m_toolWidget->setFocus();
-      }
-      break;
-    case CaptureTool::REQ_ADD_CHILD_WINDOW:
-      if (!m_activeTool) {
-        break;
-      } else {
-        QWidget* w = m_activeTool->widget();
-        connect(this, &CaptureWidget::destroyed, w, &QWidget::deleteLater);
-        w->show();
-      }
-      break;
-    case CaptureTool::REQ_ADD_EXTERNAL_WIDGETS:
-      if (!m_activeTool) {
-        break;
-      } else {
-        QWidget* w = m_activeTool->widget();
-        w->setAttribute(Qt::WA_DeleteOnClose);
-        w->show();
-      }
-      break;
-    default:
-      break;
-  }
+    switch (r) {
+        case CaptureTool::REQ_CLEAR_MODIFICATIONS:
+            m_undoStack.setIndex(0);
+            update();
+            break;
+
+        case CaptureTool::REQ_INCREMENT_CIRCLE_COUNT:
+            incrementCircleCount();
+            break;
+
+        case CaptureTool::REQ_DECREMENT_CIRCLE_COUNT:
+            decrementCircleCount();
+            break;
+
+        case CaptureTool::REQ_CLOSE_GUI:
+            close();
+            break;
+        case CaptureTool::REQ_HIDE_GUI:
+            hide();
+            break;
+        case CaptureTool::REQ_HIDE_SELECTION:
+            m_newSelection = true;
+            m_selection->setVisible(false);
+            updateCursor();
+            break;
+        case CaptureTool::REQ_SELECT_ALL:
+            m_selection->setGeometryAnimated(rect());
+            break;
+        case CaptureTool::REQ_UNDO_MODIFICATION:
+            m_undoStack.undo();
+            break;
+        case CaptureTool::REQ_REDO_MODIFICATION:
+            if (m_undoStack.redoText() == "Circle Counter") {
+                this->incrementCircleCount();
+            }
+            m_undoStack.redo();
+            break;
+        case CaptureTool::REQ_REDRAW:
+            update();
+            break;
+        case CaptureTool::REQ_TOGGLE_SIDEBAR:
+            m_panel->toggle();
+            break;
+        case CaptureTool::REQ_SHOW_COLOR_PICKER:
+            // TODO
+            break;
+        case CaptureTool::REQ_MOVE_MODE:
+            setState(m_activeButton); // Disable the actual button
+            break;
+        case CaptureTool::REQ_CAPTURE_DONE_OK:
+            m_captureDone = true;
+            break;
+        case CaptureTool::REQ_ADD_CHILD_WIDGET:
+            if (!m_activeTool) {
+                break;
+            }
+            if (m_toolWidget) {
+                m_toolWidget->deleteLater();
+            }
+            m_toolWidget = m_activeTool->widget();
+            if (m_toolWidget) {
+                makeChild(m_toolWidget);
+                m_toolWidget->move(m_context.mousePos);
+                m_toolWidget->show();
+                m_toolWidget->setFocus();
+            }
+            break;
+        case CaptureTool::REQ_ADD_CHILD_WINDOW:
+            if (!m_activeTool) {
+                break;
+            } else {
+                QWidget* w = m_activeTool->widget();
+                connect(
+                  this, &CaptureWidget::destroyed, w, &QWidget::deleteLater);
+                w->show();
+            }
+            break;
+        case CaptureTool::REQ_ADD_EXTERNAL_WIDGETS:
+            if (!m_activeTool) {
+                break;
+            } else {
+                QWidget* w = m_activeTool->widget();
+                w->setAttribute(Qt::WA_DeleteOnClose);
+                w->show();
+            }
+            break;
+        default:
+            break;
+    }
 }
 
-void
-CaptureWidget::setDrawColor(const QColor& c)
+void CaptureWidget::setDrawColor(const QColor& c)
 {
-  m_context.color = c;
-  ConfigHandler().setDrawColor(m_context.color);
-  emit colorChanged(c);
+    m_context.color = c;
+    ConfigHandler().setDrawColor(m_context.color);
+    emit colorChanged(c);
 }
 
-void
-CaptureWidget::incrementCircleCount()
+void CaptureWidget::incrementCircleCount()
 {
-  m_context.circleCount++;
+    m_context.circleCount++;
 }
 
-void
-CaptureWidget::decrementCircleCount()
+void CaptureWidget::decrementCircleCount()
 {
-  m_context.circleCount--;
+    m_context.circleCount--;
 }
 
-void
-CaptureWidget::setDrawThickness(const int& t)
+void CaptureWidget::setDrawThickness(const int& t)
 {
-  m_context.thickness = qBound(0, t, 100);
-  ConfigHandler().setdrawThickness(m_context.thickness);
-  emit thicknessChanged(m_context.thickness);
+    m_context.thickness = qBound(0, t, 100);
+    ConfigHandler().setdrawThickness(m_context.thickness);
+    emit thicknessChanged(m_context.thickness);
 }
 
-void
-CaptureWidget::leftResize()
+void CaptureWidget::leftResize()
 {
-  if (m_selection->isVisible() &&
-      m_selection->geometry().right() > m_selection->geometry().left()) {
-    m_selection->setGeometry(m_selection->geometry() + QMargins(0, 0, -1, 0));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    updateSizeIndicator();
-    update();
-  }
+    if (m_selection->isVisible() &&
+        m_selection->geometry().right() > m_selection->geometry().left()) {
+        m_selection->setGeometry(m_selection->geometry() +
+                                 QMargins(0, 0, -1, 0));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        updateSizeIndicator();
+        update();
+    }
 }
 
-void
-CaptureWidget::rightResize()
+void CaptureWidget::rightResize()
 {
-  if (m_selection->isVisible() &&
-      m_selection->geometry().right() < rect().right()) {
-    m_selection->setGeometry(m_selection->geometry() + QMargins(0, 0, 1, 0));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    updateSizeIndicator();
-    update();
-  }
+    if (m_selection->isVisible() &&
+        m_selection->geometry().right() < rect().right()) {
+        m_selection->setGeometry(m_selection->geometry() +
+                                 QMargins(0, 0, 1, 0));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        updateSizeIndicator();
+        update();
+    }
 }
 
-void
-CaptureWidget::upResize()
+void CaptureWidget::upResize()
 {
-  if (m_selection->isVisible() &&
-      m_selection->geometry().bottom() > m_selection->geometry().top()) {
-    m_selection->setGeometry(m_selection->geometry() + QMargins(0, 0, 0, -1));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    updateSizeIndicator();
-    update();
-  }
+    if (m_selection->isVisible() &&
+        m_selection->geometry().bottom() > m_selection->geometry().top()) {
+        m_selection->setGeometry(m_selection->geometry() +
+                                 QMargins(0, 0, 0, -1));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        updateSizeIndicator();
+        update();
+    }
 }
 
-void
-CaptureWidget::downResize()
+void CaptureWidget::downResize()
 {
-  if (m_selection->isVisible() &&
-      m_selection->geometry().bottom() < rect().bottom()) {
-    m_selection->setGeometry(m_selection->geometry() + QMargins(0, 0, 0, 1));
-    QRect newGeometry = m_selection->geometry().intersected(rect());
-    m_context.selection = extendedRect(&newGeometry);
-    m_buttonHandler->updatePosition(m_selection->geometry());
-    updateSizeIndicator();
-    update();
-  }
+    if (m_selection->isVisible() &&
+        m_selection->geometry().bottom() < rect().bottom()) {
+        m_selection->setGeometry(m_selection->geometry() +
+                                 QMargins(0, 0, 0, 1));
+        QRect newGeometry = m_selection->geometry().intersected(rect());
+        m_context.selection = extendedRect(&newGeometry);
+        m_buttonHandler->updatePosition(m_selection->geometry());
+        updateSizeIndicator();
+        update();
+    }
 }
 
-void
-CaptureWidget::initShortcuts()
+void CaptureWidget::initShortcuts()
 {
-  new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close()));
-  new QShortcut(
-    QKeySequence(Qt::CTRL + Qt::Key_S), this, SLOT(saveScreenshot()));
-  new QShortcut(
-    QKeySequence(Qt::CTRL + Qt::Key_C), this, SLOT(copyScreenshot()));
-  new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Z), this, SLOT(undo()));
-  new QShortcut(
-    QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_Z), this, SLOT(redo()));
-  new QShortcut(
-    QKeySequence(Qt::SHIFT + Qt::Key_Right), this, SLOT(rightResize()));
-  new QShortcut(
-    QKeySequence(Qt::SHIFT + Qt::Key_Left), this, SLOT(leftResize()));
-  new QShortcut(QKeySequence(Qt::SHIFT + Qt::Key_Up), this, SLOT(upResize()));
-  new QShortcut(
-    QKeySequence(Qt::SHIFT + Qt::Key_Down), this, SLOT(downResize()));
-  new QShortcut(Qt::Key_Space, this, SLOT(togglePanel()));
-  new QShortcut(Qt::Key_Escape, this, SLOT(deleteToolwidgetOrClose()));
-  new QShortcut(Qt::Key_Return, this, SLOT(copyScreenshot()));
-  new QShortcut(Qt::Key_Enter, this, SLOT(copyScreenshot()));
+    new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close()));
+    new QShortcut(
+      QKeySequence(Qt::CTRL + Qt::Key_S), this, SLOT(saveScreenshot()));
+    new QShortcut(
+      QKeySequence(Qt::CTRL + Qt::Key_C), this, SLOT(copyScreenshot()));
+    new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Z), this, SLOT(undo()));
+    new QShortcut(
+      QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_Z), this, SLOT(redo()));
+    new QShortcut(
+      QKeySequence(Qt::SHIFT + Qt::Key_Right), this, SLOT(rightResize()));
+    new QShortcut(
+      QKeySequence(Qt::SHIFT + Qt::Key_Left), this, SLOT(leftResize()));
+    new QShortcut(QKeySequence(Qt::SHIFT + Qt::Key_Up), this, SLOT(upResize()));
+    new QShortcut(
+      QKeySequence(Qt::SHIFT + Qt::Key_Down), this, SLOT(downResize()));
+    new QShortcut(Qt::Key_Space, this, SLOT(togglePanel()));
+    new QShortcut(Qt::Key_Escape, this, SLOT(deleteToolwidgetOrClose()));
+    new QShortcut(Qt::Key_Return, this, SLOT(copyScreenshot()));
+    new QShortcut(Qt::Key_Enter, this, SLOT(copyScreenshot()));
 }
 
-void
-CaptureWidget::updateSizeIndicator()
+void CaptureWidget::updateSizeIndicator()
 {
-  if (m_sizeIndButton) {
-    const QRect& selection = extendedSelection();
-    m_sizeIndButton->setText(
-      QStringLiteral("%1\n%2").arg(selection.width()).arg(selection.height()));
-  }
+    if (m_sizeIndButton) {
+        const QRect& selection = extendedSelection();
+        m_sizeIndButton->setText(QStringLiteral("%1\n%2")
+                                   .arg(selection.width())
+                                   .arg(selection.height()));
+    }
 }
 
-void
-CaptureWidget::updateCursor()
+void CaptureWidget::updateCursor()
 {
-  if (m_rightClick) {
-    setCursor(Qt::ArrowCursor);
-  } else if (m_grabbing) {
-    setCursor(Qt::ClosedHandCursor);
-  } else if (!m_activeButton) {
-    using sw = SelectionWidget;
-    if (m_mouseOverHandle != sw::NO_SIDE) {
-      // cursor on the handlers
-      switch (m_mouseOverHandle) {
-        case sw::TOPLEFT_SIDE:
-        case sw::BOTTONRIGHT_SIDE:
-          setCursor(Qt::SizeFDiagCursor);
-          break;
-        case sw::TOPRIGHT_SIDE:
-        case sw::BOTTONLEFT_SIDE:
-          setCursor(Qt::SizeBDiagCursor);
-          break;
-        case sw::LEFT_SIDE:
-        case sw::RIGHT_SIDE:
-          setCursor(Qt::SizeHorCursor);
-          break;
-        case sw::TOP_SIDE:
-        case sw::BOTTON_SIDE:
-          setCursor(Qt::SizeVerCursor);
-          break;
-        default:
-          break;
-      }
-    } else if (m_selection->isVisible() &&
-               m_selection->geometry().contains(m_context.mousePos)) {
-      setCursor(Qt::OpenHandCursor);
+    if (m_rightClick) {
+        setCursor(Qt::ArrowCursor);
+    } else if (m_grabbing) {
+        setCursor(Qt::ClosedHandCursor);
+    } else if (!m_activeButton) {
+        using sw = SelectionWidget;
+        if (m_mouseOverHandle != sw::NO_SIDE) {
+            // cursor on the handlers
+            switch (m_mouseOverHandle) {
+                case sw::TOPLEFT_SIDE:
+                case sw::BOTTONRIGHT_SIDE:
+                    setCursor(Qt::SizeFDiagCursor);
+                    break;
+                case sw::TOPRIGHT_SIDE:
+                case sw::BOTTONLEFT_SIDE:
+                    setCursor(Qt::SizeBDiagCursor);
+                    break;
+                case sw::LEFT_SIDE:
+                case sw::RIGHT_SIDE:
+                    setCursor(Qt::SizeHorCursor);
+                    break;
+                case sw::TOP_SIDE:
+                case sw::BOTTON_SIDE:
+                    setCursor(Qt::SizeVerCursor);
+                    break;
+                default:
+                    break;
+            }
+        } else if (m_selection->isVisible() &&
+                   m_selection->geometry().contains(m_context.mousePos)) {
+            setCursor(Qt::OpenHandCursor);
+        } else {
+            setCursor(Qt::CrossCursor);
+        }
     } else {
-      setCursor(Qt::CrossCursor);
+        setCursor(Qt::CrossCursor);
     }
-  } else {
-    setCursor(Qt::CrossCursor);
-  }
 }
 
-void
-CaptureWidget::pushToolToStack()
+void CaptureWidget::pushToolToStack()
 {
-  auto mod = new ModificationCommand(&m_context.screenshot, m_activeTool);
-  disconnect(this,
-             &CaptureWidget::colorChanged,
-             m_activeTool,
-             &CaptureTool::colorChanged);
-  disconnect(this,
-             &CaptureWidget::thicknessChanged,
-             m_activeTool,
-             &CaptureTool::thicknessChanged);
-  if (m_panel->toolWidget()) {
-    disconnect(m_panel->toolWidget(), nullptr, m_activeTool, nullptr);
-  }
-  m_undoStack.push(mod);
-  m_activeTool = nullptr;
+    auto mod = new ModificationCommand(&m_context.screenshot, m_activeTool);
+    disconnect(this,
+               &CaptureWidget::colorChanged,
+               m_activeTool,
+               &CaptureTool::colorChanged);
+    disconnect(this,
+               &CaptureWidget::thicknessChanged,
+               m_activeTool,
+               &CaptureTool::thicknessChanged);
+    if (m_panel->toolWidget()) {
+        disconnect(m_panel->toolWidget(), nullptr, m_activeTool, nullptr);
+    }
+    m_undoStack.push(mod);
+    m_activeTool = nullptr;
 }
 
-void
-CaptureWidget::makeChild(QWidget* w)
+void CaptureWidget::makeChild(QWidget* w)
 {
-  w->setParent(this);
-  w->installEventFilter(m_eventFilter);
+    w->setParent(this);
+    w->installEventFilter(m_eventFilter);
 }
 
-void
-CaptureWidget::togglePanel()
+void CaptureWidget::togglePanel()
 {
-  m_panel->toggle();
+    m_panel->toggle();
 }
 
-void
-CaptureWidget::childEnter()
+void CaptureWidget::childEnter()
 {
-  m_previewEnabled = false;
-  update();
+    m_previewEnabled = false;
+    update();
 }
 
-void
-CaptureWidget::childLeave()
+void CaptureWidget::childLeave()
 {
-  m_previewEnabled = true;
-  update();
+    m_previewEnabled = true;
+    update();
 }
 
-void
-CaptureWidget::copyScreenshot()
+void CaptureWidget::copyScreenshot()
 {
-  m_captureDone = true;
-  ScreenshotSaver().saveToClipboard(pixmap());
-  close();
+    m_captureDone = true;
+    ScreenshotSaver().saveToClipboard(pixmap());
+    close();
 }
 
-void
-CaptureWidget::saveScreenshot()
+void CaptureWidget::saveScreenshot()
 {
-  m_captureDone = true;
-  hide();
-  if (m_context.savePath.isEmpty()) {
-    ScreenshotSaver().saveToFilesystemGUI(pixmap());
-  } else {
-    ScreenshotSaver().saveToFilesystem(pixmap(), m_context.savePath, "");
-  }
-  close();
+    m_captureDone = true;
+    hide();
+    if (m_context.savePath.isEmpty()) {
+        ScreenshotSaver().saveToFilesystemGUI(pixmap());
+    } else {
+        ScreenshotSaver().saveToFilesystem(pixmap(), m_context.savePath, "");
+    }
+    close();
 }
 
-void
-CaptureWidget::undo()
+void CaptureWidget::undo()
 {
-  m_undoStack.undo();
+    m_undoStack.undo();
 }
 
-void
-CaptureWidget::redo()
+void CaptureWidget::redo()
 {
-  m_undoStack.redo();
+    m_undoStack.redo();
 }
 
-QRect
-CaptureWidget::extendedSelection() const
+QRect CaptureWidget::extendedSelection() const
 {
-  if (!m_selection->isVisible())
-    return QRect();
-  QRect r = m_selection->geometry();
-  return extendedRect(&r);
+    if (!m_selection->isVisible())
+        return QRect();
+    QRect r = m_selection->geometry();
+    return extendedRect(&r);
 }
 
-QRect
-CaptureWidget::extendedRect(QRect* r) const
+QRect CaptureWidget::extendedRect(QRect* r) const
 {
-  auto devicePixelRatio = m_context.screenshot.devicePixelRatio();
-  return QRect(r->left() * devicePixelRatio,
-               r->top() * devicePixelRatio,
-               r->width() * devicePixelRatio,
-               r->height() * devicePixelRatio);
+    auto devicePixelRatio = m_context.screenshot.devicePixelRatio();
+    return QRect(r->left() * devicePixelRatio,
+                 r->top() * devicePixelRatio,
+                 r->width() * devicePixelRatio,
+                 r->height() * devicePixelRatio);
 }
diff --git a/src/widgets/capture/capturewidget.h b/src/widgets/capture/capturewidget.h
index a7afee4a..7a56d3dc 100644
--- a/src/widgets/capture/capturewidget.h
+++ b/src/widgets/capture/capturewidget.h
@@ -49,112 +49,112 @@ class HoverEventFilter;
 
 class CaptureWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  explicit CaptureWidget(const uint id = 0,
-                         const QString& savePath = QString(),
-                         bool fullScreen = true,
-                         QWidget* parent = nullptr);
-  ~CaptureWidget();
+    explicit CaptureWidget(const uint id = 0,
+                           const QString& savePath = QString(),
+                           bool fullScreen = true,
+                           QWidget* parent = nullptr);
+    ~CaptureWidget();
 
-  void updateButtons();
-  QPixmap pixmap();
+    void updateButtons();
+    QPixmap pixmap();
 
 public slots:
-  void deleteToolwidgetOrClose();
+    void deleteToolwidgetOrClose();
 
 signals:
-  void captureTaken(uint id, QPixmap p);
-  void captureFailed(uint id);
-  void colorChanged(const QColor& c);
-  void thicknessChanged(const int thickness);
+    void captureTaken(uint id, QPixmap p);
+    void captureFailed(uint id);
+    void colorChanged(const QColor& c);
+    void thicknessChanged(const int thickness);
 
 private slots:
 
-  // TODO replace with tools
-  void copyScreenshot();
-  void saveScreenshot();
-  void undo();
-  void redo();
-  void togglePanel();
-  void childEnter();
-  void childLeave();
-
-  void leftResize();
-  void rightResize();
-  void upResize();
-  void downResize();
-
-  void setState(CaptureToolButton* b);
-  void processTool(CaptureTool* t);
-  void handleButtonSignal(CaptureTool::Request r);
-  void setDrawColor(const QColor& c);
-  void setDrawThickness(const int& t);
-  void incrementCircleCount();
-  void decrementCircleCount();
+    // TODO replace with tools
+    void copyScreenshot();
+    void saveScreenshot();
+    void undo();
+    void redo();
+    void togglePanel();
+    void childEnter();
+    void childLeave();
+
+    void leftResize();
+    void rightResize();
+    void upResize();
+    void downResize();
+
+    void setState(CaptureToolButton* b);
+    void processTool(CaptureTool* t);
+    void handleButtonSignal(CaptureTool::Request r);
+    void setDrawColor(const QColor& c);
+    void setDrawThickness(const int& t);
+    void incrementCircleCount();
+    void decrementCircleCount();
 
 protected:
-  void paintEvent(QPaintEvent*);
-  void mousePressEvent(QMouseEvent*);
-  void mouseMoveEvent(QMouseEvent*);
-  void mouseReleaseEvent(QMouseEvent*);
-  void keyPressEvent(QKeyEvent*);
-  void keyReleaseEvent(QKeyEvent*);
-  void wheelEvent(QWheelEvent*);
-  void resizeEvent(QResizeEvent*);
-  void moveEvent(QMoveEvent*);
-
-  // Context information
-  CaptureContext m_context;
-
-  // Main ui color
-  QColor m_uiColor;
-  // Secondary ui color
-  QColor m_contrastUiColor;
-
-  // Outside selection opacity
-  int m_opacity;
-
-  // utility flags
-  bool m_mouseIsClicked;
-  bool m_rightClick;
-  bool m_newSelection;
-  bool m_grabbing;
-  bool m_showInitialMsg;
-  bool m_captureDone;
-  bool m_previewEnabled;
-  bool m_adjustmentButtonPressed;
+    void paintEvent(QPaintEvent*);
+    void mousePressEvent(QMouseEvent*);
+    void mouseMoveEvent(QMouseEvent*);
+    void mouseReleaseEvent(QMouseEvent*);
+    void keyPressEvent(QKeyEvent*);
+    void keyReleaseEvent(QKeyEvent*);
+    void wheelEvent(QWheelEvent*);
+    void resizeEvent(QResizeEvent*);
+    void moveEvent(QMoveEvent*);
+
+    // Context information
+    CaptureContext m_context;
+
+    // Main ui color
+    QColor m_uiColor;
+    // Secondary ui color
+    QColor m_contrastUiColor;
+
+    // Outside selection opacity
+    int m_opacity;
+
+    // utility flags
+    bool m_mouseIsClicked;
+    bool m_rightClick;
+    bool m_newSelection;
+    bool m_grabbing;
+    bool m_showInitialMsg;
+    bool m_captureDone;
+    bool m_previewEnabled;
+    bool m_adjustmentButtonPressed;
 
 private:
-  void initContext(const QString& savePath, bool fullscreen);
-  void initPanel();
-  void initSelection();
-  void initShortcuts();
-  void updateSizeIndicator();
-  void updateCursor();
-  void pushToolToStack();
-  void makeChild(QWidget* w);
-
-  QRect extendedSelection() const;
-  QRect extendedRect(QRect* r) const;
-
-  QUndoStack m_undoStack;
-  QPointer<CaptureToolButton> m_sizeIndButton;
-  // Last pressed button
-  QPointer<CaptureToolButton> m_activeButton;
-  QPointer<CaptureTool> m_activeTool;
-  QPointer<QWidget> m_toolWidget;
-
-  ButtonHandler* m_buttonHandler;
-  UtilityPanel* m_panel;
-  ColorPicker* m_colorPicker;
-  ConfigHandler m_config;
-  NotifierBox* m_notifierBox;
-  HoverEventFilter* m_eventFilter;
-  SelectionWidget* m_selection;
-
-  QPoint m_dragStartPoint;
-  SelectionWidget::SideType m_mouseOverHandle;
-  uint m_id;
+    void initContext(const QString& savePath, bool fullscreen);
+    void initPanel();
+    void initSelection();
+    void initShortcuts();
+    void updateSizeIndicator();
+    void updateCursor();
+    void pushToolToStack();
+    void makeChild(QWidget* w);
+
+    QRect extendedSelection() const;
+    QRect extendedRect(QRect* r) const;
+
+    QUndoStack m_undoStack;
+    QPointer<CaptureToolButton> m_sizeIndButton;
+    // Last pressed button
+    QPointer<CaptureToolButton> m_activeButton;
+    QPointer<CaptureTool> m_activeTool;
+    QPointer<QWidget> m_toolWidget;
+
+    ButtonHandler* m_buttonHandler;
+    UtilityPanel* m_panel;
+    ColorPicker* m_colorPicker;
+    ConfigHandler m_config;
+    NotifierBox* m_notifierBox;
+    HoverEventFilter* m_eventFilter;
+    SelectionWidget* m_selection;
+
+    QPoint m_dragStartPoint;
+    SelectionWidget::SideType m_mouseOverHandle;
+    uint m_id;
 };
diff --git a/src/widgets/capture/colorpicker.cpp b/src/widgets/capture/colorpicker.cpp
index b3f34123..d3d2a503 100644
--- a/src/widgets/capture/colorpicker.cpp
+++ b/src/widgets/capture/colorpicker.cpp
@@ -24,102 +24,96 @@
 ColorPicker::ColorPicker(QWidget* parent)
   : QWidget(parent)
 {
-  ConfigHandler config;
-  m_colorList = config.getUserColors();
-  m_colorAreaSize = GlobalValues::buttonBaseSize() * 0.6;
-  setMouseTracking(true);
-  // save the color values in member variables for faster access
-  m_uiColor = config.uiMainColorValue();
-  m_drawColor = config.drawColorValue();
-  // extraSize represents the extra space needed for the highlight of the
-  // selected color.
-  const int extraSize = 6;
-  double radius = (m_colorList.size() * m_colorAreaSize / 1.3) / (3.141592);
-  resize(radius * 2 + m_colorAreaSize + extraSize,
-         radius * 2 + m_colorAreaSize + extraSize);
-  double degree = 360 / (m_colorList.size());
-  double degreeAcum = degree;
-  // this line is the radius of the circle which will be rotated to add
-  // the color components.
-  QLineF baseLine =
-    QLineF(QPoint(radius + extraSize / 2, radius + extraSize / 2),
-           QPoint(radius * 2, radius));
+    ConfigHandler config;
+    m_colorList = config.getUserColors();
+    m_colorAreaSize = GlobalValues::buttonBaseSize() * 0.6;
+    setMouseTracking(true);
+    // save the color values in member variables for faster access
+    m_uiColor = config.uiMainColorValue();
+    m_drawColor = config.drawColorValue();
+    // extraSize represents the extra space needed for the highlight of the
+    // selected color.
+    const int extraSize = 6;
+    double radius = (m_colorList.size() * m_colorAreaSize / 1.3) / (3.141592);
+    resize(radius * 2 + m_colorAreaSize + extraSize,
+           radius * 2 + m_colorAreaSize + extraSize);
+    double degree = 360 / (m_colorList.size());
+    double degreeAcum = degree;
+    // this line is the radius of the circle which will be rotated to add
+    // the color components.
+    QLineF baseLine =
+      QLineF(QPoint(radius + extraSize / 2, radius + extraSize / 2),
+             QPoint(radius * 2, radius));
 
-  for (int i = 0; i < m_colorList.size(); ++i) {
-    m_colorAreaList.append(
-      QRect(baseLine.x2(), baseLine.y2(), m_colorAreaSize, m_colorAreaSize));
-    baseLine.setAngle(degreeAcum);
-    degreeAcum += degree;
-  }
+    for (int i = 0; i < m_colorList.size(); ++i) {
+        m_colorAreaList.append(QRect(
+          baseLine.x2(), baseLine.y2(), m_colorAreaSize, m_colorAreaSize));
+        baseLine.setAngle(degreeAcum);
+        degreeAcum += degree;
+    }
 }
 
-QColor
-ColorPicker::drawColor()
+QColor ColorPicker::drawColor()
 {
-  return m_drawColor;
+    return m_drawColor;
 }
 
-void
-ColorPicker::show()
+void ColorPicker::show()
 {
-  grabMouse();
-  QWidget::show();
+    grabMouse();
+    QWidget::show();
 }
 
-void
-ColorPicker::hide()
+void ColorPicker::hide()
 {
-  releaseMouse();
-  QWidget::hide();
+    releaseMouse();
+    QWidget::hide();
 }
 
-void
-ColorPicker::paintEvent(QPaintEvent*)
+void ColorPicker::paintEvent(QPaintEvent*)
 {
-  QPainter painter(this);
-  painter.setRenderHint(QPainter::Antialiasing);
+    QPainter painter(this);
+    painter.setRenderHint(QPainter::Antialiasing);
 
-  QVector<QRect> rects = handleMask();
-  painter.setPen(QColor(Qt::black));
-  for (int i = 0; i < rects.size(); ++i) {
-    // draw the highlight when we have to draw the selected color
-    if (m_drawColor == QColor(m_colorList.at(i))) {
-      QColor c = QColor(m_uiColor);
-      c.setAlpha(155);
-      painter.setBrush(c);
-      c.setAlpha(100);
-      painter.setPen(c);
-      QRect highlight = rects.at(i);
-      highlight.moveTo(highlight.x() - 3, highlight.y() - 3);
-      highlight.setHeight(highlight.height() + 6);
-      highlight.setWidth(highlight.width() + 6);
-      painter.drawRoundedRect(highlight, 100, 100);
-      painter.setPen(QColor(Qt::black));
+    QVector<QRect> rects = handleMask();
+    painter.setPen(QColor(Qt::black));
+    for (int i = 0; i < rects.size(); ++i) {
+        // draw the highlight when we have to draw the selected color
+        if (m_drawColor == QColor(m_colorList.at(i))) {
+            QColor c = QColor(m_uiColor);
+            c.setAlpha(155);
+            painter.setBrush(c);
+            c.setAlpha(100);
+            painter.setPen(c);
+            QRect highlight = rects.at(i);
+            highlight.moveTo(highlight.x() - 3, highlight.y() - 3);
+            highlight.setHeight(highlight.height() + 6);
+            highlight.setWidth(highlight.width() + 6);
+            painter.drawRoundedRect(highlight, 100, 100);
+            painter.setPen(QColor(Qt::black));
+        }
+        painter.setBrush(QColor(m_colorList.at(i)));
+        painter.drawRoundedRect(rects.at(i), 100, 100);
     }
-    painter.setBrush(QColor(m_colorList.at(i)));
-    painter.drawRoundedRect(rects.at(i), 100, 100);
-  }
 }
 
-void
-ColorPicker::mouseMoveEvent(QMouseEvent* e)
+void ColorPicker::mouseMoveEvent(QMouseEvent* e)
 {
-  for (int i = 0; i < m_colorList.size(); ++i) {
-    if (m_colorAreaList.at(i).contains(e->pos())) {
-      m_drawColor = m_colorList.at(i);
-      emit colorSelected(m_drawColor);
-      update();
-      break;
+    for (int i = 0; i < m_colorList.size(); ++i) {
+        if (m_colorAreaList.at(i).contains(e->pos())) {
+            m_drawColor = m_colorList.at(i);
+            emit colorSelected(m_drawColor);
+            update();
+            break;
+        }
     }
-  }
 }
 
-QVector<QRect>
-ColorPicker::handleMask() const
+QVector<QRect> ColorPicker::handleMask() const
 {
-  QVector<QRect> areas;
-  for (const QRect& rect : m_colorAreaList) {
-    areas.append(rect);
-  }
-  return areas;
+    QVector<QRect> areas;
+    for (const QRect& rect : m_colorAreaList) {
+        areas.append(rect);
+    }
+    return areas;
 }
diff --git a/src/widgets/capture/colorpicker.h b/src/widgets/capture/colorpicker.h
index bbf98a75..ae16987c 100644
--- a/src/widgets/capture/colorpicker.h
+++ b/src/widgets/capture/colorpicker.h
@@ -21,28 +21,28 @@
 
 class ColorPicker : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit ColorPicker(QWidget* parent = nullptr);
+    explicit ColorPicker(QWidget* parent = nullptr);
 
-  QColor drawColor();
+    QColor drawColor();
 
-  void show();
-  void hide();
+    void show();
+    void hide();
 
 signals:
-  void colorSelected(QColor c);
+    void colorSelected(QColor c);
 
 protected:
-  void paintEvent(QPaintEvent*);
-  void mouseMoveEvent(QMouseEvent*);
+    void paintEvent(QPaintEvent*);
+    void mouseMoveEvent(QMouseEvent*);
 
-  QVector<QRect> handleMask() const;
+    QVector<QRect> handleMask() const;
 
 private:
-  int m_colorAreaSize;
-  QVector<QRect> m_colorAreaList;
-  QVector<QColor> m_colorList;
+    int m_colorAreaSize;
+    QVector<QRect> m_colorAreaList;
+    QVector<QColor> m_colorList;
 
-  QColor m_uiColor, m_drawColor;
+    QColor m_uiColor, m_drawColor;
 };
diff --git a/src/widgets/capture/hovereventfilter.cpp b/src/widgets/capture/hovereventfilter.cpp
index 32ad19db..48b995f5 100644
--- a/src/widgets/capture/hovereventfilter.cpp
+++ b/src/widgets/capture/hovereventfilter.cpp
@@ -30,19 +30,18 @@ HoverEventFilter::HoverEventFilter(QObject* parent)
   : QObject(parent)
 {}
 
-bool
-HoverEventFilter::eventFilter(QObject* watched, QEvent* event)
+bool HoverEventFilter::eventFilter(QObject* watched, QEvent* event)
 {
-  QEvent::Type t = event->type();
-  switch (t) {
-    case QEvent::Enter:
-      emit hoverIn(watched);
-      break;
-    case QEvent::Leave:
-      emit hoverOut(watched);
-      break;
-    default:
-      break;
-  }
-  return false;
+    QEvent::Type t = event->type();
+    switch (t) {
+        case QEvent::Enter:
+            emit hoverIn(watched);
+            break;
+        case QEvent::Leave:
+            emit hoverOut(watched);
+            break;
+        default:
+            break;
+    }
+    return false;
 }
diff --git a/src/widgets/capture/hovereventfilter.h b/src/widgets/capture/hovereventfilter.h
index 7a4c41cd..f71bc109 100644
--- a/src/widgets/capture/hovereventfilter.h
+++ b/src/widgets/capture/hovereventfilter.h
@@ -29,14 +29,14 @@
 
 class HoverEventFilter : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit HoverEventFilter(QObject* parent = nullptr);
+    explicit HoverEventFilter(QObject* parent = nullptr);
 
 signals:
-  void hoverIn(QObject*);
-  void hoverOut(QObject*);
+    void hoverIn(QObject*);
+    void hoverOut(QObject*);
 
 protected:
-  bool eventFilter(QObject* watched, QEvent* event);
+    bool eventFilter(QObject* watched, QEvent* event);
 };
diff --git a/src/widgets/capture/modificationcommand.cpp b/src/widgets/capture/modificationcommand.cpp
index 178d48b2..63adb2b2 100644
--- a/src/widgets/capture/modificationcommand.cpp
+++ b/src/widgets/capture/modificationcommand.cpp
@@ -22,19 +22,17 @@ ModificationCommand::ModificationCommand(QPixmap* p, CaptureTool* t)
   : m_pixmap(p)
   , m_tool(t)
 {
-  setText(t->name());
+    setText(t->name());
 }
 
-void
-ModificationCommand::undo()
+void ModificationCommand::undo()
 {
-  m_tool->undo(*m_pixmap);
+    m_tool->undo(*m_pixmap);
 }
 
-void
-ModificationCommand::redo()
+void ModificationCommand::redo()
 {
-  QPainter p(m_pixmap);
-  p.setRenderHint(QPainter::Antialiasing);
-  m_tool->process(p, *m_pixmap, true);
+    QPainter p(m_pixmap);
+    p.setRenderHint(QPainter::Antialiasing);
+    m_tool->process(p, *m_pixmap, true);
 }
diff --git a/src/widgets/capture/modificationcommand.h b/src/widgets/capture/modificationcommand.h
index c172d6fd..8c71af90 100644
--- a/src/widgets/capture/modificationcommand.h
+++ b/src/widgets/capture/modificationcommand.h
@@ -23,12 +23,12 @@
 class ModificationCommand : public QUndoCommand
 {
 public:
-  ModificationCommand(QPixmap*, CaptureTool*);
+    ModificationCommand(QPixmap*, CaptureTool*);
 
-  virtual void undo() override;
-  virtual void redo() override;
+    virtual void undo() override;
+    virtual void redo() override;
 
 private:
-  QPixmap* m_pixmap;
-  QScopedPointer<CaptureTool> m_tool;
+    QPixmap* m_pixmap;
+    QScopedPointer<CaptureTool> m_tool;
 };
diff --git a/src/widgets/capture/notifierbox.cpp b/src/widgets/capture/notifierbox.cpp
index 95b55553..906ef7ff 100644
--- a/src/widgets/capture/notifierbox.cpp
+++ b/src/widgets/capture/notifierbox.cpp
@@ -26,52 +26,48 @@
 NotifierBox::NotifierBox(QWidget* parent)
   : QWidget(parent)
 {
-  m_timer = new QTimer(this);
-  m_timer->setSingleShot(true);
-  m_timer->setInterval(1200);
-  connect(m_timer, &QTimer::timeout, this, &NotifierBox::hide);
-  m_bgColor = ConfigHandler().uiMainColorValue();
-  m_foregroundColor =
-    (ColorUtils::colorIsDark(m_bgColor) ? Qt::white : Qt::black);
-  m_bgColor.setAlpha(180);
-  const int size =
-    (GlobalValues::buttonBaseSize() + GlobalValues::buttonBaseSize() / 2) *
-    qApp->devicePixelRatio();
-  setFixedSize(QSize(size, size));
+    m_timer = new QTimer(this);
+    m_timer->setSingleShot(true);
+    m_timer->setInterval(1200);
+    connect(m_timer, &QTimer::timeout, this, &NotifierBox::hide);
+    m_bgColor = ConfigHandler().uiMainColorValue();
+    m_foregroundColor =
+      (ColorUtils::colorIsDark(m_bgColor) ? Qt::white : Qt::black);
+    m_bgColor.setAlpha(180);
+    const int size =
+      (GlobalValues::buttonBaseSize() + GlobalValues::buttonBaseSize() / 2) *
+      qApp->devicePixelRatio();
+    setFixedSize(QSize(size, size));
 }
 
-void
-NotifierBox::enterEvent(QEvent*)
+void NotifierBox::enterEvent(QEvent*)
 {
-  hide();
+    hide();
 }
 
-void
-NotifierBox::paintEvent(QPaintEvent*)
+void NotifierBox::paintEvent(QPaintEvent*)
 {
-  QPainter painter(this);
-  // draw Elipse
-  painter.setRenderHint(QPainter::Antialiasing);
-  painter.setBrush(QBrush(m_bgColor, Qt::SolidPattern));
-  painter.setPen(QPen(Qt::transparent));
-  painter.drawEllipse(rect());
-  // Draw the text:
-  painter.setPen(QPen(m_foregroundColor));
-  painter.drawText(rect(), Qt::AlignCenter, m_message);
+    QPainter painter(this);
+    // draw Elipse
+    painter.setRenderHint(QPainter::Antialiasing);
+    painter.setBrush(QBrush(m_bgColor, Qt::SolidPattern));
+    painter.setPen(QPen(Qt::transparent));
+    painter.drawEllipse(rect());
+    // Draw the text:
+    painter.setPen(QPen(m_foregroundColor));
+    painter.drawText(rect(), Qt::AlignCenter, m_message);
 }
 
-void
-NotifierBox::showMessage(const QString& msg)
+void NotifierBox::showMessage(const QString& msg)
 {
-  m_message = msg;
-  update();
-  show();
-  m_timer->start();
+    m_message = msg;
+    update();
+    show();
+    m_timer->start();
 }
 
-void
-NotifierBox::showColor(const QColor& color)
+void NotifierBox::showColor(const QColor& color)
 {
-  Q_UNUSED(color);
-  m_message = QLatin1String("");
+    Q_UNUSED(color);
+    m_message = QLatin1String("");
 }
diff --git a/src/widgets/capture/notifierbox.h b/src/widgets/capture/notifierbox.h
index d8b97030..f1e1a948 100644
--- a/src/widgets/capture/notifierbox.h
+++ b/src/widgets/capture/notifierbox.h
@@ -23,21 +23,21 @@ class QTimer;
 
 class NotifierBox : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit NotifierBox(QWidget* parent = nullptr);
+    explicit NotifierBox(QWidget* parent = nullptr);
 
 protected:
-  virtual void enterEvent(QEvent*);
-  virtual void paintEvent(QPaintEvent*);
+    virtual void enterEvent(QEvent*);
+    virtual void paintEvent(QPaintEvent*);
 
 public slots:
-  void showMessage(const QString& msg);
-  void showColor(const QColor& color);
+    void showMessage(const QString& msg);
+    void showColor(const QColor& color);
 
 private:
-  QTimer* m_timer;
-  QString m_message;
-  QColor m_bgColor;
-  QColor m_foregroundColor;
+    QTimer* m_timer;
+    QString m_message;
+    QColor m_bgColor;
+    QColor m_foregroundColor;
 };
diff --git a/src/widgets/capture/selectionwidget.cpp b/src/widgets/capture/selectionwidget.cpp
index 1ab4df30..a977bb1a 100644
--- a/src/widgets/capture/selectionwidget.cpp
+++ b/src/widgets/capture/selectionwidget.cpp
@@ -24,128 +24,119 @@ SelectionWidget::SelectionWidget(const QColor& c, QWidget* parent)
   : QWidget(parent)
   , m_color(c)
 {
-  m_animation = new QPropertyAnimation(this, "geometry", this);
-  m_animation->setEasingCurve(QEasingCurve::InOutQuad);
-  m_animation->setDuration(200);
-  connect(m_animation,
-          &QPropertyAnimation::finished,
-          this,
-          &SelectionWidget::animationEnded);
-
-  setAttribute(Qt::WA_TransparentForMouseEvents);
-  int sideVal = GlobalValues::buttonBaseSize() * 0.6;
-  int handleSide = sideVal / 2;
-  const QRect areaRect(0, 0, sideVal, sideVal);
-  const QRect handleRect(0, 0, handleSide, handleSide);
-  m_TLHandle = m_TRHandle = m_BLHandle = m_BRHandle = m_LHandle = m_THandle =
-    m_RHandle = m_BHandle = handleRect;
-  m_TLArea = m_TRArea = m_BLArea = m_BRArea = areaRect;
-
-  m_areaOffset = QPoint(-sideVal / 2, -sideVal / 2);
-  m_handleOffset = QPoint(-handleSide / 2, -handleSide / 2);
+    m_animation = new QPropertyAnimation(this, "geometry", this);
+    m_animation->setEasingCurve(QEasingCurve::InOutQuad);
+    m_animation->setDuration(200);
+    connect(m_animation,
+            &QPropertyAnimation::finished,
+            this,
+            &SelectionWidget::animationEnded);
+
+    setAttribute(Qt::WA_TransparentForMouseEvents);
+    int sideVal = GlobalValues::buttonBaseSize() * 0.6;
+    int handleSide = sideVal / 2;
+    const QRect areaRect(0, 0, sideVal, sideVal);
+    const QRect handleRect(0, 0, handleSide, handleSide);
+    m_TLHandle = m_TRHandle = m_BLHandle = m_BRHandle = m_LHandle = m_THandle =
+      m_RHandle = m_BHandle = handleRect;
+    m_TLArea = m_TRArea = m_BLArea = m_BRArea = areaRect;
+
+    m_areaOffset = QPoint(-sideVal / 2, -sideVal / 2);
+    m_handleOffset = QPoint(-handleSide / 2, -handleSide / 2);
 }
 
-SelectionWidget::SideType
-SelectionWidget::getMouseSide(const QPoint& point) const
+SelectionWidget::SideType SelectionWidget::getMouseSide(
+  const QPoint& point) const
 {
-  if (m_TLArea.contains(point)) {
-    return TOPLEFT_SIDE;
-  } else if (m_TRArea.contains(point)) {
-    return TOPRIGHT_SIDE;
-  } else if (m_BLArea.contains(point)) {
-    return BOTTONLEFT_SIDE;
-  } else if (m_BRArea.contains(point)) {
-    return BOTTONRIGHT_SIDE;
-  } else if (m_LArea.contains(point)) {
-    return LEFT_SIDE;
-  } else if (m_TArea.contains(point)) {
-    return TOP_SIDE;
-  } else if (m_RArea.contains(point)) {
-    return RIGHT_SIDE;
-  } else if (m_BArea.contains(point)) {
-    return BOTTON_SIDE;
-  } else {
-    return NO_SIDE;
-  }
+    if (m_TLArea.contains(point)) {
+        return TOPLEFT_SIDE;
+    } else if (m_TRArea.contains(point)) {
+        return TOPRIGHT_SIDE;
+    } else if (m_BLArea.contains(point)) {
+        return BOTTONLEFT_SIDE;
+    } else if (m_BRArea.contains(point)) {
+        return BOTTONRIGHT_SIDE;
+    } else if (m_LArea.contains(point)) {
+        return LEFT_SIDE;
+    } else if (m_TArea.contains(point)) {
+        return TOP_SIDE;
+    } else if (m_RArea.contains(point)) {
+        return RIGHT_SIDE;
+    } else if (m_BArea.contains(point)) {
+        return BOTTON_SIDE;
+    } else {
+        return NO_SIDE;
+    }
 }
 
-QVector<QRect>
-SelectionWidget::handlerAreas()
+QVector<QRect> SelectionWidget::handlerAreas()
 {
-  QVector<QRect> areas;
-  areas << m_TLHandle << m_TRHandle << m_BLHandle << m_BRHandle << m_LHandle
-        << m_THandle << m_RHandle << m_BHandle;
-  return areas;
+    QVector<QRect> areas;
+    areas << m_TLHandle << m_TRHandle << m_BLHandle << m_BRHandle << m_LHandle
+          << m_THandle << m_RHandle << m_BHandle;
+    return areas;
 }
 
-void
-SelectionWidget::setGeometryAnimated(const QRect& r)
+void SelectionWidget::setGeometryAnimated(const QRect& r)
 {
-  if (isVisible()) {
-    m_animation->setStartValue(geometry());
-    m_animation->setEndValue(r);
-    m_animation->start();
-  }
+    if (isVisible()) {
+        m_animation->setStartValue(geometry());
+        m_animation->setEndValue(r);
+        m_animation->start();
+    }
 }
 
-void
-SelectionWidget::saveGeometry()
+void SelectionWidget::saveGeometry()
 {
-  m_geometryBackup = geometry();
+    m_geometryBackup = geometry();
 }
 
-QRect
-SelectionWidget::savedGeometry()
+QRect SelectionWidget::savedGeometry()
 {
-  return m_geometryBackup;
+    return m_geometryBackup;
 }
 
-void
-SelectionWidget::paintEvent(QPaintEvent*)
+void SelectionWidget::paintEvent(QPaintEvent*)
 {
-  QPainter p(this);
-  p.setPen(m_color);
-  p.drawRect(rect() + QMargins(0, 0, -1, -1));
+    QPainter p(this);
+    p.setPen(m_color);
+    p.drawRect(rect() + QMargins(0, 0, -1, -1));
 }
 
-void
-SelectionWidget::resizeEvent(QResizeEvent*)
+void SelectionWidget::resizeEvent(QResizeEvent*)
 {
-  updateAreas();
+    updateAreas();
 }
 
-void
-SelectionWidget::moveEvent(QMoveEvent*)
+void SelectionWidget::moveEvent(QMoveEvent*)
 {
-  updateAreas();
+    updateAreas();
 }
 
-void
-SelectionWidget::updateColor(const QColor& c)
+void SelectionWidget::updateColor(const QColor& c)
 {
-  m_color = c;
+    m_color = c;
 }
 
-void
-SelectionWidget::updateAreas()
+void SelectionWidget::updateAreas()
 {
-  QRect r = rect();
-  m_TLArea.moveTo(m_areaOffset + pos());
-  m_TRArea.moveTo(r.topRight() + m_areaOffset + pos());
-  m_BLArea.moveTo(r.bottomLeft() + m_areaOffset + pos());
-  m_BRArea.moveTo(r.bottomRight() + m_areaOffset + pos());
-
-  m_LArea = QRect(m_TLArea.bottomLeft(), m_BLArea.topRight());
-  m_TArea = QRect(m_TLArea.topRight(), m_TRArea.bottomLeft());
-  m_RArea = QRect(m_TRArea.bottomLeft(), m_BRArea.topRight());
-  m_BArea = QRect(m_BLArea.topRight(), m_BRArea.bottomLeft());
-
-  m_TLHandle.moveTo(m_TLArea.center() + m_handleOffset);
-  m_BLHandle.moveTo(m_BLArea.center() + m_handleOffset);
-  m_TRHandle.moveTo(m_TRArea.center() + m_handleOffset);
-  m_BRHandle.moveTo(m_BRArea.center() + m_handleOffset);
-  m_LHandle.moveTo(m_LArea.center() + m_handleOffset);
-  m_THandle.moveTo(m_TArea.center() + m_handleOffset);
-  m_RHandle.moveTo(m_RArea.center() + m_handleOffset);
-  m_BHandle.moveTo(m_BArea.center() + m_handleOffset);
+    QRect r = rect();
+    m_TLArea.moveTo(m_areaOffset + pos());
+    m_TRArea.moveTo(r.topRight() + m_areaOffset + pos());
+    m_BLArea.moveTo(r.bottomLeft() + m_areaOffset + pos());
+    m_BRArea.moveTo(r.bottomRight() + m_areaOffset + pos());
+
+    m_LArea = QRect(m_TLArea.bottomLeft(), m_BLArea.topRight());
+    m_TArea = QRect(m_TLArea.topRight(), m_TRArea.bottomLeft());
+    m_RArea = QRect(m_TRArea.bottomLeft(), m_BRArea.topRight());
+    m_BArea = QRect(m_BLArea.topRight(), m_BRArea.bottomLeft());
+
+    m_TLHandle.moveTo(m_TLArea.center() + m_handleOffset);
+    m_BLHandle.moveTo(m_BLArea.center() + m_handleOffset);
+    m_TRHandle.moveTo(m_TRArea.center() + m_handleOffset);
+    m_BRHandle.moveTo(m_BRArea.center() + m_handleOffset);
+    m_LHandle.moveTo(m_LArea.center() + m_handleOffset);
+    m_THandle.moveTo(m_TArea.center() + m_handleOffset);
+    m_RHandle.moveTo(m_RArea.center() + m_handleOffset);
+    m_BHandle.moveTo(m_BArea.center() + m_handleOffset);
 }
diff --git a/src/widgets/capture/selectionwidget.h b/src/widgets/capture/selectionwidget.h
index b585aa27..5c95027e 100644
--- a/src/widgets/capture/selectionwidget.h
+++ b/src/widgets/capture/selectionwidget.h
@@ -23,58 +23,58 @@ class QPropertyAnimation;
 
 class SelectionWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  enum SideType
-  {
-    TOPLEFT_SIDE,
-    BOTTONLEFT_SIDE,
-    TOPRIGHT_SIDE,
-    BOTTONRIGHT_SIDE,
-    TOP_SIDE,
-    BOTTON_SIDE,
-    RIGHT_SIDE,
-    LEFT_SIDE,
-    NO_SIDE,
-  };
+    enum SideType
+    {
+        TOPLEFT_SIDE,
+        BOTTONLEFT_SIDE,
+        TOPRIGHT_SIDE,
+        BOTTONRIGHT_SIDE,
+        TOP_SIDE,
+        BOTTON_SIDE,
+        RIGHT_SIDE,
+        LEFT_SIDE,
+        NO_SIDE,
+    };
 
-  explicit SelectionWidget(const QColor& c, QWidget* parent = nullptr);
+    explicit SelectionWidget(const QColor& c, QWidget* parent = nullptr);
 
-  SideType getMouseSide(const QPoint& point) const;
-  QVector<QRect> handlerAreas();
+    SideType getMouseSide(const QPoint& point) const;
+    QVector<QRect> handlerAreas();
 
-  void setGeometryAnimated(const QRect& r);
-  void saveGeometry();
-  QRect savedGeometry();
+    void setGeometryAnimated(const QRect& r);
+    void saveGeometry();
+    QRect savedGeometry();
 
 protected:
-  void paintEvent(QPaintEvent*);
-  void resizeEvent(QResizeEvent*);
-  void moveEvent(QMoveEvent*);
+    void paintEvent(QPaintEvent*);
+    void resizeEvent(QResizeEvent*);
+    void moveEvent(QMoveEvent*);
 
 signals:
-  void animationEnded();
+    void animationEnded();
 
 public slots:
-  void updateColor(const QColor& c);
+    void updateColor(const QColor& c);
 
 private:
-  void updateAreas();
+    void updateAreas();
 
-  QPropertyAnimation* m_animation;
+    QPropertyAnimation* m_animation;
 
-  QColor m_color;
-  QPoint m_areaOffset;
-  QPoint m_handleOffset;
-  QRect m_geometryBackup;
+    QColor m_color;
+    QPoint m_areaOffset;
+    QPoint m_handleOffset;
+    QRect m_geometryBackup;
 
-  // naming convention for handles
-  // T top, B bottom, R Right, L left
-  // 2 letters: a corner
-  // 1 letter: the handle on the middle of the corresponding side
-  QRect m_TLHandle, m_TRHandle, m_BLHandle, m_BRHandle;
-  QRect m_LHandle, m_THandle, m_RHandle, m_BHandle;
+    // naming convention for handles
+    // T top, B bottom, R Right, L left
+    // 2 letters: a corner
+    // 1 letter: the handle on the middle of the corresponding side
+    QRect m_TLHandle, m_TRHandle, m_BLHandle, m_BRHandle;
+    QRect m_LHandle, m_THandle, m_RHandle, m_BHandle;
 
-  QRect m_TLArea, m_TRArea, m_BLArea, m_BRArea;
-  QRect m_LArea, m_TArea, m_RArea, m_BArea;
+    QRect m_TLArea, m_TRArea, m_BLArea, m_BRArea;
+    QRect m_LArea, m_TArea, m_RArea, m_BArea;
 };
diff --git a/src/widgets/capturelauncher.cpp b/src/widgets/capturelauncher.cpp
index 3f0d6dd7..1366b577 100644
--- a/src/widgets/capturelauncher.cpp
+++ b/src/widgets/capturelauncher.cpp
@@ -40,130 +40,126 @@ CaptureLauncher::CaptureLauncher(QWidget* parent)
   : QWidget(parent)
   , m_id(0)
 {
-  setAttribute(Qt::WA_DeleteOnClose);
-  connect(Controller::getInstance(),
-          &Controller::captureTaken,
-          this,
-          &CaptureLauncher::captureTaken);
-  connect(Controller::getInstance(),
-          &Controller::captureFailed,
-          this,
-          &CaptureLauncher::captureFailed);
-
-  m_imageLabel = new ImageLabel(this);
-  bool ok;
-  m_imageLabel->setScreenshot(ScreenGrabber().grabEntireDesktop(ok));
-  if (!ok) {
-  }
-  m_imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
-  connect(m_imageLabel,
-          &ImageLabel::dragInitiated,
-          this,
-          &CaptureLauncher::startDrag);
-
-  QGridLayout* layout = new QGridLayout(this);
-  layout->addWidget(m_imageLabel, 0, 0);
-
-  m_CaptureModeLabel = new QLabel(tr("<b>Capture Mode</b>"));
-
-  m_captureType = new QComboBox();
-  m_captureType->setMinimumWidth(240);
-  // TODO remember number
-  m_captureType->insertItem(
-    1, tr("Rectangular Region"), CaptureRequest::GRAPHICAL_MODE);
-  m_captureType->insertItem(
-    2, tr("Full Screen (All Monitors)"), CaptureRequest::FULLSCREEN_MODE);
-  // m_captureType->insertItem(3, tr("Single Screen"),
-  // CaptureRequest::SCREEN_MODE);
-
-  m_delaySpinBox = new QSpinBox();
-  m_delaySpinBox->setSingleStep(1.0);
-  m_delaySpinBox->setMinimum(0.0);
-  m_delaySpinBox->setMaximum(999.0);
-  m_delaySpinBox->setSpecialValueText(tr("No Delay"));
-  m_delaySpinBox->setMinimumWidth(160);
-  // with QT 5.7 qOverload<int>(&QSpinBox::valueChanged),
-  connect(m_delaySpinBox,
-          static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged),
-          this,
-          [this](int val) {
-            QString sufix = val == 1 ? tr(" second") : tr(" seconds");
-            this->m_delaySpinBox->setSuffix(sufix);
-          });
-
-  m_launchButton = new QPushButton(tr("Take new screenshot"));
-  m_launchButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
-  connect(m_launchButton,
-          &QPushButton::pressed,
-          this,
-          &CaptureLauncher::startCapture);
-  m_launchButton->setFocus();
-
-  QFormLayout* captureModeForm = new QFormLayout;
-  captureModeForm->addRow(tr("Area:"), m_captureType);
-  captureModeForm->addRow(tr("Delay:"), m_delaySpinBox);
-  captureModeForm->setContentsMargins(24, 0, 0, 0);
-
-  m_mainLayout = new QVBoxLayout();
-  m_mainLayout->addStretch(1);
-  m_mainLayout->addWidget(m_CaptureModeLabel);
-  m_mainLayout->addLayout(captureModeForm);
-  m_mainLayout->addStretch(10);
-  m_mainLayout->addWidget(m_launchButton, 1, Qt::AlignCenter);
-  m_mainLayout->setContentsMargins(10, 0, 0, 10);
-  layout->addLayout(m_mainLayout, 0, 1);
-  layout->setColumnMinimumWidth(0, 320);
-  layout->setColumnMinimumWidth(1, 320);
+    setAttribute(Qt::WA_DeleteOnClose);
+    connect(Controller::getInstance(),
+            &Controller::captureTaken,
+            this,
+            &CaptureLauncher::captureTaken);
+    connect(Controller::getInstance(),
+            &Controller::captureFailed,
+            this,
+            &CaptureLauncher::captureFailed);
+
+    m_imageLabel = new ImageLabel(this);
+    bool ok;
+    m_imageLabel->setScreenshot(ScreenGrabber().grabEntireDesktop(ok));
+    if (!ok) {
+    }
+    m_imageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    connect(m_imageLabel,
+            &ImageLabel::dragInitiated,
+            this,
+            &CaptureLauncher::startDrag);
+
+    QGridLayout* layout = new QGridLayout(this);
+    layout->addWidget(m_imageLabel, 0, 0);
+
+    m_CaptureModeLabel = new QLabel(tr("<b>Capture Mode</b>"));
+
+    m_captureType = new QComboBox();
+    m_captureType->setMinimumWidth(240);
+    // TODO remember number
+    m_captureType->insertItem(
+      1, tr("Rectangular Region"), CaptureRequest::GRAPHICAL_MODE);
+    m_captureType->insertItem(
+      2, tr("Full Screen (All Monitors)"), CaptureRequest::FULLSCREEN_MODE);
+    // m_captureType->insertItem(3, tr("Single Screen"),
+    // CaptureRequest::SCREEN_MODE);
+
+    m_delaySpinBox = new QSpinBox();
+    m_delaySpinBox->setSingleStep(1.0);
+    m_delaySpinBox->setMinimum(0.0);
+    m_delaySpinBox->setMaximum(999.0);
+    m_delaySpinBox->setSpecialValueText(tr("No Delay"));
+    m_delaySpinBox->setMinimumWidth(160);
+    // with QT 5.7 qOverload<int>(&QSpinBox::valueChanged),
+    connect(m_delaySpinBox,
+            static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged),
+            this,
+            [this](int val) {
+                QString sufix = val == 1 ? tr(" second") : tr(" seconds");
+                this->m_delaySpinBox->setSuffix(sufix);
+            });
+
+    m_launchButton = new QPushButton(tr("Take new screenshot"));
+    m_launchButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
+    connect(m_launchButton,
+            &QPushButton::pressed,
+            this,
+            &CaptureLauncher::startCapture);
+    m_launchButton->setFocus();
+
+    QFormLayout* captureModeForm = new QFormLayout;
+    captureModeForm->addRow(tr("Area:"), m_captureType);
+    captureModeForm->addRow(tr("Delay:"), m_delaySpinBox);
+    captureModeForm->setContentsMargins(24, 0, 0, 0);
+
+    m_mainLayout = new QVBoxLayout();
+    m_mainLayout->addStretch(1);
+    m_mainLayout->addWidget(m_CaptureModeLabel);
+    m_mainLayout->addLayout(captureModeForm);
+    m_mainLayout->addStretch(10);
+    m_mainLayout->addWidget(m_launchButton, 1, Qt::AlignCenter);
+    m_mainLayout->setContentsMargins(10, 0, 0, 10);
+    layout->addLayout(m_mainLayout, 0, 1);
+    layout->setColumnMinimumWidth(0, 320);
+    layout->setColumnMinimumWidth(1, 320);
 }
 
 // HACK:
 // https://github.com/KDE/spectacle/blob/fa1e780b8bf3df3ac36c410b9ece4ace041f401b/src/Gui/KSMainWindow.cpp#L70
-void
-CaptureLauncher::startCapture()
+void CaptureLauncher::startCapture()
 {
-  hide();
-  auto mode = static_cast<CaptureRequest::CaptureMode>(
-    m_captureType->currentData().toInt());
-  CaptureRequest req(mode, 600 + m_delaySpinBox->value() * 1000);
-  m_id = req.id();
-  Controller::getInstance()->requestCapture(req);
+    hide();
+    auto mode = static_cast<CaptureRequest::CaptureMode>(
+      m_captureType->currentData().toInt());
+    CaptureRequest req(mode, 600 + m_delaySpinBox->value() * 1000);
+    m_id = req.id();
+    Controller::getInstance()->requestCapture(req);
 }
 
-void
-CaptureLauncher::startDrag()
+void CaptureLauncher::startDrag()
 {
-  QDrag* dragHandler = new QDrag(this);
-  QMimeData* mimeData = new QMimeData;
-  mimeData->setImageData(m_imageLabel->pixmap());
-  dragHandler->setMimeData(mimeData);
-
-  dragHandler->setPixmap(m_imageLabel->pixmap()->scaled(
-    256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation));
-  dragHandler->exec();
+    QDrag* dragHandler = new QDrag(this);
+    QMimeData* mimeData = new QMimeData;
+    mimeData->setImageData(m_imageLabel->pixmap());
+    dragHandler->setMimeData(mimeData);
+
+    dragHandler->setPixmap(m_imageLabel->pixmap()->scaled(
+      256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation));
+    dragHandler->exec();
 }
 
-void
-CaptureLauncher::captureTaken(uint id, QPixmap p)
+void CaptureLauncher::captureTaken(uint id, QPixmap p)
 {
-  if (id == m_id) {
-    m_id = 0;
-    m_imageLabel->setScreenshot(p);
-    show();
-  }
-
-  auto mode = static_cast<CaptureRequest::CaptureMode>(
-    m_captureType->currentData().toInt());
-
-  if (mode == CaptureRequest::FULLSCREEN_MODE) {
-    ScreenshotSaver().saveToFilesystemGUI(p);
-  }
+    if (id == m_id) {
+        m_id = 0;
+        m_imageLabel->setScreenshot(p);
+        show();
+    }
+
+    auto mode = static_cast<CaptureRequest::CaptureMode>(
+      m_captureType->currentData().toInt());
+
+    if (mode == CaptureRequest::FULLSCREEN_MODE) {
+        ScreenshotSaver().saveToFilesystemGUI(p);
+    }
 }
 
-void
-CaptureLauncher::captureFailed(uint id)
+void CaptureLauncher::captureFailed(uint id)
 {
-  if (id == m_id) {
-    m_id = 0;
-    show();
-  }
+    if (id == m_id) {
+        m_id = 0;
+        show();
+    }
 }
diff --git a/src/widgets/capturelauncher.h b/src/widgets/capturelauncher.h
index df3f5cc7..b92fdbd7 100644
--- a/src/widgets/capturelauncher.h
+++ b/src/widgets/capturelauncher.h
@@ -29,22 +29,22 @@ class ImageLabel;
 
 class CaptureLauncher : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit CaptureLauncher(QWidget* parent = nullptr);
+    explicit CaptureLauncher(QWidget* parent = nullptr);
 
 private slots:
-  void startCapture();
-  void startDrag();
-  void captureTaken(uint id, QPixmap p);
-  void captureFailed(uint id);
+    void startCapture();
+    void startDrag();
+    void captureTaken(uint id, QPixmap p);
+    void captureFailed(uint id);
 
 private:
-  QSpinBox* m_delaySpinBox;
-  QComboBox* m_captureType;
-  QVBoxLayout* m_mainLayout;
-  QPushButton* m_launchButton;
-  QLabel* m_CaptureModeLabel;
-  ImageLabel* m_imageLabel;
-  uint m_id;
+    QSpinBox* m_delaySpinBox;
+    QComboBox* m_captureType;
+    QVBoxLayout* m_mainLayout;
+    QPushButton* m_launchButton;
+    QLabel* m_CaptureModeLabel;
+    ImageLabel* m_imageLabel;
+    uint m_id;
 };
diff --git a/src/widgets/draggablewidgetmaker.cpp b/src/widgets/draggablewidgetmaker.cpp
index 617fb668..c738dc62 100644
--- a/src/widgets/draggablewidgetmaker.cpp
+++ b/src/widgets/draggablewidgetmaker.cpp
@@ -22,60 +22,58 @@ DraggableWidgetMaker::DraggableWidgetMaker(QObject* parent)
   : QObject(parent)
 {}
 
-void
-DraggableWidgetMaker::makeDraggable(QWidget* widget)
+void DraggableWidgetMaker::makeDraggable(QWidget* widget)
 {
-  widget->installEventFilter(this);
+    widget->installEventFilter(this);
 }
 
-bool
-DraggableWidgetMaker::eventFilter(QObject* obj, QEvent* event)
+bool DraggableWidgetMaker::eventFilter(QObject* obj, QEvent* event)
 {
-  auto widget = static_cast<QWidget*>(obj);
+    auto widget = static_cast<QWidget*>(obj);
 
-  // based on https://stackoverflow.com/a/12221360/964478
-  switch (event->type()) {
-    case QEvent::MouseButtonPress: {
-      auto mouseEvent = static_cast<QMouseEvent*>(event);
+    // based on https://stackoverflow.com/a/12221360/964478
+    switch (event->type()) {
+        case QEvent::MouseButtonPress: {
+            auto mouseEvent = static_cast<QMouseEvent*>(event);
 
-      m_isPressing = false;
-      m_isDragging = false;
-      if (mouseEvent->button() == Qt::LeftButton) {
-        m_isPressing = true;
-        m_mousePressPos = mouseEvent->globalPos();
-        m_mouseMovePos = m_mousePressPos;
-      }
-    } break;
-    case QEvent::MouseMove: {
-      auto mouseEvent = static_cast<QMouseEvent*>(event);
+            m_isPressing = false;
+            m_isDragging = false;
+            if (mouseEvent->button() == Qt::LeftButton) {
+                m_isPressing = true;
+                m_mousePressPos = mouseEvent->globalPos();
+                m_mouseMovePos = m_mousePressPos;
+            }
+        } break;
+        case QEvent::MouseMove: {
+            auto mouseEvent = static_cast<QMouseEvent*>(event);
 
-      if (m_isPressing) {
-        QPoint widgetPos = widget->mapToGlobal(widget->pos());
-        QPoint eventPos = mouseEvent->globalPos();
-        QPoint diff = eventPos - m_mouseMovePos;
-        QPoint newPos = widgetPos + diff;
+            if (m_isPressing) {
+                QPoint widgetPos = widget->mapToGlobal(widget->pos());
+                QPoint eventPos = mouseEvent->globalPos();
+                QPoint diff = eventPos - m_mouseMovePos;
+                QPoint newPos = widgetPos + diff;
 
-        widget->move(widget->mapFromGlobal(newPos));
+                widget->move(widget->mapFromGlobal(newPos));
 
-        if (!m_isDragging) {
-          QPoint totalMovedDiff = eventPos - m_mousePressPos;
-          if (totalMovedDiff.manhattanLength() > 3) {
-            m_isDragging = true;
-          }
-        }
+                if (!m_isDragging) {
+                    QPoint totalMovedDiff = eventPos - m_mousePressPos;
+                    if (totalMovedDiff.manhattanLength() > 3) {
+                        m_isDragging = true;
+                    }
+                }
 
-        m_mouseMovePos = eventPos;
-      }
-    } break;
-    case QEvent::MouseButtonRelease: {
-      if (m_isDragging) {
-        m_isPressing = false;
-        m_isDragging = false;
-        event->ignore();
-        return true;
-      }
-    } break;
-  }
+                m_mouseMovePos = eventPos;
+            }
+        } break;
+        case QEvent::MouseButtonRelease: {
+            if (m_isDragging) {
+                m_isPressing = false;
+                m_isDragging = false;
+                event->ignore();
+                return true;
+            }
+        } break;
+    }
 
-  return QObject::eventFilter(obj, event);
+    return QObject::eventFilter(obj, event);
 }
diff --git a/src/widgets/draggablewidgetmaker.h b/src/widgets/draggablewidgetmaker.h
index 62f7f17b..7f99893e 100644
--- a/src/widgets/draggablewidgetmaker.h
+++ b/src/widgets/draggablewidgetmaker.h
@@ -24,18 +24,18 @@
 
 class DraggableWidgetMaker : public QObject
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  DraggableWidgetMaker(QObject* parent = nullptr);
+    DraggableWidgetMaker(QObject* parent = nullptr);
 
-  void makeDraggable(QWidget* widget);
+    void makeDraggable(QWidget* widget);
 
 protected:
-  bool eventFilter(QObject* obj, QEvent* event) override;
+    bool eventFilter(QObject* obj, QEvent* event) override;
 
 private:
-  bool m_isPressing = false;
-  bool m_isDragging = false;
-  QPoint m_mouseMovePos;
-  QPoint m_mousePressPos;
+    bool m_isPressing = false;
+    bool m_isDragging = false;
+    QPoint m_mouseMovePos;
+    QPoint m_mousePressPos;
 };
diff --git a/src/widgets/imagelabel.cpp b/src/widgets/imagelabel.cpp
index d09a901b..5115bd26 100644
--- a/src/widgets/imagelabel.cpp
+++ b/src/widgets/imagelabel.cpp
@@ -24,75 +24,69 @@ ImageLabel::ImageLabel(QWidget* parent)
   : QLabel(parent)
   , m_pixmap(QPixmap())
 {
-  m_DSEffect = new QGraphicsDropShadowEffect(this);
+    m_DSEffect = new QGraphicsDropShadowEffect(this);
 
-  m_DSEffect->setBlurRadius(5);
-  m_DSEffect->setOffset(0);
-  m_DSEffect->setColor(QColor(Qt::black));
+    m_DSEffect->setBlurRadius(5);
+    m_DSEffect->setOffset(0);
+    m_DSEffect->setColor(QColor(Qt::black));
 
-  setGraphicsEffect(m_DSEffect);
-  setCursor(Qt::OpenHandCursor);
-  setAlignment(Qt::AlignCenter);
-  setMinimumSize(size());
+    setGraphicsEffect(m_DSEffect);
+    setCursor(Qt::OpenHandCursor);
+    setAlignment(Qt::AlignCenter);
+    setMinimumSize(size());
 }
 
-void
-ImageLabel::setScreenshot(const QPixmap& pixmap)
+void ImageLabel::setScreenshot(const QPixmap& pixmap)
 {
-  m_pixmap = pixmap;
-  const QString tooltip =
-    QStringLiteral("%1x%2 px").arg(m_pixmap.width()).arg(m_pixmap.height());
-  setToolTip(tooltip);
-  setScaledPixmap();
+    m_pixmap = pixmap;
+    const QString tooltip =
+      QStringLiteral("%1x%2 px").arg(m_pixmap.width()).arg(m_pixmap.height());
+    setToolTip(tooltip);
+    setScaledPixmap();
 }
 
-void
-ImageLabel::setScaledPixmap()
+void ImageLabel::setScaledPixmap()
 {
-  const qreal scale = qApp->devicePixelRatio();
-  QPixmap scaledPixmap = m_pixmap.scaled(
-    size() * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation);
-  scaledPixmap.setDevicePixelRatio(scale);
-  setPixmap(scaledPixmap);
+    const qreal scale = qApp->devicePixelRatio();
+    QPixmap scaledPixmap = m_pixmap.scaled(
+      size() * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+    scaledPixmap.setDevicePixelRatio(scale);
+    setPixmap(scaledPixmap);
 }
 
 // drag handlers
 
-void
-ImageLabel::mousePressEvent(QMouseEvent* event)
+void ImageLabel::mousePressEvent(QMouseEvent* event)
 {
-  if (event->button() == Qt::LeftButton) {
-    m_dragStartPosition = event->pos();
-    setCursor(Qt::ClosedHandCursor);
-  }
+    if (event->button() == Qt::LeftButton) {
+        m_dragStartPosition = event->pos();
+        setCursor(Qt::ClosedHandCursor);
+    }
 }
 
-void
-ImageLabel::mouseReleaseEvent(QMouseEvent* event)
+void ImageLabel::mouseReleaseEvent(QMouseEvent* event)
 {
-  if (event->button() == Qt::LeftButton) {
-    setCursor(Qt::OpenHandCursor);
-  }
+    if (event->button() == Qt::LeftButton) {
+        setCursor(Qt::OpenHandCursor);
+    }
 }
 
-void
-ImageLabel::mouseMoveEvent(QMouseEvent* event)
+void ImageLabel::mouseMoveEvent(QMouseEvent* event)
 {
-  if (!(event->buttons() & Qt::LeftButton)) {
-    return;
-  }
-  if ((event->pos() - m_dragStartPosition).manhattanLength() <
-      QGuiApplication::styleHints()->startDragDistance()) {
-    return;
-  }
-  setCursor(Qt::OpenHandCursor);
-  emit dragInitiated();
+    if (!(event->buttons() & Qt::LeftButton)) {
+        return;
+    }
+    if ((event->pos() - m_dragStartPosition).manhattanLength() <
+        QGuiApplication::styleHints()->startDragDistance()) {
+        return;
+    }
+    setCursor(Qt::OpenHandCursor);
+    emit dragInitiated();
 }
 
 // resize handler
-void
-ImageLabel::resizeEvent(QResizeEvent* event)
+void ImageLabel::resizeEvent(QResizeEvent* event)
 {
-  Q_UNUSED(event);
-  setScaledPixmap();
+    Q_UNUSED(event);
+    setScaledPixmap();
 }
diff --git a/src/widgets/imagelabel.h b/src/widgets/imagelabel.h
index f40ac933..160dea62 100644
--- a/src/widgets/imagelabel.h
+++ b/src/widgets/imagelabel.h
@@ -31,25 +31,25 @@
 
 class ImageLabel : public QLabel
 {
-  Q_OBJECT
+    Q_OBJECT
 
 public:
-  explicit ImageLabel(QWidget* parent = nullptr);
-  void setScreenshot(const QPixmap& pixmap);
+    explicit ImageLabel(QWidget* parent = nullptr);
+    void setScreenshot(const QPixmap& pixmap);
 
 signals:
-  void dragInitiated();
+    void dragInitiated();
 
 protected:
-  void mousePressEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
-  void mouseReleaseEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
-  void mouseMoveEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
-  void resizeEvent(QResizeEvent* event) Q_DECL_OVERRIDE;
+    void mousePressEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
+    void mouseReleaseEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
+    void mouseMoveEvent(QMouseEvent* event) Q_DECL_OVERRIDE;
+    void resizeEvent(QResizeEvent* event) Q_DECL_OVERRIDE;
 
 private:
-  void setScaledPixmap();
+    void setScaledPixmap();
 
-  QGraphicsDropShadowEffect* m_DSEffect;
-  QPixmap m_pixmap;
-  QPoint m_dragStartPosition;
+    QGraphicsDropShadowEffect* m_DSEffect;
+    QPixmap m_pixmap;
+    QPoint m_dragStartPosition;
 };
diff --git a/src/widgets/infowindow.cpp b/src/widgets/infowindow.cpp
index e392f1ac..b624adfa 100644
--- a/src/widgets/infowindow.cpp
+++ b/src/widgets/infowindow.cpp
@@ -35,22 +35,22 @@
 InfoWindow::InfoWindow(QWidget* parent)
   : QWidget(parent)
 {
-  setAttribute(Qt::WA_DeleteOnClose);
-  setWindowIcon(QIcon(":img/app/flameshot.svg"));
-  setWindowTitle(tr("About"));
+    setAttribute(Qt::WA_DeleteOnClose);
+    setWindowIcon(QIcon(":img/app/flameshot.svg"));
+    setWindowTitle(tr("About"));
 
 #if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0))
-  QRect position = frameGeometry();
-  QScreen* screen = QGuiApplication::screenAt(QCursor::pos());
-  position.moveCenter(screen->availableGeometry().center());
-  move(position.topLeft());
+    QRect position = frameGeometry();
+    QScreen* screen = QGuiApplication::screenAt(QCursor::pos());
+    position.moveCenter(screen->availableGeometry().center());
+    move(position.topLeft());
 #endif
 
-  m_layout = new QVBoxLayout(this);
-  m_layout->setAlignment(Qt::AlignHCenter);
-  initLabels();
-  initInfoTable();
-  show();
+    m_layout = new QVBoxLayout(this);
+    m_layout->setAlignment(Qt::AlignHCenter);
+    initLabels();
+    initInfoTable();
+    show();
 }
 
 QVector<const char*> InfoWindow::m_keys = { "←↓↑→",
@@ -64,94 +64,93 @@ QVector<const char*> InfoWindow::m_keys = { "←↓↑→",
                                             QT_TR_NOOP("Mouse Wheel") };
 
 QVector<const char*> InfoWindow::m_description = {
-  QT_TR_NOOP("Move selection 1px"),
-  QT_TR_NOOP("Resize selection 1px"),
-  QT_TR_NOOP("Quit capture"),
-  QT_TR_NOOP("Copy to clipboard"),
-  QT_TR_NOOP("Save selection as a file"),
-  QT_TR_NOOP("Undo the last modification"),
-  QT_TR_NOOP("Toggle visibility of sidebar with options of the selected tool"),
-  QT_TR_NOOP("Show color picker"),
-  QT_TR_NOOP("Change the tool's thickness")
+    QT_TR_NOOP("Move selection 1px"),
+    QT_TR_NOOP("Resize selection 1px"),
+    QT_TR_NOOP("Quit capture"),
+    QT_TR_NOOP("Copy to clipboard"),
+    QT_TR_NOOP("Save selection as a file"),
+    QT_TR_NOOP("Undo the last modification"),
+    QT_TR_NOOP(
+      "Toggle visibility of sidebar with options of the selected tool"),
+    QT_TR_NOOP("Show color picker"),
+    QT_TR_NOOP("Change the tool's thickness")
 };
 
-void
-InfoWindow::initInfoTable()
+void InfoWindow::initInfoTable()
 {
-  QTableWidget* table = new QTableWidget(this);
-  table->setToolTip(tr("Available shortcuts in the screen capture mode."));
-
-  m_layout->addWidget(table);
-
-  table->setColumnCount(2);
-  table->setRowCount(m_keys.size());
-  table->setSelectionMode(QAbstractItemView::NoSelection);
-  table->setFocusPolicy(Qt::NoFocus);
-  table->verticalHeader()->hide();
-  // header creation
-  QStringList names;
-  names << tr("Key") << tr("Description");
-  table->setHorizontalHeaderLabels(names);
-
-  // add content
-  for (int i = 0; i < m_keys.size(); ++i) {
-    table->setItem(i, 0, new QTableWidgetItem(tr(m_keys.at(i))));
-    table->setItem(i, 1, new QTableWidgetItem(tr(m_description.at(i))));
-  }
-
-  // Read-only table items
-  for (int x = 0; x < table->rowCount(); ++x) {
-    for (int y = 0; y < table->columnCount(); ++y) {
-      QTableWidgetItem* item = table->item(x, y);
-      item->setFlags(item->flags() ^ Qt::ItemIsEditable);
+    QTableWidget* table = new QTableWidget(this);
+    table->setToolTip(tr("Available shortcuts in the screen capture mode."));
+
+    m_layout->addWidget(table);
+
+    table->setColumnCount(2);
+    table->setRowCount(m_keys.size());
+    table->setSelectionMode(QAbstractItemView::NoSelection);
+    table->setFocusPolicy(Qt::NoFocus);
+    table->verticalHeader()->hide();
+    // header creation
+    QStringList names;
+    names << tr("Key") << tr("Description");
+    table->setHorizontalHeaderLabels(names);
+
+    // add content
+    for (int i = 0; i < m_keys.size(); ++i) {
+        table->setItem(i, 0, new QTableWidgetItem(tr(m_keys.at(i))));
+        table->setItem(i, 1, new QTableWidgetItem(tr(m_description.at(i))));
     }
-  }
-
-  // adjust size
-  table->resizeColumnsToContents();
-  table->resizeRowsToContents();
-  table->setMinimumWidth(400);
-  table->setMaximumWidth(600);
-
-  table->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);
-  table->horizontalHeader()->setSizePolicy(QSizePolicy::Expanding,
-                                           QSizePolicy::Expanding);
-  m_layout->addStretch();
+
+    // Read-only table items
+    for (int x = 0; x < table->rowCount(); ++x) {
+        for (int y = 0; y < table->columnCount(); ++y) {
+            QTableWidgetItem* item = table->item(x, y);
+            item->setFlags(item->flags() ^ Qt::ItemIsEditable);
+        }
+    }
+
+    // adjust size
+    table->resizeColumnsToContents();
+    table->resizeRowsToContents();
+    table->setMinimumWidth(400);
+    table->setMaximumWidth(600);
+
+    table->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);
+    table->horizontalHeader()->setSizePolicy(QSizePolicy::Expanding,
+                                             QSizePolicy::Expanding);
+    m_layout->addStretch();
 }
 
-void
-InfoWindow::initLabels()
+void InfoWindow::initLabels()
 {
-  m_layout->addStretch();
-  QLabel* licenseTitleLabel = new QLabel(tr("<u><b>License</b></u>"), this);
-  licenseTitleLabel->setAlignment(Qt::AlignHCenter);
-  m_layout->addWidget(licenseTitleLabel);
-  QLabel* licenseLabel = new QLabel(QStringLiteral("GPLv3+"), this);
-  licenseLabel->setAlignment(Qt::AlignHCenter);
-  m_layout->addWidget(licenseLabel);
-  m_layout->addStretch();
-
-  QLabel* versionTitleLabel = new QLabel(tr("<u><b>Version</b></u>"), this);
-  versionTitleLabel->setAlignment(Qt::AlignHCenter);
-  m_layout->addWidget(versionTitleLabel);
-
-  QString versionMsg = "Flameshot " + QStringLiteral(APP_VERSION) +
-                       "\nCompiled with Qt " + QT_VERSION_STR;
-  QLabel* versionLabel = new QLabel(versionMsg, this);
-  versionLabel->setAlignment(Qt::AlignHCenter);
-  m_layout->addWidget(versionLabel);
-  m_layout->addStretch();
-  m_layout->addSpacing(10);
-  QLabel* shortcutsTitleLabel = new QLabel(tr("<u><b>Shortcuts</b></u>"), this);
-  shortcutsTitleLabel->setAlignment(Qt::AlignHCenter);
-  ;
-  m_layout->addWidget(shortcutsTitleLabel);
+    m_layout->addStretch();
+    QLabel* licenseTitleLabel = new QLabel(tr("<u><b>License</b></u>"), this);
+    licenseTitleLabel->setAlignment(Qt::AlignHCenter);
+    m_layout->addWidget(licenseTitleLabel);
+    QLabel* licenseLabel = new QLabel(QStringLiteral("GPLv3+"), this);
+    licenseLabel->setAlignment(Qt::AlignHCenter);
+    m_layout->addWidget(licenseLabel);
+    m_layout->addStretch();
+
+    QLabel* versionTitleLabel = new QLabel(tr("<u><b>Version</b></u>"), this);
+    versionTitleLabel->setAlignment(Qt::AlignHCenter);
+    m_layout->addWidget(versionTitleLabel);
+
+    QString versionMsg = "Flameshot " + QStringLiteral(APP_VERSION) +
+                         "\nCompiled with Qt " + QT_VERSION_STR;
+    QLabel* versionLabel = new QLabel(versionMsg, this);
+    versionLabel->setAlignment(Qt::AlignHCenter);
+    m_layout->addWidget(versionLabel);
+    m_layout->addStretch();
+    m_layout->addSpacing(10);
+    QLabel* shortcutsTitleLabel =
+      new QLabel(tr("<u><b>Shortcuts</b></u>"), this);
+    shortcutsTitleLabel->setAlignment(Qt::AlignHCenter);
+    ;
+    m_layout->addWidget(shortcutsTitleLabel);
 }
 
-void
-InfoWindow::keyPressEvent(QKeyEvent* e)
+void InfoWindow::keyPressEvent(QKeyEvent* e)
 {
-  if (e->key() == Qt::Key_Escape) {
-    close();
-  }
+    if (e->key() == Qt::Key_Escape) {
+        close();
+    }
 }
diff --git a/src/widgets/infowindow.h b/src/widgets/infowindow.h
index 37d33778..9262c0ce 100644
--- a/src/widgets/infowindow.h
+++ b/src/widgets/infowindow.h
@@ -23,18 +23,18 @@ class QVBoxLayout;
 
 class InfoWindow : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit InfoWindow(QWidget* parent = nullptr);
+    explicit InfoWindow(QWidget* parent = nullptr);
 
 protected:
-  void keyPressEvent(QKeyEvent*);
+    void keyPressEvent(QKeyEvent*);
 
 private:
-  void initInfoTable();
-  void initLabels();
-  QVBoxLayout* m_layout;
+    void initInfoTable();
+    void initLabels();
+    QVBoxLayout* m_layout;
 
-  static QVector<const char*> m_keys;
-  static QVector<const char*> m_description;
+    static QVector<const char*> m_keys;
+    static QVector<const char*> m_description;
 };
diff --git a/src/widgets/loadspinner.cpp b/src/widgets/loadspinner.cpp
index 4c5baef8..bc181792 100644
--- a/src/widgets/loadspinner.cpp
+++ b/src/widgets/loadspinner.cpp
@@ -29,86 +29,79 @@ LoadSpinner::LoadSpinner(QWidget* parent)
   , m_span(0)
   , m_growing(true)
 {
-  setAttribute(Qt::WA_TranslucentBackground);
-  const int size = QApplication::fontMetrics().height() * 8;
-  setFixedSize(size, size);
-  updateFrame();
-  // init timer
-  m_timer = new QTimer(this);
-  connect(m_timer, &QTimer::timeout, this, &LoadSpinner::rotate);
-  m_timer->setInterval(30);
+    setAttribute(Qt::WA_TranslucentBackground);
+    const int size = QApplication::fontMetrics().height() * 8;
+    setFixedSize(size, size);
+    updateFrame();
+    // init timer
+    m_timer = new QTimer(this);
+    connect(m_timer, &QTimer::timeout, this, &LoadSpinner::rotate);
+    m_timer->setInterval(30);
 }
 
-void
-LoadSpinner::setColor(const QColor& c)
+void LoadSpinner::setColor(const QColor& c)
 {
-  m_color = c;
+    m_color = c;
 }
 
-void
-LoadSpinner::setWidth(int w)
+void LoadSpinner::setWidth(int w)
 {
-  setFixedSize(w, w);
-  updateFrame();
+    setFixedSize(w, w);
+    updateFrame();
 }
 
-void
-LoadSpinner::setHeight(int h)
+void LoadSpinner::setHeight(int h)
 {
-  setFixedSize(h, h);
-  updateFrame();
+    setFixedSize(h, h);
+    updateFrame();
 }
 
-void
-LoadSpinner::start()
+void LoadSpinner::start()
 {
-  m_timer->start();
+    m_timer->start();
 }
 
-void
-LoadSpinner::stop()
+void LoadSpinner::stop()
 {
-  m_timer->stop();
+    m_timer->stop();
 }
 
-void
-LoadSpinner::paintEvent(QPaintEvent*)
+void LoadSpinner::paintEvent(QPaintEvent*)
 {
-  QPainter painter(this);
-  painter.setRenderHint(QPainter::Antialiasing, true);
-  auto pen = QPen(m_color);
+    QPainter painter(this);
+    painter.setRenderHint(QPainter::Antialiasing, true);
+    auto pen = QPen(m_color);
 
-  pen.setWidth(height() / 10);
-  painter.setPen(pen);
-  painter.setOpacity(0.2);
-  painter.drawArc(m_frame, 0, 5760);
-  painter.setOpacity(1.0);
-  painter.drawArc(m_frame, (m_startAngle * 16), (m_span * 16));
+    pen.setWidth(height() / 10);
+    painter.setPen(pen);
+    painter.setOpacity(0.2);
+    painter.drawArc(m_frame, 0, 5760);
+    painter.setOpacity(1.0);
+    painter.drawArc(m_frame, (m_startAngle * 16), (m_span * 16));
 }
 
-void
-LoadSpinner::rotate()
+void LoadSpinner::rotate()
 {
-  const int advance = 3;
-  const int grow = 8;
-  if (m_growing) {
-    m_startAngle = (m_startAngle + advance) % 360;
-    m_span += grow;
-    if (m_span > 260) {
-      m_growing = false;
+    const int advance = 3;
+    const int grow = 8;
+    if (m_growing) {
+        m_startAngle = (m_startAngle + advance) % 360;
+        m_span += grow;
+        if (m_span > 260) {
+            m_growing = false;
+        }
+    } else {
+        m_startAngle = (m_startAngle + grow) % 360;
+        m_span = m_span + advance - grow;
+        if (m_span < 10) {
+            m_growing = true;
+        }
     }
-  } else {
-    m_startAngle = (m_startAngle + grow) % 360;
-    m_span = m_span + advance - grow;
-    if (m_span < 10) {
-      m_growing = true;
-    }
-  }
-  update();
+    update();
 }
 
-void
-LoadSpinner::updateFrame()
+void LoadSpinner::updateFrame()
 {
-  m_frame = QRect(OFFSET, OFFSET, width() - OFFSET * 2, height() - OFFSET * 2);
+    m_frame =
+      QRect(OFFSET, OFFSET, width() - OFFSET * 2, height() - OFFSET * 2);
 }
diff --git a/src/widgets/loadspinner.h b/src/widgets/loadspinner.h
index 707fc3f0..9cb5d1e6 100644
--- a/src/widgets/loadspinner.h
+++ b/src/widgets/loadspinner.h
@@ -21,30 +21,30 @@
 
 class LoadSpinner : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit LoadSpinner(QWidget* parent = nullptr);
+    explicit LoadSpinner(QWidget* parent = nullptr);
 
-  void setColor(const QColor& c);
-  void setWidth(int w);
-  void setHeight(int h);
-  void start();
-  void stop();
+    void setColor(const QColor& c);
+    void setWidth(int w);
+    void setHeight(int h);
+    void start();
+    void stop();
 
 protected:
-  void paintEvent(QPaintEvent*);
+    void paintEvent(QPaintEvent*);
 
 private slots:
-  void rotate();
+    void rotate();
 
 private:
-  QColor m_color;
-  QTimer* m_timer;
+    QColor m_color;
+    QTimer* m_timer;
 
-  int m_startAngle = 0;
-  int m_span = 180;
-  bool m_growing;
+    int m_startAngle = 0;
+    int m_span = 180;
+    bool m_growing;
 
-  QRect m_frame;
-  void updateFrame();
+    QRect m_frame;
+    void updateFrame();
 };
diff --git a/src/widgets/notificationwidget.cpp b/src/widgets/notificationwidget.cpp
index 24135034..c0c1fed5 100644
--- a/src/widgets/notificationwidget.cpp
+++ b/src/widgets/notificationwidget.cpp
@@ -26,55 +26,52 @@
 NotificationWidget::NotificationWidget(QWidget* parent)
   : QWidget(parent)
 {
-  m_timer = new QTimer(this);
-  m_timer->setSingleShot(true);
-  m_timer->setInterval(7000);
-  connect(m_timer, &QTimer::timeout, this, &NotificationWidget::animatedHide);
+    m_timer = new QTimer(this);
+    m_timer->setSingleShot(true);
+    m_timer->setInterval(7000);
+    connect(m_timer, &QTimer::timeout, this, &NotificationWidget::animatedHide);
 
-  m_content = new QFrame();
-  m_layout = new QVBoxLayout();
-  m_label = new QLabel(m_content);
-  m_label->hide();
+    m_content = new QFrame();
+    m_layout = new QVBoxLayout();
+    m_label = new QLabel(m_content);
+    m_label->hide();
 
-  m_showAnimation = new QPropertyAnimation(m_content, "geometry", this);
-  m_showAnimation->setDuration(300);
+    m_showAnimation = new QPropertyAnimation(m_content, "geometry", this);
+    m_showAnimation->setDuration(300);
 
-  m_hideAnimation = new QPropertyAnimation(m_content, "geometry", this);
-  m_hideAnimation->setDuration(300);
-  connect(
-    m_hideAnimation, &QPropertyAnimation::finished, m_label, &QLabel::hide);
+    m_hideAnimation = new QPropertyAnimation(m_content, "geometry", this);
+    m_hideAnimation->setDuration(300);
+    connect(
+      m_hideAnimation, &QPropertyAnimation::finished, m_label, &QLabel::hide);
 
-  auto mainLayout = new QVBoxLayout();
-  setLayout(mainLayout);
+    auto mainLayout = new QVBoxLayout();
+    setLayout(mainLayout);
 
-  mainLayout->addWidget(m_content);
-  m_layout->addWidget(m_label, 0, Qt::AlignHCenter);
-  m_content->setLayout(m_layout);
+    mainLayout->addWidget(m_content);
+    m_layout->addWidget(m_label, 0, Qt::AlignHCenter);
+    m_content->setLayout(m_layout);
 
-  setFixedHeight(40);
+    setFixedHeight(40);
 }
 
-void
-NotificationWidget::showMessage(const QString& msg)
+void NotificationWidget::showMessage(const QString& msg)
 {
-  m_label->setText(msg);
-  m_label->show();
-  animatedShow();
+    m_label->setText(msg);
+    m_label->show();
+    animatedShow();
 }
 
-void
-NotificationWidget::animatedShow()
+void NotificationWidget::animatedShow()
 {
-  m_showAnimation->setStartValue(QRect(0, 0, width(), 0));
-  m_showAnimation->setEndValue(QRect(0, 0, width(), height()));
-  m_showAnimation->start();
-  m_timer->start();
+    m_showAnimation->setStartValue(QRect(0, 0, width(), 0));
+    m_showAnimation->setEndValue(QRect(0, 0, width(), height()));
+    m_showAnimation->start();
+    m_timer->start();
 }
 
-void
-NotificationWidget::animatedHide()
+void NotificationWidget::animatedHide()
 {
-  m_hideAnimation->setStartValue(QRect(0, 0, width(), height()));
-  m_hideAnimation->setEndValue(QRect(0, 0, width(), 0));
-  m_hideAnimation->start();
+    m_hideAnimation->setStartValue(QRect(0, 0, width(), height()));
+    m_hideAnimation->setEndValue(QRect(0, 0, width(), 0));
+    m_hideAnimation->start();
 }
diff --git a/src/widgets/notificationwidget.h b/src/widgets/notificationwidget.h
index b4b55535..8b62a17f 100644
--- a/src/widgets/notificationwidget.h
+++ b/src/widgets/notificationwidget.h
@@ -27,20 +27,20 @@ class QFrame;
 
 class NotificationWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit NotificationWidget(QWidget* parent = nullptr);
+    explicit NotificationWidget(QWidget* parent = nullptr);
 
-  void showMessage(const QString& msg);
+    void showMessage(const QString& msg);
 
 private:
-  QLabel* m_label;
-  QPropertyAnimation* m_showAnimation;
-  QPropertyAnimation* m_hideAnimation;
-  QVBoxLayout* m_layout;
-  QFrame* m_content;
-  QTimer* m_timer;
+    QLabel* m_label;
+    QPropertyAnimation* m_showAnimation;
+    QPropertyAnimation* m_hideAnimation;
+    QVBoxLayout* m_layout;
+    QFrame* m_content;
+    QTimer* m_timer;
 
-  void animatedShow();
-  void animatedHide();
+    void animatedShow();
+    void animatedHide();
 };
diff --git a/src/widgets/orientablepushbutton.cpp b/src/widgets/orientablepushbutton.cpp
index ba9d70ef..f85b66d5 100644
--- a/src/widgets/orientablepushbutton.cpp
+++ b/src/widgets/orientablepushbutton.cpp
@@ -37,51 +37,47 @@ OrientablePushButton::OrientablePushButton(const QIcon& icon,
   : CaptureButton(icon, text, parent)
 {}
 
-QSize
-OrientablePushButton::sizeHint() const
+QSize OrientablePushButton::sizeHint() const
 {
-  QSize sh = QPushButton::sizeHint();
+    QSize sh = QPushButton::sizeHint();
 
-  if (m_orientation != OrientablePushButton::Horizontal) {
-    sh.transpose();
-  }
+    if (m_orientation != OrientablePushButton::Horizontal) {
+        sh.transpose();
+    }
 
-  return sh;
+    return sh;
 }
 
-void
-OrientablePushButton::paintEvent(QPaintEvent* event)
+void OrientablePushButton::paintEvent(QPaintEvent* event)
 {
-  Q_UNUSED(event)
+    Q_UNUSED(event)
 
-  QStylePainter painter(this);
-  QStyleOptionButton option;
-  initStyleOption(&option);
+    QStylePainter painter(this);
+    QStyleOptionButton option;
+    initStyleOption(&option);
 
-  if (m_orientation == OrientablePushButton::VerticalTopToBottom) {
-    painter.rotate(90);
-    painter.translate(0, -1 * width());
-    option.rect = option.rect.transposed();
-  }
+    if (m_orientation == OrientablePushButton::VerticalTopToBottom) {
+        painter.rotate(90);
+        painter.translate(0, -1 * width());
+        option.rect = option.rect.transposed();
+    }
 
-  else if (m_orientation == OrientablePushButton::VerticalBottomToTop) {
-    painter.rotate(-90);
-    painter.translate(-1 * height(), 0);
-    option.rect = option.rect.transposed();
-  }
+    else if (m_orientation == OrientablePushButton::VerticalBottomToTop) {
+        painter.rotate(-90);
+        painter.translate(-1 * height(), 0);
+        option.rect = option.rect.transposed();
+    }
 
-  painter.drawControl(QStyle::CE_PushButton, option);
+    painter.drawControl(QStyle::CE_PushButton, option);
 }
 
-OrientablePushButton::Orientation
-OrientablePushButton::orientation() const
+OrientablePushButton::Orientation OrientablePushButton::orientation() const
 {
-  return m_orientation;
+    return m_orientation;
 }
 
-void
-OrientablePushButton::setOrientation(
+void OrientablePushButton::setOrientation(
   const OrientablePushButton::Orientation& orientation)
 {
-  m_orientation = orientation;
+    m_orientation = orientation;
 }
diff --git a/src/widgets/orientablepushbutton.h b/src/widgets/orientablepushbutton.h
index 499e4cb7..ffac4477 100644
--- a/src/widgets/orientablepushbutton.h
+++ b/src/widgets/orientablepushbutton.h
@@ -24,29 +24,29 @@
 
 class OrientablePushButton : public CaptureButton
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  enum Orientation
-  {
-    Horizontal,
-    VerticalTopToBottom,
-    VerticalBottomToTop
-  };
+    enum Orientation
+    {
+        Horizontal,
+        VerticalTopToBottom,
+        VerticalBottomToTop
+    };
 
-  OrientablePushButton(QWidget* parent = nullptr);
-  OrientablePushButton(const QString& text, QWidget* parent = nullptr);
-  OrientablePushButton(const QIcon& icon,
-                       const QString& text,
-                       QWidget* parent = nullptr);
+    OrientablePushButton(QWidget* parent = nullptr);
+    OrientablePushButton(const QString& text, QWidget* parent = nullptr);
+    OrientablePushButton(const QIcon& icon,
+                         const QString& text,
+                         QWidget* parent = nullptr);
 
-  QSize sizeHint() const;
+    QSize sizeHint() const;
 
-  OrientablePushButton::Orientation orientation() const;
-  void setOrientation(const OrientablePushButton::Orientation& orientation);
+    OrientablePushButton::Orientation orientation() const;
+    void setOrientation(const OrientablePushButton::Orientation& orientation);
 
 protected:
-  void paintEvent(QPaintEvent* event);
+    void paintEvent(QPaintEvent* event);
 
 private:
-  Orientation m_orientation = Horizontal;
+    Orientation m_orientation = Horizontal;
 };
diff --git a/src/widgets/panel/sidepanelwidget.cpp b/src/widgets/panel/sidepanelwidget.cpp
index f985fb5f..b5e5ba6c 100644
--- a/src/widgets/panel/sidepanelwidget.cpp
+++ b/src/widgets/panel/sidepanelwidget.cpp
@@ -28,30 +28,31 @@
 class QColorPickingEventFilter : public QObject
 {
 public:
-  explicit QColorPickingEventFilter(SidePanelWidget* pw,
-                                    QObject* parent = nullptr)
-    : QObject(parent)
-    , m_pw(pw)
-  {}
-
-  bool eventFilter(QObject*, QEvent* event) override
-  {
-    event->accept();
-    switch (event->type()) {
-      case QEvent::MouseMove:
-        return m_pw->handleMouseMove(static_cast<QMouseEvent*>(event));
-      case QEvent::MouseButtonPress:
-        return m_pw->handleMouseButtonPressed(static_cast<QMouseEvent*>(event));
-      case QEvent::KeyPress:
-        return m_pw->handleKeyPress(static_cast<QKeyEvent*>(event));
-      default:
-        break;
+    explicit QColorPickingEventFilter(SidePanelWidget* pw,
+                                      QObject* parent = nullptr)
+      : QObject(parent)
+      , m_pw(pw)
+    {}
+
+    bool eventFilter(QObject*, QEvent* event) override
+    {
+        event->accept();
+        switch (event->type()) {
+            case QEvent::MouseMove:
+                return m_pw->handleMouseMove(static_cast<QMouseEvent*>(event));
+            case QEvent::MouseButtonPress:
+                return m_pw->handleMouseButtonPressed(
+                  static_cast<QMouseEvent*>(event));
+            case QEvent::KeyPress:
+                return m_pw->handleKeyPress(static_cast<QKeyEvent*>(event));
+            default:
+                break;
+        }
+        return false;
     }
-    return false;
-  }
 
 private:
-  SidePanelWidget* m_pw;
+    SidePanelWidget* m_pw;
 };
 
 ////////////////////////
@@ -61,161 +62,150 @@ SidePanelWidget::SidePanelWidget(QPixmap* p, QWidget* parent)
   , m_pixmap(p)
   , m_eventFilter(nullptr)
 {
-  m_layout = new QVBoxLayout(this);
-
-  QFormLayout* colorForm = new QFormLayout();
-  m_thicknessSlider = new QSlider(Qt::Horizontal);
-  m_thicknessSlider->setValue(m_thickness);
-  m_colorLabel = new QLabel();
-  m_colorLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
-  colorForm->addRow(tr("Active thickness:"), m_thicknessSlider);
-  colorForm->addRow(tr("Active color:"), m_colorLabel);
-  m_layout->addLayout(colorForm);
-
-  connect(m_thicknessSlider,
-          &QSlider::sliderReleased,
-          this,
-          &SidePanelWidget::updateCurrentThickness);
-  connect(this,
-          &SidePanelWidget::thicknessChanged,
-          this,
-          &SidePanelWidget::updateThickness);
-
-  QColor background = this->palette().window().color();
-  bool isDark = ColorUtils::colorIsDark(background);
-  QString modifier =
-    isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();
-  QIcon grabIcon(modifier + "colorize.svg");
-  m_colorGrabButton = new QPushButton(grabIcon, QLatin1String(""));
-  updateGrabButton(false);
-  connect(m_colorGrabButton,
-          &QPushButton::pressed,
-          this,
-          &SidePanelWidget::colorGrabberActivated);
-  m_layout->addWidget(m_colorGrabButton);
-
-  m_colorWheel = new color_widgets::ColorWheel(this);
-  m_colorWheel->setColor(m_color);
-  connect(m_colorWheel,
-          &color_widgets::ColorWheel::mouseReleaseOnColor,
-          this,
-          &SidePanelWidget::colorChanged);
-  connect(m_colorWheel,
-          &color_widgets::ColorWheel::colorChanged,
-          this,
-          &SidePanelWidget::updateColorNoWheel);
-  m_layout->addWidget(m_colorWheel);
+    m_layout = new QVBoxLayout(this);
+
+    QFormLayout* colorForm = new QFormLayout();
+    m_thicknessSlider = new QSlider(Qt::Horizontal);
+    m_thicknessSlider->setValue(m_thickness);
+    m_colorLabel = new QLabel();
+    m_colorLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
+    colorForm->addRow(tr("Active thickness:"), m_thicknessSlider);
+    colorForm->addRow(tr("Active color:"), m_colorLabel);
+    m_layout->addLayout(colorForm);
+
+    connect(m_thicknessSlider,
+            &QSlider::sliderReleased,
+            this,
+            &SidePanelWidget::updateCurrentThickness);
+    connect(this,
+            &SidePanelWidget::thicknessChanged,
+            this,
+            &SidePanelWidget::updateThickness);
+
+    QColor background = this->palette().window().color();
+    bool isDark = ColorUtils::colorIsDark(background);
+    QString modifier =
+      isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();
+    QIcon grabIcon(modifier + "colorize.svg");
+    m_colorGrabButton = new QPushButton(grabIcon, QLatin1String(""));
+    updateGrabButton(false);
+    connect(m_colorGrabButton,
+            &QPushButton::pressed,
+            this,
+            &SidePanelWidget::colorGrabberActivated);
+    m_layout->addWidget(m_colorGrabButton);
+
+    m_colorWheel = new color_widgets::ColorWheel(this);
+    m_colorWheel->setColor(m_color);
+    connect(m_colorWheel,
+            &color_widgets::ColorWheel::mouseReleaseOnColor,
+            this,
+            &SidePanelWidget::colorChanged);
+    connect(m_colorWheel,
+            &color_widgets::ColorWheel::colorChanged,
+            this,
+            &SidePanelWidget::updateColorNoWheel);
+    m_layout->addWidget(m_colorWheel);
 }
 
-void
-SidePanelWidget::updateColor(const QColor& c)
+void SidePanelWidget::updateColor(const QColor& c)
 {
-  m_color = c;
-  m_colorLabel->setStyleSheet(
-    QStringLiteral("QLabel { background-color : %1; }").arg(c.name()));
-  m_colorWheel->setColor(m_color);
+    m_color = c;
+    m_colorLabel->setStyleSheet(
+      QStringLiteral("QLabel { background-color : %1; }").arg(c.name()));
+    m_colorWheel->setColor(m_color);
 }
 
-void
-SidePanelWidget::updateThickness(const int& t)
+void SidePanelWidget::updateThickness(const int& t)
 {
-  m_thickness = qBound(0, t, 100);
-  m_thicknessSlider->setValue(m_thickness);
+    m_thickness = qBound(0, t, 100);
+    m_thicknessSlider->setValue(m_thickness);
 }
 
-void
-SidePanelWidget::updateColorNoWheel(const QColor& c)
+void SidePanelWidget::updateColorNoWheel(const QColor& c)
 {
-  m_color = c;
-  m_colorLabel->setStyleSheet(
-    QStringLiteral("QLabel { background-color : %1; }").arg(c.name()));
+    m_color = c;
+    m_colorLabel->setStyleSheet(
+      QStringLiteral("QLabel { background-color : %1; }").arg(c.name()));
 }
 
-void
-SidePanelWidget::updateCurrentThickness()
+void SidePanelWidget::updateCurrentThickness()
 {
-  emit thicknessChanged(m_thicknessSlider->value());
+    emit thicknessChanged(m_thicknessSlider->value());
 }
 
-void
-SidePanelWidget::colorGrabberActivated()
+void SidePanelWidget::colorGrabberActivated()
 {
-  grabKeyboard();
-  grabMouse(Qt::CrossCursor);
-  setMouseTracking(true);
-  m_colorBackup = m_color;
-  if (!m_eventFilter) {
-    m_eventFilter = new QColorPickingEventFilter(this, this);
-  }
-  installEventFilter(m_eventFilter);
-  updateGrabButton(true);
+    grabKeyboard();
+    grabMouse(Qt::CrossCursor);
+    setMouseTracking(true);
+    m_colorBackup = m_color;
+    if (!m_eventFilter) {
+        m_eventFilter = new QColorPickingEventFilter(this, this);
+    }
+    installEventFilter(m_eventFilter);
+    updateGrabButton(true);
 }
 
-void
-SidePanelWidget::releaseColorGrab()
+void SidePanelWidget::releaseColorGrab()
 {
-  setMouseTracking(false);
-  removeEventFilter(m_eventFilter);
-  releaseMouse();
-  releaseKeyboard();
-  setFocus();
-  updateGrabButton(false);
+    setMouseTracking(false);
+    removeEventFilter(m_eventFilter);
+    releaseMouse();
+    releaseKeyboard();
+    setFocus();
+    updateGrabButton(false);
 }
 
-QColor
-SidePanelWidget::grabPixmapColor(const QPoint& p)
+QColor SidePanelWidget::grabPixmapColor(const QPoint& p)
 {
-  QColor c;
-  if (m_pixmap) {
-    QPixmap pixel = m_pixmap->copy(QRect(p, p));
-    c = pixel.toImage().pixel(0, 0);
-  }
-  return c;
+    QColor c;
+    if (m_pixmap) {
+        QPixmap pixel = m_pixmap->copy(QRect(p, p));
+        c = pixel.toImage().pixel(0, 0);
+    }
+    return c;
 }
 
-bool
-SidePanelWidget::handleKeyPress(QKeyEvent* e)
+bool SidePanelWidget::handleKeyPress(QKeyEvent* e)
 {
-  if (e->key() == Qt::Key_Space) {
-    emit togglePanel();
-  } else if (e->key() == Qt::Key_Escape) {
-    releaseColorGrab();
-    updateColor(m_colorBackup);
-  } else if (e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter) {
-    updateColor(grabPixmapColor(QCursor::pos()));
-    releaseColorGrab();
-    emit colorChanged(m_color);
-  }
-  return true;
+    if (e->key() == Qt::Key_Space) {
+        emit togglePanel();
+    } else if (e->key() == Qt::Key_Escape) {
+        releaseColorGrab();
+        updateColor(m_colorBackup);
+    } else if (e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter) {
+        updateColor(grabPixmapColor(QCursor::pos()));
+        releaseColorGrab();
+        emit colorChanged(m_color);
+    }
+    return true;
 }
 
-bool
-SidePanelWidget::handleMouseButtonPressed(QMouseEvent* e)
+bool SidePanelWidget::handleMouseButtonPressed(QMouseEvent* e)
 {
-  if (m_colorGrabButton->geometry().contains(e->pos()) ||
-      e->button() == Qt::RightButton) {
-    updateColorNoWheel(m_colorBackup);
-  } else if (e->button() == Qt::LeftButton) {
-    updateColor(grabPixmapColor(QCursor::pos()));
-  }
-  releaseColorGrab();
-  emit colorChanged(m_color);
-  return true;
+    if (m_colorGrabButton->geometry().contains(e->pos()) ||
+        e->button() == Qt::RightButton) {
+        updateColorNoWheel(m_colorBackup);
+    } else if (e->button() == Qt::LeftButton) {
+        updateColor(grabPixmapColor(QCursor::pos()));
+    }
+    releaseColorGrab();
+    emit colorChanged(m_color);
+    return true;
 }
 
-bool
-SidePanelWidget::handleMouseMove(QMouseEvent* e)
+bool SidePanelWidget::handleMouseMove(QMouseEvent* e)
 {
-  updateColorNoWheel(grabPixmapColor(e->globalPos()));
-  return true;
+    updateColorNoWheel(grabPixmapColor(e->globalPos()));
+    return true;
 }
 
-void
-SidePanelWidget::updateGrabButton(const bool activated)
+void SidePanelWidget::updateGrabButton(const bool activated)
 {
-  if (activated) {
-    m_colorGrabButton->setText(tr("Press ESC to cancel"));
-  } else {
-    m_colorGrabButton->setText(tr("Grab Color"));
-  }
+    if (activated) {
+        m_colorGrabButton->setText(tr("Press ESC to cancel"));
+    } else {
+        m_colorGrabButton->setText(tr("Grab Color"));
+    }
 }
diff --git a/src/widgets/panel/sidepanelwidget.h b/src/widgets/panel/sidepanelwidget.h
index 5ac935c0..beaaae29 100644
--- a/src/widgets/panel/sidepanelwidget.h
+++ b/src/widgets/panel/sidepanelwidget.h
@@ -28,47 +28,47 @@ class QSlider;
 
 class SidePanelWidget : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 
-  friend class QColorPickingEventFilter;
+    friend class QColorPickingEventFilter;
 
 public:
-  explicit SidePanelWidget(QPixmap* p, QWidget* parent = nullptr);
+    explicit SidePanelWidget(QPixmap* p, QWidget* parent = nullptr);
 
 signals:
-  void colorChanged(const QColor& c);
-  void thicknessChanged(const int& t);
-  void togglePanel();
+    void colorChanged(const QColor& c);
+    void thicknessChanged(const int& t);
+    void togglePanel();
 
 public slots:
-  void updateColor(const QColor& c);
-  void updateThickness(const int& t);
+    void updateColor(const QColor& c);
+    void updateThickness(const int& t);
 
 private slots:
-  void updateColorNoWheel(const QColor& c);
-  void updateCurrentThickness();
+    void updateColorNoWheel(const QColor& c);
+    void updateCurrentThickness();
 
 private slots:
-  void colorGrabberActivated();
-  void releaseColorGrab();
+    void colorGrabberActivated();
+    void releaseColorGrab();
 
 private:
-  QColor grabPixmapColor(const QPoint& p);
+    QColor grabPixmapColor(const QPoint& p);
 
-  bool handleKeyPress(QKeyEvent* e);
-  bool handleMouseButtonPressed(QMouseEvent* e);
-  bool handleMouseMove(QMouseEvent* e);
+    bool handleKeyPress(QKeyEvent* e);
+    bool handleMouseButtonPressed(QMouseEvent* e);
+    bool handleMouseMove(QMouseEvent* e);
 
-  void updateGrabButton(const bool activated);
+    void updateGrabButton(const bool activated);
 
-  QVBoxLayout* m_layout;
-  QPushButton* m_colorGrabButton;
-  color_widgets::ColorWheel* m_colorWheel;
-  QLabel* m_colorLabel;
-  QPixmap* m_pixmap;
-  QColor m_colorBackup;
-  QColor m_color;
-  QSlider* m_thicknessSlider;
-  int m_thickness;
-  QColorPickingEventFilter* m_eventFilter;
+    QVBoxLayout* m_layout;
+    QPushButton* m_colorGrabButton;
+    color_widgets::ColorWheel* m_colorWheel;
+    QLabel* m_colorLabel;
+    QPixmap* m_pixmap;
+    QColor m_colorBackup;
+    QColor m_color;
+    QSlider* m_thicknessSlider;
+    int m_thickness;
+    QColorPickingEventFilter* m_eventFilter;
 };
diff --git a/src/widgets/panel/utilitypanel.cpp b/src/widgets/panel/utilitypanel.cpp
index 6b08b51c..217a87ce 100644
--- a/src/widgets/panel/utilitypanel.cpp
+++ b/src/widgets/panel/utilitypanel.cpp
@@ -26,98 +26,93 @@
 UtilityPanel::UtilityPanel(QWidget* parent)
   : QWidget(parent)
 {
-  initInternalPanel();
-  setAttribute(Qt::WA_TransparentForMouseEvents);
-  setCursor(Qt::ArrowCursor);
+    initInternalPanel();
+    setAttribute(Qt::WA_TransparentForMouseEvents);
+    setCursor(Qt::ArrowCursor);
 
-  m_showAnimation = new QPropertyAnimation(m_internalPanel, "geometry", this);
-  m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad);
-  m_showAnimation->setDuration(300);
+    m_showAnimation = new QPropertyAnimation(m_internalPanel, "geometry", this);
+    m_showAnimation->setEasingCurve(QEasingCurve::InOutQuad);
+    m_showAnimation->setDuration(300);
 
-  m_hideAnimation = new QPropertyAnimation(m_internalPanel, "geometry", this);
-  m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad);
-  m_hideAnimation->setDuration(300);
+    m_hideAnimation = new QPropertyAnimation(m_internalPanel, "geometry", this);
+    m_hideAnimation->setEasingCurve(QEasingCurve::InOutQuad);
+    m_hideAnimation->setDuration(300);
 
-  connect(m_hideAnimation,
-          &QPropertyAnimation::finished,
-          m_internalPanel,
-          &QWidget::hide);
+    connect(m_hideAnimation,
+            &QPropertyAnimation::finished,
+            m_internalPanel,
+            &QWidget::hide);
 }
 
-QWidget*
-UtilityPanel::toolWidget() const
+QWidget* UtilityPanel::toolWidget() const
 {
-  return m_toolWidget;
+    return m_toolWidget;
 }
 
-void
-UtilityPanel::addToolWidget(QWidget* w)
+void UtilityPanel::addToolWidget(QWidget* w)
 {
-  if (m_toolWidget) {
-    m_toolWidget->deleteLater();
-  }
-  if (w) {
-    m_toolWidget = w;
-    m_toolWidget->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Preferred);
-    m_upLayout->addWidget(w);
-  }
+    if (m_toolWidget) {
+        m_toolWidget->deleteLater();
+    }
+    if (w) {
+        m_toolWidget = w;
+        m_toolWidget->setSizePolicy(QSizePolicy::Ignored,
+                                    QSizePolicy::Preferred);
+        m_upLayout->addWidget(w);
+    }
 }
 
-void
-UtilityPanel::clearToolWidget()
+void UtilityPanel::clearToolWidget()
 {
-  if (m_toolWidget) {
-    m_toolWidget->deleteLater();
-  }
+    if (m_toolWidget) {
+        m_toolWidget->deleteLater();
+    }
 }
 
-void
-UtilityPanel::pushWidget(QWidget* w)
+void UtilityPanel::pushWidget(QWidget* w)
 {
-  m_layout->insertWidget(m_layout->count() - 1, w);
+    m_layout->insertWidget(m_layout->count() - 1, w);
 }
 
-void
-UtilityPanel::toggle()
+void UtilityPanel::toggle()
 {
-  if (m_internalPanel->isHidden()) {
-    setAttribute(Qt::WA_TransparentForMouseEvents, false);
-    m_showAnimation->setStartValue(QRect(-width(), 0, 0, height()));
-    m_showAnimation->setEndValue(QRect(0, 0, width(), height()));
-    m_internalPanel->show();
-    m_showAnimation->start();
-  } else {
-    setAttribute(Qt::WA_TransparentForMouseEvents);
-    m_hideAnimation->setStartValue(QRect(0, 0, width(), height()));
-    m_hideAnimation->setEndValue(QRect(-width(), 0, 0, height()));
-    m_hideAnimation->start();
-  }
+    if (m_internalPanel->isHidden()) {
+        setAttribute(Qt::WA_TransparentForMouseEvents, false);
+        m_showAnimation->setStartValue(QRect(-width(), 0, 0, height()));
+        m_showAnimation->setEndValue(QRect(0, 0, width(), height()));
+        m_internalPanel->show();
+        m_showAnimation->start();
+    } else {
+        setAttribute(Qt::WA_TransparentForMouseEvents);
+        m_hideAnimation->setStartValue(QRect(0, 0, width(), height()));
+        m_hideAnimation->setEndValue(QRect(-width(), 0, 0, height()));
+        m_hideAnimation->start();
+    }
 }
 
-void
-UtilityPanel::initInternalPanel()
+void UtilityPanel::initInternalPanel()
 {
-  m_internalPanel = new QScrollArea(this);
-  m_internalPanel->setAttribute(Qt::WA_NoMousePropagation);
-  QWidget* widget = new QWidget();
-  m_internalPanel->setWidget(widget);
-  m_internalPanel->setWidgetResizable(true);
+    m_internalPanel = new QScrollArea(this);
+    m_internalPanel->setAttribute(Qt::WA_NoMousePropagation);
+    QWidget* widget = new QWidget();
+    m_internalPanel->setWidget(widget);
+    m_internalPanel->setWidgetResizable(true);
 
-  m_layout = new QVBoxLayout();
-  m_upLayout = new QVBoxLayout();
-  m_bottomLayout = new QVBoxLayout();
-  m_layout->addLayout(m_upLayout);
-  m_layout->addLayout(m_bottomLayout);
-  widget->setLayout(m_layout);
+    m_layout = new QVBoxLayout();
+    m_upLayout = new QVBoxLayout();
+    m_bottomLayout = new QVBoxLayout();
+    m_layout->addLayout(m_upLayout);
+    m_layout->addLayout(m_bottomLayout);
+    widget->setLayout(m_layout);
 
-  QPushButton* closeButton = new QPushButton(this);
-  closeButton->setText(tr("Close"));
-  connect(closeButton, &QPushButton::clicked, this, &UtilityPanel::toggle);
-  m_bottomLayout->addWidget(closeButton);
+    QPushButton* closeButton = new QPushButton(this);
+    closeButton->setText(tr("Close"));
+    connect(closeButton, &QPushButton::clicked, this, &UtilityPanel::toggle);
+    m_bottomLayout->addWidget(closeButton);
 
-  QColor bgColor = palette().window().color();
-  bgColor.setAlphaF(0.0);
-  m_internalPanel->setStyleSheet(
-    QStringLiteral("QScrollArea {background-color: %1}").arg(bgColor.name()));
-  m_internalPanel->hide();
+    QColor bgColor = palette().window().color();
+    bgColor.setAlphaF(0.0);
+    m_internalPanel->setStyleSheet(
+      QStringLiteral("QScrollArea {background-color: %1}").arg(bgColor.name()));
+    m_internalPanel->hide();
 }
diff --git a/src/widgets/panel/utilitypanel.h b/src/widgets/panel/utilitypanel.h
index ce143193..bc989a56 100644
--- a/src/widgets/panel/utilitypanel.h
+++ b/src/widgets/panel/utilitypanel.h
@@ -26,30 +26,30 @@ class QScrollArea;
 
 class UtilityPanel : public QWidget
 {
-  Q_OBJECT
+    Q_OBJECT
 public:
-  explicit UtilityPanel(QWidget* parent = nullptr);
+    explicit UtilityPanel(QWidget* parent = nullptr);
 
-  QWidget* toolWidget() const;
-  void addToolWidget(QWidget* w);
-  void clearToolWidget();
-  void pushWidget(QWidget* w);
+    QWidget* toolWidget() const;
+    void addToolWidget(QWidget* w);
+    void clearToolWidget();
+    void pushWidget(QWidget* w);
 
 signals:
-  void mouseEnter();
-  void mouseLeave();
+    void mouseEnter();
+    void mouseLeave();
 
 public slots:
-  void toggle();
+    void toggle();
 
 private:
-  void initInternalPanel();
-
-  QPointer<QWidget> m_toolWidget;
-  QScrollArea* m_internalPanel;
-  QVBoxLayout* m_upLayout;
-  QVBoxLayout* m_bottomLayout;
-  QVBoxLayout* m_layout;
-  QPropertyAnimation* m_showAnimation;
-  QPropertyAnimation* m_hideAnimation;
+    void initInternalPanel();
+
+    QPointer<QWidget> m_toolWidget;
+    QScrollArea* m_internalPanel;
+    QVBoxLayout* m_upLayout;
+    QVBoxLayout* m_bottomLayout;
+    QVBoxLayout* m_layout;
+    QPropertyAnimation* m_showAnimation;
+    QPropertyAnimation* m_hideAnimation;
 };
