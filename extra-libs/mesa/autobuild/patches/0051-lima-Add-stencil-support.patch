From 242ee0da742f82111dcb790ea39376c1381daea1 Mon Sep 17 00:00:00 2001
From: Andreas Baierl <ichgeh@imkreisrum.de>
Date: Tue, 7 Jan 2020 17:06:46 +0100
Subject: [PATCH 51/51] lima: Add stencil support

This re-enables and fixes support for stencil buffer.

It fixes 365 stencil related deqp tests. All tests that use INCR, INCR_WRAR,
DECR and DECR_WRAP as a stencil op still fail, but they also fail with the
blob, so we may ignore that for now.
We still have dEQP-GLES2.functional.depth_stencil_clear.depth_stencil_masked
failing, which is strange because it's the only one out of the
depth_stencil_clear.* set.

Reviewed-by: Vasily Khoruzhick <anarsoul@gmail.com>
Signed-off-by: Andreas Baierl <ichgeh@imkreisrum.de>
---
 src/gallium/drivers/lima/lima_draw.c   | 59 +++++++++++++++-----------
 src/gallium/drivers/lima/lima_parser.c | 32 ++++++++++++--
 2 files changed, 64 insertions(+), 27 deletions(-)

diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 992dd72276b..5adc1c7f33c 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -1000,7 +1000,6 @@ lima_calculate_alpha_blend(enum pipe_blend_func rgb_func, enum pipe_blend_func a
       0x0C000000; /* need check if this GLESv1 glAlphaFunc */
 }
 
-#if 0
 static int
 lima_stencil_op(enum pipe_stencil_op pipe)
 {
@@ -1024,7 +1023,6 @@ lima_stencil_op(enum pipe_stencil_op pipe)
    }
    return -1;
 }
-#endif
 
 static unsigned
 lima_calculate_depth_test(struct pipe_depth_state *depth, struct pipe_rasterizer_state *rst)
@@ -1092,30 +1090,43 @@ lima_pack_render_state(struct lima_context *ctx, const struct pipe_draw_info *in
    render->depth_range = float_to_ushort(ctx->viewport.near) |
       (float_to_ushort(ctx->viewport.far) << 16);
 
-#if 0
    struct pipe_stencil_state *stencil = ctx->zsa->base.stencil;
    struct pipe_stencil_ref *ref = &ctx->stencil_ref;
-   render->stencil_front = stencil[0].func |
-      (lima_stencil_op(stencil[0].fail_op) << 3) |
-      (lima_stencil_op(stencil[0].zfail_op) << 6) |
-      (lima_stencil_op(stencil[0].zpass_op) << 9) |
-      (ref->ref_value[0] << 16) |
-      (stencil[0].valuemask << 24);
-   render->stencil_back = stencil[1].func |
-      (lima_stencil_op(stencil[1].fail_op) << 3) |
-      (lima_stencil_op(stencil[1].zfail_op) << 6) |
-      (lima_stencil_op(stencil[1].zpass_op) << 9) |
-      (ref->ref_value[1] << 16) |
-      (stencil[1].valuemask << 24);
-#else
-   render->stencil_front = 0xff000007;
-   render->stencil_back = 0xff000007;
-#endif
-
-   /* seems not correct? */
-   //struct pipe_alpha_state *alpha = &ctx->zsa->base.alpha;
-   render->stencil_test = 0;
-   //(stencil->enabled ? 0xFF : 0x00) | (float_to_ubyte(alpha->ref_value) << 16)
+
+   if (stencil[0].enabled) { /* stencil is enabled */
+      render->stencil_front = stencil[0].func |
+         (lima_stencil_op(stencil[0].fail_op) << 3) |
+         (lima_stencil_op(stencil[0].zfail_op) << 6) |
+         (lima_stencil_op(stencil[0].zpass_op) << 9) |
+         (ref->ref_value[0] << 16) |
+         (stencil[0].valuemask << 24);
+      render->stencil_back = render->stencil_front;
+      render->stencil_test = (stencil[0].writemask & 0xff) | (stencil[0].writemask & 0xff) << 8;
+      if (stencil[1].enabled) { /* two-side is enabled */
+         render->stencil_back = stencil[1].func |
+            (lima_stencil_op(stencil[1].fail_op) << 3) |
+            (lima_stencil_op(stencil[1].zfail_op) << 6) |
+            (lima_stencil_op(stencil[1].zpass_op) << 9) |
+            (ref->ref_value[1] << 16) |
+            (stencil[1].valuemask << 24);
+         render->stencil_test = (stencil[0].writemask & 0xff) | (stencil[1].writemask & 0xff) << 8;
+      }
+      /* TODO: Find out, what (render->stecil_test & 0xffff0000) is.
+       * 0x00ff0000 is probably (float_to_ubyte(alpha->ref_value) << 16)
+       * (render->multi_sample & 0x00000007 is probably the compare function
+       * of glAlphaFunc then.
+       */
+   }
+   else {
+      /* Default values, when stencil is disabled:
+       * stencil[0|1].valuemask = 0xff
+       * stencil[0|1].func = PIPE_FUNC_ALWAYS
+       * stencil[0|1].writemask = 0xff
+       */
+      render->stencil_front = 0xff000007;
+      render->stencil_back = 0xff000007;
+      render->stencil_test = 0x0000ffff;
+   }
 
    /* need more investigation */
    if (info->mode == PIPE_PRIM_POINTS)
diff --git a/src/gallium/drivers/lima/lima_parser.c b/src/gallium/drivers/lima/lima_parser.c
index 44f8c63b240..f2c56bc663c 100644
--- a/src/gallium/drivers/lima/lima_parser.c
+++ b/src/gallium/drivers/lima/lima_parser.c
@@ -492,13 +492,39 @@ parse_rsw(FILE *fp, uint32_t *value, int i, uint32_t *helper)
               (float)(ushort_to_float(*value & 0x0000ffff)));
       break;
    case 5: /* STENCIL FRONT */
-      fprintf(fp, " (to investigate) */\n");
+      fprintf(fp, "(1): valuemask 0x%02x, ref value %d (0x%02x), stencil_func %d */\n",
+              (*value & 0xff000000) >> 24, /* valuemask */
+              (*value & 0x00ff0000) >> 16, (*value & 0x00ff0000) >> 16, /* ref value */
+              (*value & 0x00000007)); /* stencil_func */
+      /* add a few tabs for alignment */
+      fprintf(fp, "\t\t\t\t\t\t/* %s(2)", render_state_infos[i].info);
+      fprintf(fp, ": fail_op %d, zfail_op %d, zpass_op %d, unknown (12-15) 0x%02x */\n",
+              (*value & 0x00000038) >> 3, /* fail_op */
+              (*value & 0x000001c0) >> 6, /* zfail_op */
+              (*value & 0x00000e00) >> 9, /* zpass_op */
+              (*value & 0x0000f000) >> 12); /* unknown */
       break;
    case 6: /* STENCIL BACK */
-      fprintf(fp, " (to investigate) */\n");
+      fprintf(fp, "(1): valuemask 0x%02x, ref value %d (0x%02x), stencil_func %d */\n",
+              (*value & 0xff000000) >> 24, /* valuemask */
+              (*value & 0x00ff0000) >> 16, (*value & 0x00ff0000) >> 16, /* ref value */
+              (*value & 0x00000007)); /* stencil_func */
+      /* add a few tabs for alignment */
+      fprintf(fp, "\t\t\t\t\t\t/* %s(2)", render_state_infos[i].info);
+      fprintf(fp, ": fail_op %d, zfail_op %d, zpass_op %d, unknown (12-15) 0x%02x */\n",
+              (*value & 0x00000038) >> 3, /* fail_op */
+              (*value & 0x000001c0) >> 6, /* zfail_op */
+              (*value & 0x00000e00) >> 9, /* zpass_op */
+              (*value & 0x0000f000) >> 12); /* unknown */
       break;
    case 7: /* STENCIL TEST */
-      fprintf(fp, " (to investigate) */\n");
+      fprintf(fp, "(1): stencil_front writemask 0x%02x, stencil_back writemask 0x%02x */\n",
+              (*value & 0x000000ff), /* front writemask */
+              (*value & 0x0000ff00) >> 8); /* back writemask */
+      /* add a few tabs for alignment */
+      fprintf(fp, "\t\t\t\t\t\t/* %s(2)", render_state_infos[i].info);
+      fprintf(fp, ": unknown (bits 16-31) 0x%04x */\n",
+              (*value & 0xffff0000) >> 16); /* unknown, alpha ref_value? */
       break;
    case 8: /* MULTI SAMPLE */
       if ((*value & 0x00000f00) == 0x00000000)
-- 
2.23.0

