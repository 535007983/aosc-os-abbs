From f62a2fe28d8bba0ac75c066311cd100cef6411f0 Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Wed, 22 Jan 2020 00:42:14 +0100
Subject: [PATCH 063/102] lima/ppir: split ppir_op_undef into undef and dummy
 again

Those were renamed/merged some time ago but it turns out that
ppir_op_undef can't be shared.
It was being used for undefined ssa operations and for read-before-write
operations that may happen to e.g. uninitialized registers (non-ssa)
inside a loop.
We really don't want to reserve a register for the undef ssa case, but
we must reserve and allocate register for the unitialized register case
because when it happens inside a loop it may need to hold its value
across iterations.

This dummy node might be eliminated with a code refactor in ppir in case
we are able to emit the write and allocate the ppir_reg before we emit
the read. But a major refactor we need this to keep this code to avoid
apparent regressions with the new liveness analysis implementation.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
Reviewed-by: Vasily Khoruzhick <anarsoul@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/merge_requests/3502>
---
 src/gallium/drivers/lima/ir/pp/nir.c  | 4 ++--
 src/gallium/drivers/lima/ir/pp/node.c | 6 ++++++
 src/gallium/drivers/lima/ir/pp/ppir.h | 1 +
 3 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/lima/ir/pp/nir.c b/src/gallium/drivers/lima/ir/pp/nir.c
index 9798d16dd1e..61664a02941 100644
--- a/src/gallium/drivers/lima/ir/pp/nir.c
+++ b/src/gallium/drivers/lima/ir/pp/nir.c
@@ -156,12 +156,12 @@ static void ppir_node_add_src(ppir_compiler *comp, ppir_node *node,
          child = comp->var_nodes[(reg->index << 2) + comp->reg_base + swizzle];
          /* Reg is read before it was written, create a dummy node for it */
          if (!child) {
-            child = ppir_node_create_reg(node->block, ppir_op_undef, reg,
+            child = ppir_node_create_reg(node->block, ppir_op_dummy, reg,
                u_bit_consecutive(0, 4));
             comp->var_nodes[(reg->index << 2) + comp->reg_base + swizzle] = child;
          }
          /* Don't add dummies or recursive deps for ops like r1 = r1 + ssa1 */
-         if (child && node != child && child->op != ppir_op_undef)
+         if (child && node != child && child->op != ppir_op_dummy)
             ppir_node_add_dep(node, child, ppir_dep_src);
       }
    }
diff --git a/src/gallium/drivers/lima/ir/pp/node.c b/src/gallium/drivers/lima/ir/pp/node.c
index 5090d1b9921..e646a395ca7 100644
--- a/src/gallium/drivers/lima/ir/pp/node.c
+++ b/src/gallium/drivers/lima/ir/pp/node.c
@@ -348,6 +348,12 @@ const ppir_op_info ppir_op_infos[] = {
       .slots = (int []) {
       },
    },
+   [ppir_op_dummy] = {
+      .name = "dummy",
+      .type = ppir_node_type_alu,
+      .slots = (int []) {
+      },
+   },
 };
 
 void *ppir_node_create(ppir_block *block, ppir_op op, int index, unsigned mask)
diff --git a/src/gallium/drivers/lima/ir/pp/ppir.h b/src/gallium/drivers/lima/ir/pp/ppir.h
index f58dd8be730..b2637cb68c3 100644
--- a/src/gallium/drivers/lima/ir/pp/ppir.h
+++ b/src/gallium/drivers/lima/ir/pp/ppir.h
@@ -116,6 +116,7 @@ typedef enum {
    ppir_op_branch,
 
    ppir_op_undef,
+   ppir_op_dummy,
 
    ppir_op_num,
 } ppir_op;
-- 
2.24.1

