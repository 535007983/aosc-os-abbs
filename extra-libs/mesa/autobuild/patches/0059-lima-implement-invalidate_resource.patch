From 899f7590a6a9a1b80d3b2ac49f1d4327a8d80ae4 Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Wed, 4 Dec 2019 19:27:43 -0800
Subject: [PATCH 059/102] lima: implement invalidate_resource()

We don't need to resolve invalidated resources, so it should
improve performance for applications that are doing this hint.

Reviewed-by: Qiang Yu <yuq825@gmail.com>
Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>
Tested-by: Marge Bot <https://gitlab.freedesktop.org/mesa/mesa/merge_requests/3476>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/merge_requests/3476>
---
 src/gallium/drivers/lima/lima_context.c | 26 +++++++++++++------------
 src/gallium/drivers/lima/lima_context.h |  2 ++
 src/gallium/drivers/lima/lima_draw.c    | 24 +++++++++++++++++------
 3 files changed, 34 insertions(+), 18 deletions(-)

diff --git a/src/gallium/drivers/lima/lima_context.c b/src/gallium/drivers/lima/lima_context.c
index e2d48d155a3..b2a205f26d4 100644
--- a/src/gallium/drivers/lima/lima_context.c
+++ b/src/gallium/drivers/lima/lima_context.c
@@ -104,6 +104,19 @@ lima_context_free_drm_ctx(struct lima_screen *screen, int id)
    drmIoctl(screen->fd, DRM_IOCTL_LIMA_CTX_FREE, &req);
 }
 
+static void
+lima_invalidate_resource(struct pipe_context *pctx, struct pipe_resource *prsc)
+{
+   struct lima_context *ctx = lima_context(pctx);
+
+   if (ctx->framebuffer.base.zsbuf && (ctx->framebuffer.base.zsbuf->texture == prsc))
+      ctx->resolve &= ~(PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL);
+
+   if (ctx->framebuffer.base.nr_cbufs &&
+       (ctx->framebuffer.base.cbufs[0]->texture == prsc))
+      ctx->resolve &= ~PIPE_CLEAR_COLOR0;
+}
+
 static void
 lima_context_destroy(struct pipe_context *pctx)
 {
@@ -192,6 +205,7 @@ lima_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    ctx->base.screen = pscreen;
    ctx->base.destroy = lima_context_destroy;
    ctx->base.set_debug_callback = lima_set_debug_callback;
+   ctx->base.invalidate_resource = lima_invalidate_resource;
 
    lima_resource_context_init(ctx);
    lima_fence_context_init(ctx);
@@ -273,15 +287,3 @@ lima_need_flush(struct lima_context *ctx, struct lima_bo *bo, bool write)
    return lima_submit_has_bo(ctx->gp_submit, bo, write) ||
       lima_submit_has_bo(ctx->pp_submit, bo, write);
 }
-
-bool
-lima_is_scanout(struct lima_context *ctx)
-{
-        /* If there is no color buffer, it's an FBO */
-        if (!ctx->framebuffer.base.nr_cbufs)
-                return false;
-
-        return ctx->framebuffer.base.cbufs[0]->texture->bind & PIPE_BIND_DISPLAY_TARGET ||
-               ctx->framebuffer.base.cbufs[0]->texture->bind & PIPE_BIND_SCANOUT ||
-               ctx->framebuffer.base.cbufs[0]->texture->bind & PIPE_BIND_SHARED;
-}
diff --git a/src/gallium/drivers/lima/lima_context.h b/src/gallium/drivers/lima/lima_context.h
index e62630b7a6d..304576b7b6d 100644
--- a/src/gallium/drivers/lima/lima_context.h
+++ b/src/gallium/drivers/lima/lima_context.h
@@ -187,6 +187,8 @@ struct lima_context {
       LIMA_CONTEXT_DIRTY_TEXTURES     = (1 << 14),
    } dirty;
 
+   unsigned resolve;
+
    struct u_upload_mgr *uploader;
    struct blitter_context *blitter;
 
diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 18426f6b0d4..1bbe853b3ff 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -680,6 +680,8 @@ lima_clear(struct pipe_context *pctx, unsigned buffers,
 
    lima_flush(ctx);
 
+   ctx->resolve |= buffers;
+
    /* no need to reload if cleared */
    if (ctx->framebuffer.base.nr_cbufs && (buffers & PIPE_CLEAR_COLOR0)) {
       struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
@@ -1522,6 +1524,17 @@ lima_draw_vbo_update(struct pipe_context *pctx,
       ctx->gp_output = NULL;
    }
 
+   if (ctx->framebuffer.base.zsbuf) {
+      if (ctx->zsa->base.depth.enabled)
+         ctx->resolve |= PIPE_CLEAR_DEPTH;
+      if (ctx->zsa->base.stencil[0].enabled ||
+          ctx->zsa->base.stencil[1].enabled)
+         ctx->resolve |= PIPE_CLEAR_STENCIL;
+   }
+
+   if (ctx->framebuffer.base.nr_cbufs)
+      ctx->resolve |= PIPE_CLEAR_COLOR0;
+
    ctx->dirty = 0;
 }
 
@@ -1719,14 +1732,11 @@ lima_pack_pp_frame_reg(struct lima_context *ctx, uint32_t *frame_reg,
    frame->blocking = (fb->shift_min << 28) | (fb->shift_h << 16) | fb->shift_w;
    frame->foureight = 0x8888;
 
-   if (fb->base.nr_cbufs)
+   if (fb->base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0))
       lima_pack_wb_cbuf_reg(ctx, wb_reg, wb_idx++);
 
-   /* Mali4x0 can use on-tile buffer for depth/stencil, so to save some
-    * memory bandwidth don't write depth/stencil back to memory if we're
-    * rendering to scanout
-    */
-   if (!lima_is_scanout(ctx) && fb->base.zsbuf)
+   if (fb->base.zsbuf &&
+       (ctx->resolve & (PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL)))
       lima_pack_wb_zsbuf_reg(ctx, wb_reg, wb_idx++);
 }
 
@@ -1883,6 +1893,8 @@ _lima_flush(struct lima_context *ctx, bool end_of_frame)
    ctx->damage_rect.minx = ctx->damage_rect.miny = 0xffff;
    ctx->damage_rect.maxx = ctx->damage_rect.maxy = 0;
 
+   ctx->resolve = 0;
+
    lima_dump_file_next();
 }
 
-- 
2.24.1

