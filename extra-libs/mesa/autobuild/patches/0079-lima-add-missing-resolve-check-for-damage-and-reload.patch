From 98e5ce81937b4a7dc8c6d12bfde3ae70db604566 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 12 Feb 2020 11:07:03 +0800
Subject: [PATCH 079/102] lima: add missing resolve check for damage and reload

If color buffer is not touched, we do not need to reload or get
damage region from it.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/lima/lima_draw.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 94e7f61b730..04696bb0fc6 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -218,7 +218,7 @@ lima_ctx_dirty(struct lima_context *ctx)
 static inline struct lima_damage_region *
 lima_ctx_get_damage(struct lima_context *ctx)
 {
-   if (!ctx->framebuffer.base.nr_cbufs)
+   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
       return NULL;
 
    struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
@@ -230,7 +230,7 @@ static bool
 lima_fb_need_reload(struct lima_context *ctx)
 {
    /* Depth buffer is always discarded */
-   if (!ctx->framebuffer.base.nr_cbufs)
+   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
       return false;
 
    struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
@@ -1897,7 +1897,7 @@ _lima_flush(struct lima_context *ctx, bool end_of_frame)
 
    ctx->plb_index = (ctx->plb_index + 1) % lima_ctx_num_plb;
 
-   if (ctx->framebuffer.base.nr_cbufs) {
+   if (ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)) {
       /* Set reload flag for next draw. It'll be unset if buffer is cleared */
       struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
       surf->reload = true;
-- 
2.24.1

