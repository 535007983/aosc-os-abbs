From ca8fc3514fa31e90ede48e63449cd236a7cfde34 Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Fri, 1 Nov 2019 19:23:57 -0700
Subject: [PATCH 010/102] lima: add support for gl_PointSize

GP handles gl_PointSize similar to gl_Position, i.e. it needs
separate buffer and it has special type in varying descriptors, also
for indexed draw we need to emit special PLBU command to pass
address of gl_PointSize buffer.

Blob also clamps gl_PointSize to 1 .. 100 (as well as line width),
so let's do the same.

Reviewed-by: Andreas Baierl <ichgeh@imkreisrum.de>
Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>
---
 src/gallium/drivers/lima/ir/gp/nir.c    | 19 ++++-
 src/gallium/drivers/lima/lima_context.h |  6 +-
 src/gallium/drivers/lima/lima_draw.c    | 94 ++++++++++++++++++-------
 src/gallium/drivers/lima/lima_program.c |  1 +
 src/gallium/drivers/lima/lima_screen.c  |  2 +-
 5 files changed, 90 insertions(+), 32 deletions(-)

diff --git a/src/gallium/drivers/lima/ir/gp/nir.c b/src/gallium/drivers/lima/ir/gp/nir.c
index e405e1a6c62..9916a057656 100644
--- a/src/gallium/drivers/lima/ir/gp/nir.c
+++ b/src/gallium/drivers/lima/ir/gp/nir.c
@@ -457,6 +457,8 @@ bool gpir_compile_nir(struct lima_vs_shader_state *prog, struct nir_shader *nir,
 
    comp->constant_base = nir->num_uniforms;
    prog->uniform_pending_offset = nir->num_uniforms * 16;
+   prog->gl_pos_idx = 0;
+   prog->point_size_idx = -1;
 
    if (!gpir_emit_function(comp, func))
       goto err_out0;
@@ -483,13 +485,24 @@ bool gpir_compile_nir(struct lima_vs_shader_state *prog, struct nir_shader *nir,
       goto err_out0;
 
    nir_foreach_variable(var, &nir->outputs) {
-      if (var->data.location == VARYING_SLOT_POS)
-         assert(var->data.driver_location == 0);
+      bool varying = true;
+      switch (var->data.location) {
+      case VARYING_SLOT_POS:
+         prog->gl_pos_idx = var->data.driver_location;
+         varying = false;
+         break;
+      case VARYING_SLOT_PSIZ:
+         prog->point_size_idx = var->data.driver_location;
+         varying = false;
+         break;
+      }
 
       struct lima_varying_info *v = prog->varying + var->data.driver_location;
       if (!v->components) {
          v->component_size = gpir_glsl_type_size(glsl_get_base_type(var->type));
-         prog->num_varying++;
+         prog->num_outputs++;
+         if (varying)
+            prog->num_varyings++;
       }
 
       v->components += glsl_get_components(var->type);
diff --git a/src/gallium/drivers/lima/lima_context.h b/src/gallium/drivers/lima/lima_context.h
index 3d8bf6c2b3f..7a0e7e8367f 100644
--- a/src/gallium/drivers/lima/lima_context.h
+++ b/src/gallium/drivers/lima/lima_context.h
@@ -81,7 +81,10 @@ struct lima_vs_shader_state {
 
    struct lima_varying_info varying[LIMA_MAX_VARYING_NUM];
    int varying_stride;
-   int num_varying;
+   int num_outputs;
+   int num_varyings;
+   int gl_pos_idx;
+   int point_size_idx;
 
    struct lima_bo *bo;
 };
@@ -120,6 +123,7 @@ struct lima_context_constant_buffer {
 enum lima_ctx_buff {
    lima_ctx_buff_sh_varying,
    lima_ctx_buff_sh_gl_pos,
+   lima_ctx_buff_sh_gl_point_size,
    lima_ctx_buff_gp_varying_info,
    lima_ctx_buff_gp_attribute_info,
    lima_ctx_buff_gp_uniform,
diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index bb603d45180..773614879f9 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -147,8 +147,8 @@ struct lima_render_state {
 #define PLBU_CMD_VIEWPORT_TOP(v) PLBU_CMD(v, 0x10000106)
 #define PLBU_CMD_ARRAYS_SEMAPHORE_BEGIN() PLBU_CMD(0x00010002, 0x60000000)
 #define PLBU_CMD_ARRAYS_SEMAPHORE_END() PLBU_CMD(0x00010001, 0x60000000)
-#define PLBU_CMD_PRIMITIVE_SETUP(low_prim, cull, index_size) \
-   PLBU_CMD(((low_prim) ? 0x00003200 : 0x00002200) | (cull) | ((index_size) << 9), 0x1000010B)
+#define PLBU_CMD_PRIMITIVE_SETUP(prim, cull, index_size) \
+   PLBU_CMD(0x200 | (prim) | (cull) | ((index_size) << 9), 0x1000010B)
 #define PLBU_CMD_RSW_VERTEX_ARRAY(rsw, gl_pos) \
    PLBU_CMD(rsw, 0x80000000 | ((gl_pos) >> 4))
 #define PLBU_CMD_SCISSORS(minx, maxx, miny, maxy) \
@@ -160,6 +160,7 @@ struct lima_render_state {
 #define PLBU_CMD_DEPTH_RANGE_NEAR(v) PLBU_CMD(v, 0x1000010E)
 #define PLBU_CMD_DEPTH_RANGE_FAR(v) PLBU_CMD(v, 0x1000010F)
 #define PLBU_CMD_INDEXED_DEST(gl_pos) PLBU_CMD(gl_pos, 0x10000100)
+#define PLBU_CMD_INDEXED_PT_SIZE(pt_size) PLBU_CMD(pt_size, 0x10000102)
 #define PLBU_CMD_INDICES(va) PLBU_CMD(va, 0x10000101)
 #define PLBU_CMD_DRAW_ARRAYS(mode, start, count) \
    PLBU_CMD(((count) << 24) | (start), (((mode) & 0x1F) << 16) | ((count) >> 8))
@@ -739,9 +740,9 @@ lima_pack_vs_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
    VS_CMD_SHADER_ADDRESS(ctx->vs->bo->va, ctx->vs->shader_size);
    VS_CMD_SHADER_INFO(ctx->vs->prefetch, ctx->vs->shader_size);
 
-   int num_varryings = ctx->vs->num_varying;
+   int num_outputs = ctx->vs->num_outputs;
    int num_attributes = ctx->vertex_elements->num_elements;
-   VS_CMD_VARYING_ATTRIBUTE_COUNT(num_varryings, MAX2(1, num_attributes));
+   VS_CMD_VARYING_ATTRIBUTE_COUNT(num_outputs, MAX2(1, num_attributes));
 
    VS_CMD_UNKNOWN1();
 
@@ -751,7 +752,7 @@ lima_pack_vs_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
 
    VS_CMD_VARYINGS_ADDRESS(
       lima_ctx_buff_va(ctx, lima_ctx_buff_gp_varying_info, LIMA_CTX_BUFF_SUBMIT_GP),
-      num_varryings);
+      num_outputs);
 
    unsigned num = info->index_size ? (ctx->max_index - ctx->min_index + 1) : info->count;
    VS_CMD_DRAW(num, info->index_size);
@@ -767,6 +768,7 @@ static void
 lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
 {
    struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_vs_shader_state *vs = ctx->vs;
 
    lima_pack_head_plbu_cmd(ctx);
 
@@ -774,7 +776,7 @@ lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
    if (lima_is_scissor_zero(ctx))
       return;
 
-   PLBU_CMD_BEGIN(30);
+   PLBU_CMD_BEGIN(32);
 
    PLBU_CMD_VIEWPORT_LEFT(fui(ctx->viewport.left));
    PLBU_CMD_VIEWPORT_RIGHT(fui(ctx->viewport.right));
@@ -784,7 +786,6 @@ lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
    if (!info->index_size)
       PLBU_CMD_ARRAYS_SEMAPHORE_BEGIN();
 
-   bool low_prim = info->mode < PIPE_PRIM_TRIANGLES;
    int cf = ctx->rasterizer->base.cull_face;
    int ccw = ctx->rasterizer->base.front_ccw;
    uint32_t cull = 0;
@@ -794,7 +795,13 @@ lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
       if (cf & PIPE_FACE_BACK)
          cull |= ccw ? 0x00020000 : 0x00040000;
    }
-   PLBU_CMD_PRIMITIVE_SETUP(low_prim, cull, info->index_size);
+
+   if (info->mode == PIPE_PRIM_POINTS && ctx->vs->point_size_idx != -1)
+      PLBU_CMD_PRIMITIVE_SETUP(0x0000, cull, info->index_size);
+   else if (info->mode < PIPE_PRIM_TRIANGLES)
+      PLBU_CMD_PRIMITIVE_SETUP(0x3000, cull, info->index_size);
+   else
+      PLBU_CMD_PRIMITIVE_SETUP(0x2000, cull, info->index_size);
 
    uint32_t gl_position_va =
       lima_ctx_buff_va(ctx, lima_ctx_buff_sh_gl_pos,
@@ -819,7 +826,9 @@ lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
    PLBU_CMD_DEPTH_RANGE_NEAR(fui(ctx->viewport.near));
    PLBU_CMD_DEPTH_RANGE_FAR(fui(ctx->viewport.far));
 
-   if (low_prim) {
+   if ((info->mode == PIPE_PRIM_POINTS && ctx->vs->point_size_idx == -1) ||
+       ((info->mode >= PIPE_PRIM_LINES) && (info->mode < PIPE_PRIM_TRIANGLES)))
+   {
       uint32_t v = info->mode == PIPE_PRIM_POINTS ?
          fui(ctx->rasterizer->base.point_size) : fui(ctx->rasterizer->base.line_width);
       PLBU_CMD_LOW_PRIM_SIZE(v);
@@ -827,6 +836,13 @@ lima_pack_plbu_cmd(struct lima_context *ctx, const struct pipe_draw_info *info)
 
    if (info->index_size) {
       PLBU_CMD_INDEXED_DEST(gl_position_va);
+      if (vs->point_size_idx != -1) {
+         uint32_t gl_point_size_va =
+            lima_ctx_buff_va(ctx, lima_ctx_buff_sh_gl_point_size,
+                             LIMA_CTX_BUFF_SUBMIT_GP |
+                             LIMA_CTX_BUFF_SUBMIT_PP);
+         PLBU_CMD_INDEXED_PT_SIZE(gl_point_size_va);
+      }
 
       struct pipe_resource *indexbuf = NULL;
       unsigned index_offset = 0;
@@ -1100,20 +1116,23 @@ lima_pack_render_state(struct lima_context *ctx, const struct pipe_draw_info *in
       render->aux1 |= 0x10000;
    }
 
-   if (ctx->vs->num_varying > 1) {
+   if (ctx->vs->num_varyings) {
       render->varying_types = 0x00000000;
       render->varyings_address =
          lima_ctx_buff_va(ctx, lima_ctx_buff_sh_varying, LIMA_CTX_BUFF_SUBMIT_PP);
-      for (int i = 1; i < ctx->vs->num_varying; i++) {
+      for (int i = 0, index = 0; i < ctx->vs->num_outputs; i++) {
          int val;
 
+         if (i == ctx->vs->gl_pos_idx ||
+             i == ctx->vs->point_size_idx)
+            continue;
+
          struct lima_varying_info *v = ctx->vs->varying + i;
          if (v->component_size == 4)
             val = v->components > 2 ? 0 : 1;
          else
             val = v->components > 2 ? 2 : 3;
 
-         int index = i - 1;
          if (index < 10)
             render->varying_types |= val << (3 * index);
          else if (index == 10) {
@@ -1122,6 +1141,8 @@ lima_pack_render_state(struct lima_context *ctx, const struct pipe_draw_info *in
          }
          else if (index == 11)
             render->varyings_address |= val << 1;
+
+         index++;
       }
    }
    else {
@@ -1236,7 +1257,7 @@ lima_update_varying(struct lima_context *ctx, const struct pipe_draw_info *info)
 
    uint32_t *varying =
       lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_varying_info,
-                          vs->num_varying * 8, true);
+                          vs->num_outputs * 8, true);
    int n = 0;
 
    /* should be LIMA_SUBMIT_BO_WRITE for GP, but each draw will use
@@ -1244,15 +1265,15 @@ lima_update_varying(struct lima_context *ctx, const struct pipe_draw_info *info)
    lima_ctx_buff_alloc(ctx, lima_ctx_buff_sh_gl_pos,
                        4 * 4 * info->count, false);
 
-   /* for gl_Position */
-   varying[n++] =
-      lima_ctx_buff_va(ctx, lima_ctx_buff_sh_gl_pos,
-                       LIMA_CTX_BUFF_SUBMIT_GP | LIMA_CTX_BUFF_SUBMIT_PP);
-   varying[n++] = 0x8020;
-
    int offset = 0;
-   for (int i = 1; i < vs->num_varying; i++) {
+
+   for (int i = 0; i < vs->num_outputs; i++) {
       struct lima_varying_info *v = vs->varying + i;
+
+      if (i == vs->gl_pos_idx ||
+          i == vs->point_size_idx)
+         continue;
+
       int size = v->component_size * 4;
 
       /* does component_size == 2 need to be 16 aligned? */
@@ -1262,19 +1283,38 @@ lima_update_varying(struct lima_context *ctx, const struct pipe_draw_info *info)
       v->offset = offset;
       offset += size;
    }
+
    vs->varying_stride = align(offset, 16);
 
-   if (vs->num_varying > 1)
+   if (vs->num_varyings)
       lima_ctx_buff_alloc(ctx, lima_ctx_buff_sh_varying,
                           vs->varying_stride * info->count, false);
 
-   for (int i = 1; i < vs->num_varying; i++) {
+   for (int i = 0; i < vs->num_outputs; i++) {
       struct lima_varying_info *v = vs->varying + i;
-      varying[n++] =
-         lima_ctx_buff_va(ctx, lima_ctx_buff_sh_varying, LIMA_CTX_BUFF_SUBMIT_GP) +
-         v->offset;
-      varying[n++] = (vs->varying_stride << 11) | (v->components - 1) |
-         (v->component_size == 2 ? 0x0C : 0);
+
+      if (i == vs->gl_pos_idx) {
+         /* gl_Position */
+         varying[n++] =
+            lima_ctx_buff_va(ctx, lima_ctx_buff_sh_gl_pos,
+                             LIMA_CTX_BUFF_SUBMIT_GP | LIMA_CTX_BUFF_SUBMIT_PP);
+         varying[n++] = 0x8020;
+      } else if (i == vs->point_size_idx) {
+         /* gl_PointSize */
+         lima_ctx_buff_alloc(ctx, lima_ctx_buff_sh_gl_point_size,
+                             4 * info->count, false);
+         varying[n++] =
+            lima_ctx_buff_va(ctx, lima_ctx_buff_sh_gl_point_size,
+                             LIMA_CTX_BUFF_SUBMIT_GP | LIMA_CTX_BUFF_SUBMIT_PP);
+         varying[n++] = 0x2021;
+      } else {
+         /* Varying */
+         varying[n++] =
+            lima_ctx_buff_va(ctx, lima_ctx_buff_sh_varying, LIMA_CTX_BUFF_SUBMIT_GP) +
+            v->offset;
+         varying[n++] = (vs->varying_stride << 11) | (v->components - 1) |
+            (v->component_size == 2 ? 0x0C : 0);
+      }
    }
 
    lima_dump_command_stream_print(
diff --git a/src/gallium/drivers/lima/lima_program.c b/src/gallium/drivers/lima/lima_program.c
index e1237642482..3fd7b0711a6 100644
--- a/src/gallium/drivers/lima/lima_program.c
+++ b/src/gallium/drivers/lima/lima_program.c
@@ -101,6 +101,7 @@ lima_program_optimize_vs_nir(struct nir_shader *s)
    bool progress;
 
    NIR_PASS_V(s, nir_lower_viewport_transform);
+   NIR_PASS_V(s, nir_lower_point_size, 1.0f, 100.0f);
    NIR_PASS_V(s, nir_lower_io, nir_var_all, type_size, 0);
    NIR_PASS_V(s, nir_lower_load_const_to_scalar);
    NIR_PASS_V(s, lima_nir_lower_uniform_to_scalar);
diff --git a/src/gallium/drivers/lima/lima_screen.c b/src/gallium/drivers/lima/lima_screen.c
index d8f5c3b4fd9..60020f28a0c 100644
--- a/src/gallium/drivers/lima/lima_screen.c
+++ b/src/gallium/drivers/lima/lima_screen.c
@@ -157,7 +157,7 @@ lima_screen_get_paramf(struct pipe_screen *pscreen, enum pipe_capf param)
    case PIPE_CAPF_MAX_LINE_WIDTH_AA:
    case PIPE_CAPF_MAX_POINT_WIDTH:
    case PIPE_CAPF_MAX_POINT_WIDTH_AA:
-      return 255.0f;
+      return 100.0f;
    case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
       return 16.0f;
    case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
-- 
2.24.1

