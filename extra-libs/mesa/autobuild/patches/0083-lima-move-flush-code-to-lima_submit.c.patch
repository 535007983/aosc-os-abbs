From 10a190025218ca1952c9e3856ac579464238077b Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 8 Feb 2020 19:24:34 +0800
Subject: [PATCH 083/102] lima: move flush code to lima_submit.c

Just code move, no content change.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/lima/lima_draw.c   | 735 ------------------------
 src/gallium/drivers/lima/lima_submit.c | 745 ++++++++++++++++++++++++-
 src/gallium/drivers/lima/lima_submit.h |   2 -
 3 files changed, 743 insertions(+), 739 deletions(-)

diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 710d3852b1d..fbc5b714aea 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -23,14 +23,12 @@
  *
  */
 
-#include "util/u_math.h"
 #include "util/u_format.h"
 #include "util/u_debug.h"
 #include "util/u_half.h"
 #include "util/u_helpers.h"
 #include "util/u_inlines.h"
 #include "util/u_pack_color.h"
-#include "util/hash_table.h"
 #include "util/u_split_draw.h"
 #include "util/u_upload_mgr.h"
 #include "util/u_prim.h"
@@ -44,170 +42,10 @@
 #include "lima_submit.h"
 #include "lima_texture.h"
 #include "lima_util.h"
-#include "lima_fence.h"
-#include "lima_format.h"
 #include "lima_gpu.h"
 
-#include <xf86drm.h>
 #include <drm-uapi/lima_drm.h>
 
-static inline bool
-lima_ctx_dirty(struct lima_context *ctx)
-{
-   return !!ctx->resolve;
-}
-
-static inline struct lima_damage_region *
-lima_ctx_get_damage(struct lima_context *ctx)
-{
-   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
-      return NULL;
-
-   struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
-   struct lima_resource *res = lima_resource(surf->base.texture);
-   return &res->damage;
-}
-
-static bool
-lima_fb_need_reload(struct lima_context *ctx)
-{
-   /* Depth buffer is always discarded */
-   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
-      return false;
-
-   struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
-   struct lima_resource *res = lima_resource(surf->base.texture);
-   if (res->damage.region) {
-      /* for EGL_KHR_partial_update, when EGL_EXT_buffer_age is enabled,
-       * we need to reload damage region, otherwise just want to reload
-       * the region not aligned to tile boundary */
-      //if (!res->damage.aligned)
-      //   return true;
-      return true;
-   }
-   else if (surf->reload)
-         return true;
-
-   return false;
-}
-
-static void
-lima_pack_reload_plbu_cmd(struct lima_context *ctx)
-{
-   #define lima_reload_render_state_offset 0x0000
-   #define lima_reload_gl_pos_offset       0x0040
-   #define lima_reload_varying_offset      0x0080
-   #define lima_reload_tex_desc_offset     0x00c0
-   #define lima_reload_tex_array_offset    0x0100
-   #define lima_reload_buffer_size         0x0140
-
-   void *cpu;
-   unsigned offset;
-   struct pipe_resource *pres = NULL;
-   u_upload_alloc(ctx->uploader, 0, lima_reload_buffer_size,
-                  0x40, &offset, &pres, &cpu);
-
-   struct lima_resource *res = lima_resource(pres);
-   uint32_t va = res->bo->va + offset;
-
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-
-   uint32_t reload_shader_first_instr_size =
-      ((uint32_t *)(screen->pp_buffer->map + pp_reload_program_offset))[0] & 0x1f;
-   uint32_t reload_shader_va = screen->pp_buffer->va + pp_reload_program_offset;
-
-   struct lima_render_state reload_render_state = {
-      .alpha_blend = 0xf03b1ad2,
-      .depth_test = 0x0000000e,
-      .depth_range = 0xffff0000,
-      .stencil_front = 0x00000007,
-      .stencil_back = 0x00000007,
-      .multi_sample = 0x0000f007,
-      .shader_address = reload_shader_va | reload_shader_first_instr_size,
-      .varying_types = 0x00000001,
-      .textures_address = va + lima_reload_tex_array_offset,
-      .aux0 = 0x00004021,
-      .varyings_address = va + lima_reload_varying_offset,
-   };
-   memcpy(cpu + lima_reload_render_state_offset, &reload_render_state,
-          sizeof(reload_render_state));
-
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   lima_tex_desc *td = cpu + lima_reload_tex_desc_offset;
-   memset(td, 0, lima_min_tex_desc_size);
-   lima_texture_desc_set_res(ctx, td, fb->base.cbufs[0]->texture, 0, 0);
-   td->unnorm_coords = 1;
-   td->texture_type = LIMA_TEXTURE_TYPE_2D;
-   td->min_img_filter_nearest = 1;
-   td->mag_img_filter_nearest = 1;
-   td->wrap_s_clamp_to_edge = 1;
-   td->wrap_t_clamp_to_edge = 1;
-   td->unknown_2_2 = 0x1;
-
-   uint32_t *ta = cpu + lima_reload_tex_array_offset;
-   ta[0] = va + lima_reload_tex_desc_offset;
-
-   float reload_gl_pos[] = {
-      fb->base.width, 0,               0, 1,
-      0,              0,               0, 1,
-      0,              fb->base.height, 0, 1,
-   };
-   memcpy(cpu + lima_reload_gl_pos_offset, reload_gl_pos,
-          sizeof(reload_gl_pos));
-
-   float reload_varying[] = {
-      fb->base.width, 0,               0, 0,
-      0,              fb->base.height, 0, 0,
-   };
-   memcpy(cpu + lima_reload_varying_offset, reload_varying,
-          sizeof(reload_varying));
-
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, res->bo, LIMA_SUBMIT_BO_READ);
-   pipe_resource_reference(&pres, NULL);
-
-   PLBU_CMD_BEGIN(&ctx->plbu_cmd_head, 20);
-
-   PLBU_CMD_VIEWPORT_LEFT(0);
-   PLBU_CMD_VIEWPORT_RIGHT(fui(fb->base.width));
-   PLBU_CMD_VIEWPORT_BOTTOM(0);
-   PLBU_CMD_VIEWPORT_TOP(fui(fb->base.height));
-
-   PLBU_CMD_RSW_VERTEX_ARRAY(
-      va + lima_reload_render_state_offset,
-      va + lima_reload_gl_pos_offset);
-
-   PLBU_CMD_UNKNOWN2();
-   PLBU_CMD_UNKNOWN1();
-
-   PLBU_CMD_INDICES(screen->pp_buffer->va + pp_shared_index_offset);
-   PLBU_CMD_INDEXED_DEST(va + lima_reload_gl_pos_offset);
-   PLBU_CMD_DRAW_ELEMENTS(0xf, 0, 3);
-
-   PLBU_CMD_END();
-}
-
-static void
-lima_pack_head_plbu_cmd(struct lima_context *ctx)
-{
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-
-   PLBU_CMD_BEGIN(&ctx->plbu_cmd_head, 10);
-
-   PLBU_CMD_UNKNOWN2();
-   PLBU_CMD_BLOCK_STEP(fb->shift_min, fb->shift_h, fb->shift_w);
-   PLBU_CMD_TILED_DIMENSIONS(fb->tiled_w, fb->tiled_h);
-   PLBU_CMD_BLOCK_STRIDE(fb->block_w);
-
-   PLBU_CMD_ARRAY_ADDRESS(
-      ctx->plb_gp_stream->va + ctx->plb_index * ctx->plb_gp_size,
-      fb->block_w * fb->block_h);
-
-   PLBU_CMD_END();
-
-   if (lima_fb_need_reload(ctx))
-      lima_pack_reload_plbu_cmd(ctx);
-}
-
 static bool
 lima_is_scissor_zero(struct lima_context *ctx)
 {
@@ -220,260 +58,6 @@ lima_is_scissor_zero(struct lima_context *ctx)
       && scissor->miny == scissor->maxy;
 }
 
-static void
-hilbert_rotate(int n, int *x, int *y, int rx, int ry)
-{
-   if (ry == 0) {
-      if (rx == 1) {
-         *x = n-1 - *x;
-         *y = n-1 - *y;
-      }
-
-      /* Swap x and y */
-      int t  = *x;
-      *x = *y;
-      *y = t;
-   }
-}
-
-static void
-hilbert_coords(int n, int d, int *x, int *y)
-{
-   int rx, ry, i, t=d;
-
-   *x = *y = 0;
-
-   for (i = 0; (1 << i) < n; i++) {
-
-      rx = 1 & (t / 2);
-      ry = 1 & (t ^ rx);
-
-      hilbert_rotate(1 << i, x, y, rx, ry);
-
-      *x += rx << i;
-      *y += ry << i;
-
-      t /= 4;
-   }
-}
-
-static int
-lima_get_pp_stream_size(int num_pp, int tiled_w, int tiled_h, uint32_t *off)
-{
-   /* carefully calculate each stream start address:
-    * 1. overflow: each stream size may be different due to
-    *    fb->tiled_w * fb->tiled_h can't be divided by num_pp,
-    *    extra size should be added to the preceeding stream
-    * 2. alignment: each stream address should be 0x20 aligned
-    */
-   int delta = tiled_w * tiled_h / num_pp * 16 + 16;
-   int remain = tiled_w * tiled_h % num_pp;
-   int offset = 0;
-
-   for (int i = 0; i < num_pp; i++) {
-      off[i] = offset;
-
-      offset += delta;
-      if (remain) {
-         offset += 16;
-         remain--;
-      }
-      offset = align(offset, 0x20);
-   }
-
-   return offset;
-}
-
-static bool
-inside_damage_region(int x, int y, struct lima_damage_region *ds)
-{
-   if (!ds || !ds->region)
-      return true;
-
-   for (int i = 0; i < ds->num_region; i++) {
-      struct pipe_scissor_state *ss = ds->region + i;
-      if (x >= ss->minx && x < ss->maxx &&
-          y >= ss->miny && y < ss->maxy)
-         return true;
-   }
-
-   return false;
-}
-
-static void
-lima_generate_pp_stream(struct lima_context *ctx, int off_x, int off_y,
-                      int tiled_w, int tiled_h)
-{
-   struct lima_pp_stream_state *ps = &ctx->pp_stream;
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct lima_damage_region *damage = lima_ctx_get_damage(ctx);
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-   int i, num_pp = screen->num_pp;
-
-   /* use hilbert_coords to generates 1D to 2D relationship.
-    * 1D for pp stream index and 2D for plb block x/y on framebuffer.
-    * if multi pp, interleave the 1D index to make each pp's render target
-    * close enough which should result close workload
-    */
-   int max = MAX2(tiled_w, tiled_h);
-   int index = 0;
-   uint32_t *stream[4];
-   int si[4] = {0};
-   int dim = 0;
-   int count = 0;
-
-   /* Don't update count if we get zero rect. We'll just generate
-    * PP stream with just terminators in it.
-    */
-   if ((tiled_w * tiled_h) != 0) {
-      dim = util_logbase2_ceil(max);
-      count = 1 << (dim + dim);
-   }
-
-   for (i = 0; i < num_pp; i++)
-      stream[i] = ps->bo->map + ps->bo_offset + ps->offset[i];
-
-   for (i = 0; i < count; i++) {
-      int x, y;
-      hilbert_coords(max, i, &x, &y);
-      if (x < tiled_w && y < tiled_h) {
-         x += off_x;
-         y += off_y;
-
-         if (!inside_damage_region(x, y, damage))
-            continue;
-
-         int pp = index % num_pp;
-         int offset = ((y >> fb->shift_h) * fb->block_w +
-                       (x >> fb->shift_w)) * LIMA_CTX_PLB_BLK_SIZE;
-         int plb_va = ctx->plb[ctx->plb_index]->va + offset;
-
-         stream[pp][si[pp]++] = 0;
-         stream[pp][si[pp]++] = 0xB8000000 | x | (y << 8);
-         stream[pp][si[pp]++] = 0xE0000002 | ((plb_va >> 3) & ~0xE0000003);
-         stream[pp][si[pp]++] = 0xB0000000;
-
-         index++;
-      }
-   }
-
-   for (i = 0; i < num_pp; i++) {
-      stream[i][si[i]++] = 0;
-      stream[i][si[i]++] = 0xBC000000;
-      stream[i][si[i]++] = 0;
-      stream[i][si[i]++] = 0;
-
-      lima_dump_command_stream_print(
-         stream[i], si[i] * 4, false, "pp plb stream %d at va %x\n",
-         i, ps->bo->va + ps->bo_offset + ps->offset[i]);
-   }
-}
-
-static void
-lima_update_damage_pp_stream(struct lima_context *ctx)
-{
-   struct lima_damage_region *ds = lima_ctx_get_damage(ctx);
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct pipe_scissor_state bound;
-
-   if (ds && ds->region) {
-      struct pipe_scissor_state *dbound = &ds->bound;
-      bound.minx = MAX2(dbound->minx, ctx->damage_rect.minx >> 4);
-      bound.miny = MAX2(dbound->miny, ctx->damage_rect.miny >> 4);
-      bound.maxx = MIN2(dbound->maxx, (ctx->damage_rect.maxx + 0xf) >> 4);
-      bound.maxy = MIN2(dbound->maxy, (ctx->damage_rect.maxy + 0xf) >> 4);
-   } else {
-      bound.minx = ctx->damage_rect.minx >> 4;
-      bound.miny = ctx->damage_rect.miny >> 4;
-      bound.maxx = (ctx->damage_rect.maxx + 0xf) >> 4;
-      bound.maxy = (ctx->damage_rect.maxy + 0xf) >> 4;
-   }
-
-   /* Clamp to FB size */
-   bound.minx = MIN2(bound.minx, fb->tiled_w);
-   bound.miny = MIN2(bound.miny, fb->tiled_h);
-   bound.maxx = MIN2(bound.maxx, fb->tiled_w);
-   bound.maxy = MIN2(bound.maxy, fb->tiled_h);
-
-   int tiled_w = bound.maxx - bound.minx;
-   int tiled_h = bound.maxy - bound.miny;
-
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-   int size = lima_get_pp_stream_size(
-      screen->num_pp, tiled_w, tiled_h, ctx->pp_stream.offset);
-
-   void *cpu;
-   unsigned offset;
-   struct pipe_resource *pres = NULL;
-   u_upload_alloc(ctx->uploader, 0, size, 0x40, &offset, &pres, &cpu);
-
-   struct lima_resource *res = lima_resource(pres);
-   ctx->pp_stream.bo = res->bo;
-   ctx->pp_stream.bo_offset = offset;
-
-   lima_generate_pp_stream(ctx, bound.minx, bound.miny, tiled_w, tiled_h);
-
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, res->bo, LIMA_SUBMIT_BO_READ);
-   pipe_resource_reference(&pres, NULL);
-}
-
-static void
-lima_update_full_pp_stream(struct lima_context *ctx)
-{
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct lima_ctx_plb_pp_stream_key key = {
-      .plb_index = ctx->plb_index,
-      .tiled_w = fb->tiled_w,
-      .tiled_h = fb->tiled_h,
-   };
-
-   struct hash_entry *entry =
-      _mesa_hash_table_search(ctx->plb_pp_stream, &key);
-   struct lima_ctx_plb_pp_stream *s = entry->data;
-
-   if (s->bo) {
-      ctx->pp_stream.bo = s->bo;
-      ctx->pp_stream.bo_offset = 0;
-      memcpy(ctx->pp_stream.offset, s->offset, sizeof(s->offset));
-   }
-   else {
-      struct lima_screen *screen = lima_screen(ctx->base.screen);
-      int size = lima_get_pp_stream_size(
-         screen->num_pp, fb->tiled_w, fb->tiled_h, s->offset);
-      s->bo = lima_bo_create(screen, size, 0);
-      lima_bo_map(s->bo);
-
-      ctx->pp_stream.bo = s->bo;
-      ctx->pp_stream.bo_offset = 0;
-      memcpy(ctx->pp_stream.offset, s->offset, sizeof(s->offset));
-
-      lima_generate_pp_stream(ctx, 0, 0, fb->tiled_w, fb->tiled_h);
-   }
-
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, s->bo, LIMA_SUBMIT_BO_READ);
-}
-
-static bool
-lima_damage_fullscreen(struct lima_context *ctx)
-{
-   return ctx->damage_rect.minx == 0 &&
-          ctx->damage_rect.miny == 0 &&
-          ctx->damage_rect.maxx == ctx->framebuffer.base.width &&
-          ctx->damage_rect.maxy == ctx->framebuffer.base.height;
-}
-
-static void
-lima_update_pp_stream(struct lima_context *ctx)
-{
-   struct lima_damage_region *damage = lima_ctx_get_damage(ctx);
-   if ((damage && damage->region) || !lima_damage_fullscreen(ctx))
-      lima_update_damage_pp_stream(ctx);
-   else if (ctx->plb_pp_stream)
-      lima_update_full_pp_stream(ctx);
-   else
-      ctx->pp_stream.bo = NULL;
-}
-
 static void
 lima_update_submit_wb(struct lima_context *ctx, unsigned buffers)
 {
@@ -496,30 +80,6 @@ lima_update_submit_wb(struct lima_context *ctx, unsigned buffers)
    ctx->resolve |= buffers;
 }
 
-static void
-lima_update_submit_bo(struct lima_context *ctx)
-{
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->plb_gp_stream,
-                      LIMA_SUBMIT_BO_READ);
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->plb[ctx->plb_index],
-                      LIMA_SUBMIT_BO_WRITE);
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->gp_tile_heap[ctx->plb_index],
-                      LIMA_SUBMIT_BO_WRITE);
-
-   lima_dump_command_stream_print(
-      ctx->plb_gp_stream->map + ctx->plb_index * ctx->plb_gp_size,
-      ctx->plb_gp_size, false, "gp plb stream at va %x\n",
-      ctx->plb_gp_stream->va + ctx->plb_index * ctx->plb_gp_size);
-
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, ctx->plb[ctx->plb_index],
-                      LIMA_SUBMIT_BO_READ);
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, ctx->gp_tile_heap[ctx->plb_index],
-                      LIMA_SUBMIT_BO_READ);
-
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, screen->pp_buffer, LIMA_SUBMIT_BO_READ);
-}
-
 static void
 lima_damage_rect_union(struct lima_context *ctx, unsigned minx, unsigned maxx, unsigned miny, unsigned maxy)
 {
@@ -1492,304 +1052,9 @@ lima_draw_vbo(struct pipe_context *pctx,
       lima_draw_vbo_count(pctx, info);
 }
 
-static void
-lima_finish_plbu_cmd(struct lima_context *ctx)
-{
-   int i = 0;
-   uint32_t *plbu_cmd = util_dynarray_ensure_cap(&ctx->plbu_cmd_array, ctx->plbu_cmd_array.size + 2 * 4);
-
-   plbu_cmd[i++] = 0x00000000;
-   plbu_cmd[i++] = 0x50000000; /* END */
-
-   ctx->plbu_cmd_array.size += i * 4;
-}
-
-static void
-lima_pack_wb_zsbuf_reg(struct lima_context *ctx, uint32_t *wb_reg, int wb_idx)
-{
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct lima_resource *res = lima_resource(fb->base.zsbuf->texture);
-   int level = fb->base.zsbuf->u.tex.level;
-   uint32_t format = lima_format_get_pixel(fb->base.zsbuf->format);
-
-   struct lima_pp_wb_reg *wb = (void *)wb_reg;
-   wb[wb_idx].type = 0x01; /* 1 for depth, stencil */
-   wb[wb_idx].address = res->bo->va + res->levels[level].offset;
-   wb[wb_idx].pixel_format = format;
-   if (res->tiled) {
-      wb[wb_idx].pixel_layout = 0x2;
-      wb[wb_idx].pitch = fb->tiled_w;
-   } else {
-      wb[wb_idx].pixel_layout = 0x0;
-      wb[wb_idx].pitch = res->levels[level].stride / 8;
-   }
-   wb[wb_idx].mrt_bits = 0;
-}
-
-static void
-lima_pack_wb_cbuf_reg(struct lima_context *ctx, uint32_t *wb_reg, int wb_idx)
-{
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct lima_resource *res = lima_resource(fb->base.cbufs[0]->texture);
-   int level = fb->base.cbufs[0]->u.tex.level;
-   unsigned layer = fb->base.cbufs[0]->u.tex.first_layer;
-   uint32_t format = lima_format_get_pixel(fb->base.cbufs[0]->format);
-   bool swap_channels = lima_format_get_swap_rb(fb->base.cbufs[0]->format);
-
-   struct lima_pp_wb_reg *wb = (void *)wb_reg;
-   wb[wb_idx].type = 0x02; /* 2 for color buffer */
-   wb[wb_idx].address = res->bo->va + res->levels[level].offset + layer * res->levels[level].layer_stride;
-   wb[wb_idx].pixel_format = format;
-   if (res->tiled) {
-      wb[wb_idx].pixel_layout = 0x2;
-      wb[wb_idx].pitch = fb->tiled_w;
-   } else {
-      wb[wb_idx].pixel_layout = 0x0;
-      wb[wb_idx].pitch = res->levels[level].stride / 8;
-   }
-   wb[wb_idx].mrt_bits = swap_channels ? 0x4 : 0x0;
-}
-
-
-static void
-lima_pack_pp_frame_reg(struct lima_context *ctx, uint32_t *frame_reg,
-                       uint32_t *wb_reg)
-{
-   struct lima_context_framebuffer *fb = &ctx->framebuffer;
-   struct lima_pp_frame_reg *frame = (void *)frame_reg;
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-   int wb_idx = 0;
-
-   frame->render_address = screen->pp_buffer->va + pp_frame_rsw_offset;
-   frame->flags = 0x02;
-   frame->clear_value_depth = ctx->clear.depth;
-   frame->clear_value_stencil = ctx->clear.stencil;
-   frame->clear_value_color = ctx->clear.color_8pc;
-   frame->clear_value_color_1 = ctx->clear.color_8pc;
-   frame->clear_value_color_2 = ctx->clear.color_8pc;
-   frame->clear_value_color_3 = ctx->clear.color_8pc;
-   frame->one = 1;
-
-   frame->width = fb->base.width - 1;
-   frame->height = fb->base.height - 1;
-
-   /* frame->fragment_stack_address is overwritten per-pp in the kernel
-    * by the values of pp_frame.fragment_stack_address[i] */
-
-   /* These are "stack size" and "stack offset" shifted,
-    * here they are assumed to be always the same. */
-   frame->fragment_stack_size = ctx->pp_max_stack_size << 16 | ctx->pp_max_stack_size;
-
-   /* related with MSAA and different value when r4p0/r7p0 */
-   frame->supersampled_height = fb->base.height * 2 - 1;
-   frame->scale = 0xE0C;
-
-   frame->dubya = 0x77;
-   frame->onscreen = 1;
-   frame->blocking = (fb->shift_min << 28) | (fb->shift_h << 16) | fb->shift_w;
-   frame->foureight = 0x8888;
-
-   if (fb->base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0))
-      lima_pack_wb_cbuf_reg(ctx, wb_reg, wb_idx++);
-
-   if (fb->base.zsbuf &&
-       (ctx->resolve & (PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL)))
-      lima_pack_wb_zsbuf_reg(ctx, wb_reg, wb_idx++);
-}
-
-static void
-_lima_flush(struct lima_context *ctx, bool end_of_frame)
-{
-   #define pp_stack_pp_size 0x400
-
-   lima_pack_head_plbu_cmd(ctx);
-   lima_finish_plbu_cmd(ctx);
-
-   lima_update_submit_bo(ctx);
-
-   int vs_cmd_size = ctx->vs_cmd_array.size;
-   uint32_t vs_cmd_va = 0;
-
-   if (vs_cmd_size) {
-      void *vs_cmd =
-         lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_vs_cmd, vs_cmd_size);
-      memcpy(vs_cmd, util_dynarray_begin(&ctx->vs_cmd_array), vs_cmd_size);
-      util_dynarray_clear(&ctx->vs_cmd_array);
-      vs_cmd_va = lima_ctx_buff_va(ctx, lima_ctx_buff_gp_vs_cmd);
-
-      lima_dump_command_stream_print(
-         vs_cmd, vs_cmd_size, false, "flush vs cmd at va %x\n", vs_cmd_va);
-      lima_dump_vs_command_stream_print(vs_cmd, vs_cmd_size, vs_cmd_va);
-   }
-
-   int plbu_cmd_size = ctx->plbu_cmd_array.size + ctx->plbu_cmd_head.size;
-   void *plbu_cmd =
-      lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_plbu_cmd, plbu_cmd_size);
-   memcpy(plbu_cmd,
-          util_dynarray_begin(&ctx->plbu_cmd_head),
-          ctx->plbu_cmd_head.size);
-   memcpy(plbu_cmd + ctx->plbu_cmd_head.size,
-          util_dynarray_begin(&ctx->plbu_cmd_array),
-          ctx->plbu_cmd_array.size);
-   util_dynarray_clear(&ctx->plbu_cmd_array);
-   util_dynarray_clear(&ctx->plbu_cmd_head);
-   uint32_t plbu_cmd_va = lima_ctx_buff_va(ctx, lima_ctx_buff_gp_plbu_cmd);
-
-   lima_dump_command_stream_print(
-      plbu_cmd, plbu_cmd_size, false, "flush plbu cmd at va %x\n", plbu_cmd_va);
-   lima_dump_plbu_command_stream_print(plbu_cmd, plbu_cmd_size, plbu_cmd_va);
-
-   struct lima_screen *screen = lima_screen(ctx->base.screen);
-   struct drm_lima_gp_frame gp_frame;
-   struct lima_gp_frame_reg *gp_frame_reg = (void *)gp_frame.frame;
-   gp_frame_reg->vs_cmd_start = vs_cmd_va;
-   gp_frame_reg->vs_cmd_end = vs_cmd_va + vs_cmd_size;
-   gp_frame_reg->plbu_cmd_start = plbu_cmd_va;
-   gp_frame_reg->plbu_cmd_end = plbu_cmd_va + plbu_cmd_size;
-   gp_frame_reg->tile_heap_start = ctx->gp_tile_heap[ctx->plb_index]->va;
-   gp_frame_reg->tile_heap_end = ctx->gp_tile_heap[ctx->plb_index]->va + ctx->gp_tile_heap_size;
-
-   lima_dump_command_stream_print(
-      &gp_frame, sizeof(gp_frame), false, "add gp frame\n");
-
-   if (!lima_submit_start(ctx->submit, LIMA_PIPE_GP, &gp_frame, sizeof(gp_frame)))
-      fprintf(stderr, "gp submit error\n");
-
-   if (lima_dump_command_stream) {
-      if (lima_submit_wait(ctx->submit, LIMA_PIPE_GP, PIPE_TIMEOUT_INFINITE)) {
-         if (ctx->gp_output) {
-            float *pos = lima_bo_map(ctx->gp_output);
-            lima_dump_command_stream_print(
-               pos, 4 * 4 * 16, true, "gl_pos dump at va %x\n",
-               ctx->gp_output->va);
-         }
-
-         uint32_t *plb = lima_bo_map(ctx->plb[ctx->plb_index]);
-         lima_dump_command_stream_print(
-            plb, LIMA_CTX_PLB_BLK_SIZE, false, "plb dump at va %x\n",
-            ctx->plb[ctx->plb_index]->va);
-      }
-      else {
-         fprintf(stderr, "gp submit wait error\n");
-         exit(1);
-      }
-   }
-
-   uint32_t pp_stack_va = 0;
-   if (ctx->pp_max_stack_size) {
-      lima_ctx_buff_alloc(ctx, lima_ctx_buff_pp_stack, screen->num_pp *
-                          ctx->pp_max_stack_size * pp_stack_pp_size);
-      pp_stack_va = lima_ctx_buff_va(ctx, lima_ctx_buff_pp_stack);
-   }
-
-   lima_update_pp_stream(ctx);
-
-   struct lima_pp_stream_state *ps = &ctx->pp_stream;
-   if (screen->gpu_type == DRM_LIMA_PARAM_GPU_ID_MALI400) {
-      struct drm_lima_m400_pp_frame pp_frame = {0};
-      lima_pack_pp_frame_reg(ctx, pp_frame.frame, pp_frame.wb);
-      pp_frame.num_pp = screen->num_pp;
-
-      for (int i = 0; i < screen->num_pp; i++) {
-         pp_frame.plbu_array_address[i] = ps->bo->va + ps->bo_offset + ps->offset[i];
-         if (ctx->pp_max_stack_size)
-            pp_frame.fragment_stack_address[i] = pp_stack_va +
-               ctx->pp_max_stack_size * pp_stack_pp_size * i;
-      }
-
-      lima_dump_command_stream_print(
-         &pp_frame, sizeof(pp_frame), false, "add pp frame\n");
-
-      if (!lima_submit_start(ctx->submit, LIMA_PIPE_PP, &pp_frame, sizeof(pp_frame)))
-         fprintf(stderr, "pp submit error\n");
-   }
-   else {
-      struct drm_lima_m450_pp_frame pp_frame = {0};
-      lima_pack_pp_frame_reg(ctx, pp_frame.frame, pp_frame.wb);
-      pp_frame.num_pp = screen->num_pp;
-
-      if (ctx->pp_max_stack_size)
-         for (int i = 0; i < screen->num_pp; i++)
-            pp_frame.fragment_stack_address[i] = pp_stack_va +
-               ctx->pp_max_stack_size * pp_stack_pp_size * i;
-
-      if (ps->bo) {
-         for (int i = 0; i < screen->num_pp; i++)
-            pp_frame.plbu_array_address[i] = ps->bo->va + ps->bo_offset + ps->offset[i];
-      }
-      else {
-         pp_frame.use_dlbu = true;
-
-         struct lima_context_framebuffer *fb = &ctx->framebuffer;
-         pp_frame.dlbu_regs[0] = ctx->plb[ctx->plb_index]->va;
-         pp_frame.dlbu_regs[1] = ((fb->tiled_h - 1) << 16) | (fb->tiled_w - 1);
-         unsigned s = util_logbase2(LIMA_CTX_PLB_BLK_SIZE) - 7;
-         pp_frame.dlbu_regs[2] = (s << 28) | (fb->shift_h << 16) | fb->shift_w;
-         pp_frame.dlbu_regs[3] = ((fb->tiled_h - 1) << 24) | ((fb->tiled_w - 1) << 16);
-      }
-
-      lima_dump_command_stream_print(
-         &pp_frame, sizeof(pp_frame), false, "add pp frame\n");
-
-      if (!lima_submit_start(ctx->submit, LIMA_PIPE_PP, &pp_frame, sizeof(pp_frame)))
-         fprintf(stderr, "pp submit error\n");
-   }
-
-   if (lima_dump_command_stream) {
-      if (!lima_submit_wait(ctx->submit, LIMA_PIPE_PP, PIPE_TIMEOUT_INFINITE)) {
-         fprintf(stderr, "pp wait error\n");
-         exit(1);
-      }
-   }
-
-   ctx->plb_index = (ctx->plb_index + 1) % lima_ctx_num_plb;
-
-   if (ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)) {
-      /* Set reload flag for next draw. It'll be unset if buffer is cleared */
-      struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
-      surf->reload = true;
-   }
-
-   ctx->pp_max_stack_size = 0;
-
-   ctx->damage_rect.minx = ctx->damage_rect.miny = 0xffff;
-   ctx->damage_rect.maxx = ctx->damage_rect.maxy = 0;
-
-   ctx->resolve = 0;
-
-   lima_dump_file_next();
-}
-
-void
-lima_flush(struct lima_context *ctx)
-{
-   if (!lima_ctx_dirty(ctx))
-      return;
-
-   _lima_flush(ctx, false);
-}
-
-static void
-lima_pipe_flush(struct pipe_context *pctx, struct pipe_fence_handle **fence,
-                unsigned flags)
-{
-   struct lima_context *ctx = lima_context(pctx);
-   if (lima_ctx_dirty(ctx))
-      _lima_flush(ctx, flags & PIPE_FLUSH_END_OF_FRAME);
-
-   if (fence) {
-      int drm_fd = lima_screen(ctx->base.screen)->fd;
-      int fd;
-
-      if (!drmSyncobjExportSyncFile(drm_fd, ctx->out_sync[LIMA_PIPE_PP], &fd))
-         *fence = lima_fence_create(fd);
-   }
-}
-
 void
 lima_draw_init(struct lima_context *ctx)
 {
    ctx->base.clear = lima_clear;
    ctx->base.draw_vbo = lima_draw_vbo;
-   ctx->base.flush = lima_pipe_flush;
 }
diff --git a/src/gallium/drivers/lima/lima_submit.c b/src/gallium/drivers/lima/lima_submit.c
index 113f9dbce7e..e1f2807e1d2 100644
--- a/src/gallium/drivers/lima/lima_submit.c
+++ b/src/gallium/drivers/lima/lima_submit.c
@@ -27,15 +27,24 @@
 #include "xf86drm.h"
 #include "drm-uapi/lima_drm.h"
 
+#include "util/u_math.h"
 #include "util/ralloc.h"
 #include "util/u_dynarray.h"
 #include "util/os_time.h"
+#include "util/hash_table.h"
+#include "util/u_upload_mgr.h"
+#include "util/u_inlines.h"
 
 #include "lima_screen.h"
 #include "lima_context.h"
 #include "lima_submit.h"
 #include "lima_bo.h"
 #include "lima_util.h"
+#include "lima_format.h"
+#include "lima_resource.h"
+#include "lima_texture.h"
+#include "lima_fence.h"
+#include "lima_gpu.h"
 
 struct lima_submit {
    int fd;
@@ -98,7 +107,8 @@ bool lima_submit_add_bo(struct lima_submit *submit, int pipe,
    return true;
 }
 
-bool lima_submit_start(struct lima_submit *submit, int pipe, void *frame, uint32_t size)
+static bool
+lima_submit_start(struct lima_submit *submit, int pipe, void *frame, uint32_t size)
 {
    struct lima_context *ctx = submit->ctx;
    struct drm_lima_gem_submit req = {
@@ -133,7 +143,8 @@ bool lima_submit_start(struct lima_submit *submit, int pipe, void *frame, uint32
    return ret;
 }
 
-bool lima_submit_wait(struct lima_submit *submit, int pipe, uint64_t timeout_ns)
+static bool
+lima_submit_wait(struct lima_submit *submit, int pipe, uint64_t timeout_ns)
 {
    int64_t abs_timeout = os_time_get_absolute_timeout(timeout_ns);
    if (abs_timeout == OS_TIMEOUT_INFINITE)
@@ -159,6 +170,734 @@ bool lima_submit_has_bo(struct lima_submit *submit, struct lima_bo *bo, bool all
    return false;
 }
 
+static inline bool
+lima_ctx_dirty(struct lima_context *ctx)
+{
+   return !!ctx->resolve;
+}
+
+static inline struct lima_damage_region *
+lima_ctx_get_damage(struct lima_context *ctx)
+{
+   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
+      return NULL;
+
+   struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
+   struct lima_resource *res = lima_resource(surf->base.texture);
+   return &res->damage;
+}
+
+static bool
+lima_fb_need_reload(struct lima_context *ctx)
+{
+   /* Depth buffer is always discarded */
+   if (!(ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)))
+      return false;
+
+   struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
+   struct lima_resource *res = lima_resource(surf->base.texture);
+   if (res->damage.region) {
+      /* for EGL_KHR_partial_update, when EGL_EXT_buffer_age is enabled,
+       * we need to reload damage region, otherwise just want to reload
+       * the region not aligned to tile boundary */
+      //if (!res->damage.aligned)
+      //   return true;
+      return true;
+   }
+   else if (surf->reload)
+         return true;
+
+   return false;
+}
+
+static void
+lima_pack_reload_plbu_cmd(struct lima_context *ctx)
+{
+   #define lima_reload_render_state_offset 0x0000
+   #define lima_reload_gl_pos_offset       0x0040
+   #define lima_reload_varying_offset      0x0080
+   #define lima_reload_tex_desc_offset     0x00c0
+   #define lima_reload_tex_array_offset    0x0100
+   #define lima_reload_buffer_size         0x0140
+
+   void *cpu;
+   unsigned offset;
+   struct pipe_resource *pres = NULL;
+   u_upload_alloc(ctx->uploader, 0, lima_reload_buffer_size,
+                  0x40, &offset, &pres, &cpu);
+
+   struct lima_resource *res = lima_resource(pres);
+   uint32_t va = res->bo->va + offset;
+
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+
+   uint32_t reload_shader_first_instr_size =
+      ((uint32_t *)(screen->pp_buffer->map + pp_reload_program_offset))[0] & 0x1f;
+   uint32_t reload_shader_va = screen->pp_buffer->va + pp_reload_program_offset;
+
+   struct lima_render_state reload_render_state = {
+      .alpha_blend = 0xf03b1ad2,
+      .depth_test = 0x0000000e,
+      .depth_range = 0xffff0000,
+      .stencil_front = 0x00000007,
+      .stencil_back = 0x00000007,
+      .multi_sample = 0x0000f007,
+      .shader_address = reload_shader_va | reload_shader_first_instr_size,
+      .varying_types = 0x00000001,
+      .textures_address = va + lima_reload_tex_array_offset,
+      .aux0 = 0x00004021,
+      .varyings_address = va + lima_reload_varying_offset,
+   };
+   memcpy(cpu + lima_reload_render_state_offset, &reload_render_state,
+          sizeof(reload_render_state));
+
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   lima_tex_desc *td = cpu + lima_reload_tex_desc_offset;
+   memset(td, 0, lima_min_tex_desc_size);
+   lima_texture_desc_set_res(ctx, td, fb->base.cbufs[0]->texture, 0, 0);
+   td->unnorm_coords = 1;
+   td->texture_type = LIMA_TEXTURE_TYPE_2D;
+   td->min_img_filter_nearest = 1;
+   td->mag_img_filter_nearest = 1;
+   td->wrap_s_clamp_to_edge = 1;
+   td->wrap_t_clamp_to_edge = 1;
+   td->unknown_2_2 = 0x1;
+
+   uint32_t *ta = cpu + lima_reload_tex_array_offset;
+   ta[0] = va + lima_reload_tex_desc_offset;
+
+   float reload_gl_pos[] = {
+      fb->base.width, 0,               0, 1,
+      0,              0,               0, 1,
+      0,              fb->base.height, 0, 1,
+   };
+   memcpy(cpu + lima_reload_gl_pos_offset, reload_gl_pos,
+          sizeof(reload_gl_pos));
+
+   float reload_varying[] = {
+      fb->base.width, 0,               0, 0,
+      0,              fb->base.height, 0, 0,
+   };
+   memcpy(cpu + lima_reload_varying_offset, reload_varying,
+          sizeof(reload_varying));
+
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, res->bo, LIMA_SUBMIT_BO_READ);
+   pipe_resource_reference(&pres, NULL);
+
+   PLBU_CMD_BEGIN(&ctx->plbu_cmd_head, 20);
+
+   PLBU_CMD_VIEWPORT_LEFT(0);
+   PLBU_CMD_VIEWPORT_RIGHT(fui(fb->base.width));
+   PLBU_CMD_VIEWPORT_BOTTOM(0);
+   PLBU_CMD_VIEWPORT_TOP(fui(fb->base.height));
+
+   PLBU_CMD_RSW_VERTEX_ARRAY(
+      va + lima_reload_render_state_offset,
+      va + lima_reload_gl_pos_offset);
+
+   PLBU_CMD_UNKNOWN2();
+   PLBU_CMD_UNKNOWN1();
+
+   PLBU_CMD_INDICES(screen->pp_buffer->va + pp_shared_index_offset);
+   PLBU_CMD_INDEXED_DEST(va + lima_reload_gl_pos_offset);
+   PLBU_CMD_DRAW_ELEMENTS(0xf, 0, 3);
+
+   PLBU_CMD_END();
+}
+
+static void
+lima_pack_head_plbu_cmd(struct lima_context *ctx)
+{
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+
+   PLBU_CMD_BEGIN(&ctx->plbu_cmd_head, 10);
+
+   PLBU_CMD_UNKNOWN2();
+   PLBU_CMD_BLOCK_STEP(fb->shift_min, fb->shift_h, fb->shift_w);
+   PLBU_CMD_TILED_DIMENSIONS(fb->tiled_w, fb->tiled_h);
+   PLBU_CMD_BLOCK_STRIDE(fb->block_w);
+
+   PLBU_CMD_ARRAY_ADDRESS(
+      ctx->plb_gp_stream->va + ctx->plb_index * ctx->plb_gp_size,
+      fb->block_w * fb->block_h);
+
+   PLBU_CMD_END();
+
+   if (lima_fb_need_reload(ctx))
+      lima_pack_reload_plbu_cmd(ctx);
+}
+
+static void
+hilbert_rotate(int n, int *x, int *y, int rx, int ry)
+{
+   if (ry == 0) {
+      if (rx == 1) {
+         *x = n-1 - *x;
+         *y = n-1 - *y;
+      }
+
+      /* Swap x and y */
+      int t  = *x;
+      *x = *y;
+      *y = t;
+   }
+}
+
+static void
+hilbert_coords(int n, int d, int *x, int *y)
+{
+   int rx, ry, i, t=d;
+
+   *x = *y = 0;
+
+   for (i = 0; (1 << i) < n; i++) {
+
+      rx = 1 & (t / 2);
+      ry = 1 & (t ^ rx);
+
+      hilbert_rotate(1 << i, x, y, rx, ry);
+
+      *x += rx << i;
+      *y += ry << i;
+
+      t /= 4;
+   }
+}
+
+static int
+lima_get_pp_stream_size(int num_pp, int tiled_w, int tiled_h, uint32_t *off)
+{
+   /* carefully calculate each stream start address:
+    * 1. overflow: each stream size may be different due to
+    *    fb->tiled_w * fb->tiled_h can't be divided by num_pp,
+    *    extra size should be added to the preceeding stream
+    * 2. alignment: each stream address should be 0x20 aligned
+    */
+   int delta = tiled_w * tiled_h / num_pp * 16 + 16;
+   int remain = tiled_w * tiled_h % num_pp;
+   int offset = 0;
+
+   for (int i = 0; i < num_pp; i++) {
+      off[i] = offset;
+
+      offset += delta;
+      if (remain) {
+         offset += 16;
+         remain--;
+      }
+      offset = align(offset, 0x20);
+   }
+
+   return offset;
+}
+
+static bool
+inside_damage_region(int x, int y, struct lima_damage_region *ds)
+{
+   if (!ds || !ds->region)
+      return true;
+
+   for (int i = 0; i < ds->num_region; i++) {
+      struct pipe_scissor_state *ss = ds->region + i;
+      if (x >= ss->minx && x < ss->maxx &&
+          y >= ss->miny && y < ss->maxy)
+         return true;
+   }
+
+   return false;
+}
+
+static void
+lima_generate_pp_stream(struct lima_context *ctx, int off_x, int off_y,
+                      int tiled_w, int tiled_h)
+{
+   struct lima_pp_stream_state *ps = &ctx->pp_stream;
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_damage_region *damage = lima_ctx_get_damage(ctx);
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+   int i, num_pp = screen->num_pp;
+
+   /* use hilbert_coords to generates 1D to 2D relationship.
+    * 1D for pp stream index and 2D for plb block x/y on framebuffer.
+    * if multi pp, interleave the 1D index to make each pp's render target
+    * close enough which should result close workload
+    */
+   int max = MAX2(tiled_w, tiled_h);
+   int index = 0;
+   uint32_t *stream[4];
+   int si[4] = {0};
+   int dim = 0;
+   int count = 0;
+
+   /* Don't update count if we get zero rect. We'll just generate
+    * PP stream with just terminators in it.
+    */
+   if ((tiled_w * tiled_h) != 0) {
+      dim = util_logbase2_ceil(max);
+      count = 1 << (dim + dim);
+   }
+
+   for (i = 0; i < num_pp; i++)
+      stream[i] = ps->bo->map + ps->bo_offset + ps->offset[i];
+
+   for (i = 0; i < count; i++) {
+      int x, y;
+      hilbert_coords(max, i, &x, &y);
+      if (x < tiled_w && y < tiled_h) {
+         x += off_x;
+         y += off_y;
+
+         if (!inside_damage_region(x, y, damage))
+            continue;
+
+         int pp = index % num_pp;
+         int offset = ((y >> fb->shift_h) * fb->block_w +
+                       (x >> fb->shift_w)) * LIMA_CTX_PLB_BLK_SIZE;
+         int plb_va = ctx->plb[ctx->plb_index]->va + offset;
+
+         stream[pp][si[pp]++] = 0;
+         stream[pp][si[pp]++] = 0xB8000000 | x | (y << 8);
+         stream[pp][si[pp]++] = 0xE0000002 | ((plb_va >> 3) & ~0xE0000003);
+         stream[pp][si[pp]++] = 0xB0000000;
+
+         index++;
+      }
+   }
+
+   for (i = 0; i < num_pp; i++) {
+      stream[i][si[i]++] = 0;
+      stream[i][si[i]++] = 0xBC000000;
+      stream[i][si[i]++] = 0;
+      stream[i][si[i]++] = 0;
+
+      lima_dump_command_stream_print(
+         stream[i], si[i] * 4, false, "pp plb stream %d at va %x\n",
+         i, ps->bo->va + ps->bo_offset + ps->offset[i]);
+   }
+}
+
+static void
+lima_update_damage_pp_stream(struct lima_context *ctx)
+{
+   struct lima_damage_region *ds = lima_ctx_get_damage(ctx);
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct pipe_scissor_state bound;
+
+   if (ds && ds->region) {
+      struct pipe_scissor_state *dbound = &ds->bound;
+      bound.minx = MAX2(dbound->minx, ctx->damage_rect.minx >> 4);
+      bound.miny = MAX2(dbound->miny, ctx->damage_rect.miny >> 4);
+      bound.maxx = MIN2(dbound->maxx, (ctx->damage_rect.maxx + 0xf) >> 4);
+      bound.maxy = MIN2(dbound->maxy, (ctx->damage_rect.maxy + 0xf) >> 4);
+   } else {
+      bound.minx = ctx->damage_rect.minx >> 4;
+      bound.miny = ctx->damage_rect.miny >> 4;
+      bound.maxx = (ctx->damage_rect.maxx + 0xf) >> 4;
+      bound.maxy = (ctx->damage_rect.maxy + 0xf) >> 4;
+   }
+
+   /* Clamp to FB size */
+   bound.minx = MIN2(bound.minx, fb->tiled_w);
+   bound.miny = MIN2(bound.miny, fb->tiled_h);
+   bound.maxx = MIN2(bound.maxx, fb->tiled_w);
+   bound.maxy = MIN2(bound.maxy, fb->tiled_h);
+
+   int tiled_w = bound.maxx - bound.minx;
+   int tiled_h = bound.maxy - bound.miny;
+
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+   int size = lima_get_pp_stream_size(
+      screen->num_pp, tiled_w, tiled_h, ctx->pp_stream.offset);
+
+   void *cpu;
+   unsigned offset;
+   struct pipe_resource *pres = NULL;
+   u_upload_alloc(ctx->uploader, 0, size, 0x40, &offset, &pres, &cpu);
+
+   struct lima_resource *res = lima_resource(pres);
+   ctx->pp_stream.bo = res->bo;
+   ctx->pp_stream.bo_offset = offset;
+
+   lima_generate_pp_stream(ctx, bound.minx, bound.miny, tiled_w, tiled_h);
+
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, res->bo, LIMA_SUBMIT_BO_READ);
+   pipe_resource_reference(&pres, NULL);
+}
+
+static void
+lima_update_full_pp_stream(struct lima_context *ctx)
+{
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_ctx_plb_pp_stream_key key = {
+      .plb_index = ctx->plb_index,
+      .tiled_w = fb->tiled_w,
+      .tiled_h = fb->tiled_h,
+   };
+
+   struct hash_entry *entry =
+      _mesa_hash_table_search(ctx->plb_pp_stream, &key);
+   struct lima_ctx_plb_pp_stream *s = entry->data;
+
+   if (s->bo) {
+      ctx->pp_stream.bo = s->bo;
+      ctx->pp_stream.bo_offset = 0;
+      memcpy(ctx->pp_stream.offset, s->offset, sizeof(s->offset));
+   }
+   else {
+      struct lima_screen *screen = lima_screen(ctx->base.screen);
+      int size = lima_get_pp_stream_size(
+         screen->num_pp, fb->tiled_w, fb->tiled_h, s->offset);
+      s->bo = lima_bo_create(screen, size, 0);
+      lima_bo_map(s->bo);
+
+      ctx->pp_stream.bo = s->bo;
+      ctx->pp_stream.bo_offset = 0;
+      memcpy(ctx->pp_stream.offset, s->offset, sizeof(s->offset));
+
+      lima_generate_pp_stream(ctx, 0, 0, fb->tiled_w, fb->tiled_h);
+   }
+
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, s->bo, LIMA_SUBMIT_BO_READ);
+}
+
+static bool
+lima_damage_fullscreen(struct lima_context *ctx)
+{
+   return ctx->damage_rect.minx == 0 &&
+          ctx->damage_rect.miny == 0 &&
+          ctx->damage_rect.maxx == ctx->framebuffer.base.width &&
+          ctx->damage_rect.maxy == ctx->framebuffer.base.height;
+}
+
+static void
+lima_update_pp_stream(struct lima_context *ctx)
+{
+   struct lima_damage_region *damage = lima_ctx_get_damage(ctx);
+   if ((damage && damage->region) || !lima_damage_fullscreen(ctx))
+      lima_update_damage_pp_stream(ctx);
+   else if (ctx->plb_pp_stream)
+      lima_update_full_pp_stream(ctx);
+   else
+      ctx->pp_stream.bo = NULL;
+}
+
+static void
+lima_update_submit_bo(struct lima_context *ctx)
+{
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->plb_gp_stream,
+                      LIMA_SUBMIT_BO_READ);
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->plb[ctx->plb_index],
+                      LIMA_SUBMIT_BO_WRITE);
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_GP, ctx->gp_tile_heap[ctx->plb_index],
+                      LIMA_SUBMIT_BO_WRITE);
+
+   lima_dump_command_stream_print(
+      ctx->plb_gp_stream->map + ctx->plb_index * ctx->plb_gp_size,
+      ctx->plb_gp_size, false, "gp plb stream at va %x\n",
+      ctx->plb_gp_stream->va + ctx->plb_index * ctx->plb_gp_size);
+
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, ctx->plb[ctx->plb_index],
+                      LIMA_SUBMIT_BO_READ);
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, ctx->gp_tile_heap[ctx->plb_index],
+                      LIMA_SUBMIT_BO_READ);
+
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+   lima_submit_add_bo(ctx->submit, LIMA_PIPE_PP, screen->pp_buffer, LIMA_SUBMIT_BO_READ);
+}
+
+static void
+lima_finish_plbu_cmd(struct lima_context *ctx)
+{
+   int i = 0;
+   uint32_t *plbu_cmd = util_dynarray_ensure_cap(&ctx->plbu_cmd_array, ctx->plbu_cmd_array.size + 2 * 4);
+
+   plbu_cmd[i++] = 0x00000000;
+   plbu_cmd[i++] = 0x50000000; /* END */
+
+   ctx->plbu_cmd_array.size += i * 4;
+}
+
+static void
+lima_pack_wb_zsbuf_reg(struct lima_context *ctx, uint32_t *wb_reg, int wb_idx)
+{
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_resource *res = lima_resource(fb->base.zsbuf->texture);
+   int level = fb->base.zsbuf->u.tex.level;
+   uint32_t format = lima_format_get_pixel(fb->base.zsbuf->format);
+
+   struct lima_pp_wb_reg *wb = (void *)wb_reg;
+   wb[wb_idx].type = 0x01; /* 1 for depth, stencil */
+   wb[wb_idx].address = res->bo->va + res->levels[level].offset;
+   wb[wb_idx].pixel_format = format;
+   if (res->tiled) {
+      wb[wb_idx].pixel_layout = 0x2;
+      wb[wb_idx].pitch = fb->tiled_w;
+   } else {
+      wb[wb_idx].pixel_layout = 0x0;
+      wb[wb_idx].pitch = res->levels[level].stride / 8;
+   }
+   wb[wb_idx].mrt_bits = 0;
+}
+
+static void
+lima_pack_wb_cbuf_reg(struct lima_context *ctx, uint32_t *wb_reg, int wb_idx)
+{
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_resource *res = lima_resource(fb->base.cbufs[0]->texture);
+   int level = fb->base.cbufs[0]->u.tex.level;
+   unsigned layer = fb->base.cbufs[0]->u.tex.first_layer;
+   uint32_t format = lima_format_get_pixel(fb->base.cbufs[0]->format);
+   bool swap_channels = lima_format_get_swap_rb(fb->base.cbufs[0]->format);
+
+   struct lima_pp_wb_reg *wb = (void *)wb_reg;
+   wb[wb_idx].type = 0x02; /* 2 for color buffer */
+   wb[wb_idx].address = res->bo->va + res->levels[level].offset + layer * res->levels[level].layer_stride;
+   wb[wb_idx].pixel_format = format;
+   if (res->tiled) {
+      wb[wb_idx].pixel_layout = 0x2;
+      wb[wb_idx].pitch = fb->tiled_w;
+   } else {
+      wb[wb_idx].pixel_layout = 0x0;
+      wb[wb_idx].pitch = res->levels[level].stride / 8;
+   }
+   wb[wb_idx].mrt_bits = swap_channels ? 0x4 : 0x0;
+}
+
+static void
+lima_pack_pp_frame_reg(struct lima_context *ctx, uint32_t *frame_reg,
+                       uint32_t *wb_reg)
+{
+   struct lima_context_framebuffer *fb = &ctx->framebuffer;
+   struct lima_pp_frame_reg *frame = (void *)frame_reg;
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+   int wb_idx = 0;
+
+   frame->render_address = screen->pp_buffer->va + pp_frame_rsw_offset;
+   frame->flags = 0x02;
+   frame->clear_value_depth = ctx->clear.depth;
+   frame->clear_value_stencil = ctx->clear.stencil;
+   frame->clear_value_color = ctx->clear.color_8pc;
+   frame->clear_value_color_1 = ctx->clear.color_8pc;
+   frame->clear_value_color_2 = ctx->clear.color_8pc;
+   frame->clear_value_color_3 = ctx->clear.color_8pc;
+   frame->one = 1;
+
+   frame->width = fb->base.width - 1;
+   frame->height = fb->base.height - 1;
+
+   /* frame->fragment_stack_address is overwritten per-pp in the kernel
+    * by the values of pp_frame.fragment_stack_address[i] */
+
+   /* These are "stack size" and "stack offset" shifted,
+    * here they are assumed to be always the same. */
+   frame->fragment_stack_size = ctx->pp_max_stack_size << 16 | ctx->pp_max_stack_size;
+
+   /* related with MSAA and different value when r4p0/r7p0 */
+   frame->supersampled_height = fb->base.height * 2 - 1;
+   frame->scale = 0xE0C;
+
+   frame->dubya = 0x77;
+   frame->onscreen = 1;
+   frame->blocking = (fb->shift_min << 28) | (fb->shift_h << 16) | fb->shift_w;
+   frame->foureight = 0x8888;
+
+   if (fb->base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0))
+      lima_pack_wb_cbuf_reg(ctx, wb_reg, wb_idx++);
+
+   if (fb->base.zsbuf &&
+       (ctx->resolve & (PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL)))
+      lima_pack_wb_zsbuf_reg(ctx, wb_reg, wb_idx++);
+}
+
+static void
+_lima_flush(struct lima_context *ctx, bool end_of_frame)
+{
+   #define pp_stack_pp_size 0x400
+
+   lima_pack_head_plbu_cmd(ctx);
+   lima_finish_plbu_cmd(ctx);
+
+   lima_update_submit_bo(ctx);
+
+   int vs_cmd_size = ctx->vs_cmd_array.size;
+   uint32_t vs_cmd_va = 0;
+
+   if (vs_cmd_size) {
+      void *vs_cmd =
+         lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_vs_cmd, vs_cmd_size);
+      memcpy(vs_cmd, util_dynarray_begin(&ctx->vs_cmd_array), vs_cmd_size);
+      util_dynarray_clear(&ctx->vs_cmd_array);
+      vs_cmd_va = lima_ctx_buff_va(ctx, lima_ctx_buff_gp_vs_cmd);
+
+      lima_dump_command_stream_print(
+         vs_cmd, vs_cmd_size, false, "flush vs cmd at va %x\n", vs_cmd_va);
+      lima_dump_vs_command_stream_print(vs_cmd, vs_cmd_size, vs_cmd_va);
+   }
+
+   int plbu_cmd_size = ctx->plbu_cmd_array.size + ctx->plbu_cmd_head.size;
+   void *plbu_cmd =
+      lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_plbu_cmd, plbu_cmd_size);
+   memcpy(plbu_cmd,
+          util_dynarray_begin(&ctx->plbu_cmd_head),
+          ctx->plbu_cmd_head.size);
+   memcpy(plbu_cmd + ctx->plbu_cmd_head.size,
+          util_dynarray_begin(&ctx->plbu_cmd_array),
+          ctx->plbu_cmd_array.size);
+   util_dynarray_clear(&ctx->plbu_cmd_array);
+   util_dynarray_clear(&ctx->plbu_cmd_head);
+   uint32_t plbu_cmd_va = lima_ctx_buff_va(ctx, lima_ctx_buff_gp_plbu_cmd);
+
+   lima_dump_command_stream_print(
+      plbu_cmd, plbu_cmd_size, false, "flush plbu cmd at va %x\n", plbu_cmd_va);
+   lima_dump_plbu_command_stream_print(plbu_cmd, plbu_cmd_size, plbu_cmd_va);
+
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+   struct drm_lima_gp_frame gp_frame;
+   struct lima_gp_frame_reg *gp_frame_reg = (void *)gp_frame.frame;
+   gp_frame_reg->vs_cmd_start = vs_cmd_va;
+   gp_frame_reg->vs_cmd_end = vs_cmd_va + vs_cmd_size;
+   gp_frame_reg->plbu_cmd_start = plbu_cmd_va;
+   gp_frame_reg->plbu_cmd_end = plbu_cmd_va + plbu_cmd_size;
+   gp_frame_reg->tile_heap_start = ctx->gp_tile_heap[ctx->plb_index]->va;
+   gp_frame_reg->tile_heap_end = ctx->gp_tile_heap[ctx->plb_index]->va + ctx->gp_tile_heap_size;
+
+   lima_dump_command_stream_print(
+      &gp_frame, sizeof(gp_frame), false, "add gp frame\n");
+
+   if (!lima_submit_start(ctx->submit, LIMA_PIPE_GP, &gp_frame, sizeof(gp_frame)))
+      fprintf(stderr, "gp submit error\n");
+
+   if (lima_dump_command_stream) {
+      if (lima_submit_wait(ctx->submit, LIMA_PIPE_GP, PIPE_TIMEOUT_INFINITE)) {
+         if (ctx->gp_output) {
+            float *pos = lima_bo_map(ctx->gp_output);
+            lima_dump_command_stream_print(
+               pos, 4 * 4 * 16, true, "gl_pos dump at va %x\n",
+               ctx->gp_output->va);
+         }
+
+         uint32_t *plb = lima_bo_map(ctx->plb[ctx->plb_index]);
+         lima_dump_command_stream_print(
+            plb, LIMA_CTX_PLB_BLK_SIZE, false, "plb dump at va %x\n",
+            ctx->plb[ctx->plb_index]->va);
+      }
+      else {
+         fprintf(stderr, "gp submit wait error\n");
+         exit(1);
+      }
+   }
+
+   uint32_t pp_stack_va = 0;
+   if (ctx->pp_max_stack_size) {
+      lima_ctx_buff_alloc(ctx, lima_ctx_buff_pp_stack, screen->num_pp *
+                          ctx->pp_max_stack_size * pp_stack_pp_size);
+      pp_stack_va = lima_ctx_buff_va(ctx, lima_ctx_buff_pp_stack);
+   }
+
+   lima_update_pp_stream(ctx);
+
+   struct lima_pp_stream_state *ps = &ctx->pp_stream;
+   if (screen->gpu_type == DRM_LIMA_PARAM_GPU_ID_MALI400) {
+      struct drm_lima_m400_pp_frame pp_frame = {0};
+      lima_pack_pp_frame_reg(ctx, pp_frame.frame, pp_frame.wb);
+      pp_frame.num_pp = screen->num_pp;
+
+      for (int i = 0; i < screen->num_pp; i++) {
+         pp_frame.plbu_array_address[i] = ps->bo->va + ps->bo_offset + ps->offset[i];
+         if (ctx->pp_max_stack_size)
+            pp_frame.fragment_stack_address[i] = pp_stack_va +
+               ctx->pp_max_stack_size * pp_stack_pp_size * i;
+      }
+
+      lima_dump_command_stream_print(
+         &pp_frame, sizeof(pp_frame), false, "add pp frame\n");
+
+      if (!lima_submit_start(ctx->submit, LIMA_PIPE_PP, &pp_frame, sizeof(pp_frame)))
+         fprintf(stderr, "pp submit error\n");
+   }
+   else {
+      struct drm_lima_m450_pp_frame pp_frame = {0};
+      lima_pack_pp_frame_reg(ctx, pp_frame.frame, pp_frame.wb);
+      pp_frame.num_pp = screen->num_pp;
+
+      if (ctx->pp_max_stack_size)
+         for (int i = 0; i < screen->num_pp; i++)
+            pp_frame.fragment_stack_address[i] = pp_stack_va +
+               ctx->pp_max_stack_size * pp_stack_pp_size * i;
+
+      if (ps->bo) {
+         for (int i = 0; i < screen->num_pp; i++)
+            pp_frame.plbu_array_address[i] = ps->bo->va + ps->bo_offset + ps->offset[i];
+      }
+      else {
+         pp_frame.use_dlbu = true;
+
+         struct lima_context_framebuffer *fb = &ctx->framebuffer;
+         pp_frame.dlbu_regs[0] = ctx->plb[ctx->plb_index]->va;
+         pp_frame.dlbu_regs[1] = ((fb->tiled_h - 1) << 16) | (fb->tiled_w - 1);
+         unsigned s = util_logbase2(LIMA_CTX_PLB_BLK_SIZE) - 7;
+         pp_frame.dlbu_regs[2] = (s << 28) | (fb->shift_h << 16) | fb->shift_w;
+         pp_frame.dlbu_regs[3] = ((fb->tiled_h - 1) << 24) | ((fb->tiled_w - 1) << 16);
+      }
+
+      lima_dump_command_stream_print(
+         &pp_frame, sizeof(pp_frame), false, "add pp frame\n");
+
+      if (!lima_submit_start(ctx->submit, LIMA_PIPE_PP, &pp_frame, sizeof(pp_frame)))
+         fprintf(stderr, "pp submit error\n");
+   }
+
+   if (lima_dump_command_stream) {
+      if (!lima_submit_wait(ctx->submit, LIMA_PIPE_PP, PIPE_TIMEOUT_INFINITE)) {
+         fprintf(stderr, "pp wait error\n");
+         exit(1);
+      }
+   }
+
+   ctx->plb_index = (ctx->plb_index + 1) % lima_ctx_num_plb;
+
+   if (ctx->framebuffer.base.nr_cbufs && (ctx->resolve & PIPE_CLEAR_COLOR0)) {
+      /* Set reload flag for next draw. It'll be unset if buffer is cleared */
+      struct lima_surface *surf = lima_surface(ctx->framebuffer.base.cbufs[0]);
+      surf->reload = true;
+   }
+
+   ctx->pp_max_stack_size = 0;
+
+   ctx->damage_rect.minx = ctx->damage_rect.miny = 0xffff;
+   ctx->damage_rect.maxx = ctx->damage_rect.maxy = 0;
+
+   ctx->resolve = 0;
+
+   lima_dump_file_next();
+}
+
+void
+lima_flush(struct lima_context *ctx)
+{
+   if (!lima_ctx_dirty(ctx))
+      return;
+
+   _lima_flush(ctx, false);
+}
+
+static void
+lima_pipe_flush(struct pipe_context *pctx, struct pipe_fence_handle **fence,
+                unsigned flags)
+{
+   struct lima_context *ctx = lima_context(pctx);
+   if (lima_ctx_dirty(ctx))
+      _lima_flush(ctx, flags & PIPE_FLUSH_END_OF_FRAME);
+
+   if (fence) {
+      int drm_fd = lima_screen(ctx->base.screen)->fd;
+      int fd;
+
+      if (!drmSyncobjExportSyncFile(drm_fd, ctx->out_sync[LIMA_PIPE_PP], &fd))
+         *fence = lima_fence_create(fd);
+   }
+}
+
 bool lima_submit_init(struct lima_context *ctx)
 {
    int fd = lima_screen(ctx->base.screen)->fd;
@@ -175,6 +914,8 @@ bool lima_submit_init(struct lima_context *ctx)
          return false;
    }
 
+   ctx->base.flush = lima_pipe_flush;
+
    return true;
 }
 
diff --git a/src/gallium/drivers/lima/lima_submit.h b/src/gallium/drivers/lima/lima_submit.h
index 8208aa44d38..25cd5e31eb8 100644
--- a/src/gallium/drivers/lima/lima_submit.h
+++ b/src/gallium/drivers/lima/lima_submit.h
@@ -33,8 +33,6 @@ struct lima_bo;
 
 bool lima_submit_add_bo(struct lima_submit *submit, int pipe,
                         struct lima_bo *bo, uint32_t flags);
-bool lima_submit_start(struct lima_submit *submit, int pipe, void *frame, uint32_t size);
-bool lima_submit_wait(struct lima_submit *submit, int pipe, uint64_t timeout_ns);
 bool lima_submit_has_bo(struct lima_submit *submit, struct lima_bo *bo, bool all);
 
 bool lima_submit_init(struct lima_context *ctx);
-- 
2.24.1

