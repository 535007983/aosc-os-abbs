From 45f59e9e0c79cebb1865257511e1f90a9c397658 Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Sun, 12 Jan 2020 14:30:26 +0100
Subject: [PATCH 055/102] lima/ppir: remove orphan load node after cloning

There are some cases in shades using control flow where the varying load
is cloned to every block, and then the original node is left orphan.
This is not harmful for program execution, but it complicates analysis
for register allocation as there is now a case of writing to a register
that is never read.
While ppir doesn't have a dead code elimination pass for its own
optimizations and it is not hard to detect when we cloned the last load,
let's remove it early.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
Reviewed-by: Vasily Khoruzhick <anarsoul@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/merge_requests/3358>
---
 src/gallium/drivers/lima/ir/pp/nir.c  |  6 +++++-
 src/gallium/drivers/lima/ir/pp/node.c | 21 +++++++++++++++++++++
 src/gallium/drivers/lima/ir/pp/ppir.h |  1 +
 3 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/lima/ir/pp/nir.c b/src/gallium/drivers/lima/ir/pp/nir.c
index 71393dc1188..0c91c09831b 100644
--- a/src/gallium/drivers/lima/ir/pp/nir.c
+++ b/src/gallium/drivers/lima/ir/pp/nir.c
@@ -115,7 +115,11 @@ static void ppir_node_add_src(ppir_compiler *comp, ppir_node *node,
          if (!is_load_coords) {
             /* Clone varying loads for each block */
             if (child->block != node->block) {
-               child = ppir_node_clone(node->block, child);
+               ppir_node *new = ppir_node_clone(node->block, child);
+               /* If we clone it for every block and there is no user of
+                * the original load left, delete the original one. */
+               ppir_delete_if_orphan(node->block, child);
+               child = new;
                comp->var_nodes[ns->ssa->index] = child;
             }
             break;
diff --git a/src/gallium/drivers/lima/ir/pp/node.c b/src/gallium/drivers/lima/ir/pp/node.c
index 2f39cabf5fb..5090d1b9921 100644
--- a/src/gallium/drivers/lima/ir/pp/node.c
+++ b/src/gallium/drivers/lima/ir/pp/node.c
@@ -667,6 +667,27 @@ ppir_node_clone_load(ppir_block *block, ppir_node *node)
    return &new_lnode->node;
 }
 
+void
+ppir_delete_if_orphan(ppir_block *block, ppir_node *node)
+{
+   ppir_dest *dest = ppir_node_get_dest(node);
+   if (!dest)
+      return;
+
+   ppir_node_foreach_succ_safe(node, dep) {
+      ppir_node *succ = dep->succ;
+      for (int i = 0; i < ppir_node_get_src_num(succ); i++) {
+         ppir_src *src = ppir_node_get_src(succ, i);
+         if (!src)
+            continue;
+         if (ppir_node_target_equal(src, dest))
+            return;
+      }
+   }
+
+   ppir_node_delete(node);
+}
+
 ppir_node *ppir_node_clone(ppir_block *block, ppir_node *node)
 {
    switch (node->op) {
diff --git a/src/gallium/drivers/lima/ir/pp/ppir.h b/src/gallium/drivers/lima/ir/pp/ppir.h
index 10a4711c119..f58dd8be730 100644
--- a/src/gallium/drivers/lima/ir/pp/ppir.h
+++ b/src/gallium/drivers/lima/ir/pp/ppir.h
@@ -406,6 +406,7 @@ void ppir_node_print_prog(ppir_compiler *comp);
 void ppir_node_replace_child(ppir_node *parent, ppir_node *old_child, ppir_node *new_child);
 void ppir_node_replace_all_succ(ppir_node *dst, ppir_node *src);
 void ppir_node_replace_pred(ppir_dep *dep, ppir_node *new_pred);
+void ppir_delete_if_orphan(ppir_block *block, ppir_node *node);
 ppir_dep *ppir_dep_for_pred(ppir_node *node, ppir_node *pred);
 ppir_node *ppir_node_clone(ppir_block *block, ppir_node *node);
 /* Assumes that node successors are in the same block */
-- 
2.24.1

