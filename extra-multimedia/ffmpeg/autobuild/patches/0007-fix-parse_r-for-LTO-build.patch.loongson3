From db341a1ea5dada5ae18ca8d0a0e244650e751ddc Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <icenowy@aosc.io>
Date: Mon, 7 Sep 2020 03:49:55 +0800
Subject: [PATCH] fix parse_r for LTO build

Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
---
 libavutil/mips/asmdefs.h | 42 ----------------------------------------
 libavutil/mips/cpu.c     | 42 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 42 insertions(+), 42 deletions(-)

diff --git a/libavutil/mips/asmdefs.h b/libavutil/mips/asmdefs.h
index 76bb2b93fa..748119918a 100644
--- a/libavutil/mips/asmdefs.h
+++ b/libavutil/mips/asmdefs.h
@@ -55,46 +55,4 @@
 # define PTR_SLL        "sll "
 #endif
 
-/*
- * parse_r var, r - Helper assembler macro for parsing register names.
- *
- * This converts the register name in $n form provided in \r to the
- * corresponding register number, which is assigned to the variable \var. It is
- * needed to allow explicit encoding of instructions in inline assembly where
- * registers are chosen by the compiler in $n form, allowing us to avoid using
- * fixed register numbers.
- *
- * It also allows newer instructions (not implemented by the assembler) to be
- * transparently implemented using assembler macros, instead of needing separate
- * cases depending on toolchain support.
- *
- * Simple usage example:
- * __asm__ __volatile__("parse_r __rt, %0\n\t"
- *                      ".insn\n\t"
- *                      "# di    %0\n\t"
- *                      ".word   (0x41606000 | (__rt << 16))"
- *                      : "=r" (status);
- */
-
-/* Match an individual register number and assign to \var */
-#define _IFC_REG(n)                                \
-        ".ifc        \\r, $" #n "\n\t"             \
-        "\\var        = " #n "\n\t"                \
-        ".endif\n\t"
-
-__asm__(".macro        parse_r var r\n\t"
-        "\\var        = -1\n\t"
-        _IFC_REG(0)  _IFC_REG(1)  _IFC_REG(2)  _IFC_REG(3)
-        _IFC_REG(4)  _IFC_REG(5)  _IFC_REG(6)  _IFC_REG(7)
-        _IFC_REG(8)  _IFC_REG(9)  _IFC_REG(10) _IFC_REG(11)
-        _IFC_REG(12) _IFC_REG(13) _IFC_REG(14) _IFC_REG(15)
-        _IFC_REG(16) _IFC_REG(17) _IFC_REG(18) _IFC_REG(19)
-        _IFC_REG(20) _IFC_REG(21) _IFC_REG(22) _IFC_REG(23)
-        _IFC_REG(24) _IFC_REG(25) _IFC_REG(26) _IFC_REG(27)
-        _IFC_REG(28) _IFC_REG(29) _IFC_REG(30) _IFC_REG(31)
-        ".iflt        \\var\n\t"
-        ".error        \"Unable to parse register name \\r\"\n\t"
-        ".endif\n\t"
-        ".endm");
-
 #endif /* AVCODEC_MIPS_ASMDEFS_H */
diff --git a/libavutil/mips/cpu.c b/libavutil/mips/cpu.c
index 59619d54de..398973f9c4 100644
--- a/libavutil/mips/cpu.c
+++ b/libavutil/mips/cpu.c
@@ -37,6 +37,48 @@ static int cpucfg_available(void)
     return getauxval(AT_HWCAP) & HWCAP_LOONGSON_CPUCFG;
 }
 
+/*
+ * parse_r var, r - Helper assembler macro for parsing register names.
+ *
+ * This converts the register name in $n form provided in \r to the
+ * corresponding register number, which is assigned to the variable \var. It is
+ * needed to allow explicit encoding of instructions in inline assembly where
+ * registers are chosen by the compiler in $n form, allowing us to avoid using
+ * fixed register numbers.
+ *
+ * It also allows newer instructions (not implemented by the assembler) to be
+ * transparently implemented using assembler macros, instead of needing separate
+ * cases depending on toolchain support.
+ *
+ * Simple usage example:
+ * __asm__ __volatile__("parse_r __rt, %0\n\t"
+ *                      ".insn\n\t"
+ *                      "# di    %0\n\t"
+ *                      ".word   (0x41606000 | (__rt << 16))"
+ *                      : "=r" (status);
+ */
+
+/* Match an individual register number and assign to \var */
+#define _IFC_REG(n)                                \
+        ".ifc        \\r, $" #n "\n\t"             \
+        "\\var        = " #n "\n\t"                \
+        ".endif\n\t"
+
+__asm__(".macro        parse_r var r\n\t"
+        "\\var        = -1\n\t"
+        _IFC_REG(0)  _IFC_REG(1)  _IFC_REG(2)  _IFC_REG(3)
+        _IFC_REG(4)  _IFC_REG(5)  _IFC_REG(6)  _IFC_REG(7)
+        _IFC_REG(8)  _IFC_REG(9)  _IFC_REG(10) _IFC_REG(11)
+        _IFC_REG(12) _IFC_REG(13) _IFC_REG(14) _IFC_REG(15)
+        _IFC_REG(16) _IFC_REG(17) _IFC_REG(18) _IFC_REG(19)
+        _IFC_REG(20) _IFC_REG(21) _IFC_REG(22) _IFC_REG(23)
+        _IFC_REG(24) _IFC_REG(25) _IFC_REG(26) _IFC_REG(27)
+        _IFC_REG(28) _IFC_REG(29) _IFC_REG(30) _IFC_REG(31)
+        ".iflt        \\var\n\t"
+        ".error        \"Unable to parse register name \\r\"\n\t"
+        ".endif\n\t"
+        ".endm");
+
 /* Most toolchains have no CPUCFG support yet */
 static uint32_t read_cpucfg(uint32_t reg)
 {
-- 
2.27.0

