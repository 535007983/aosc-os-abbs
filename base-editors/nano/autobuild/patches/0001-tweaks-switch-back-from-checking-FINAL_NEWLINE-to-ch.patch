From 5601b9a66bf8bad4b357e278c7f2fd87bba014ec Mon Sep 17 00:00:00 2001
From: Benno Schulenberg <bensberg@telfort.nl>
Date: Sun, 7 Apr 2019 08:47:29 +0200
Subject: [PATCH 1/2] tweaks: switch back from checking FINAL_NEWLINE to
 checking NO_NEWLINES

This effectively reverts commit b6a76223 from a good two months ago.
---
 src/cut.c    | 14 +++++++-------
 src/files.c  |  8 ++++----
 src/nano.c   | 11 ++++++++---
 src/search.c |  2 +-
 src/text.c   | 18 +++++++++---------
 5 files changed, 29 insertions(+), 24 deletions(-)

diff --git a/src/cut.c b/src/cut.c
index 029e854f..5e0a01fc 100644
--- a/src/cut.c
+++ b/src/cut.c
@@ -67,7 +67,7 @@ void do_deletion(undo_type action)
 
 		/* If there is a magic line, and we're before it: don't eat it. */
 		if (joining == openfile->filebot && openfile->current_x != 0 &&
-				ISSET(FINAL_NEWLINE)) {
+				!ISSET(NO_NEWLINES)) {
 #ifndef NANO_TINY
 			if (action == BACK)
 				add_undo(BACK);
@@ -279,7 +279,7 @@ void do_cut_text(bool copy_text, bool marked, bool cut_till_eof, bool append)
 	size_t cb_save_len = 0;
 		/* The length of the string at the current end of the cutbuffer,
 		 * before we add text to it. */
-	bool using_magicline = ISSET(FINAL_NEWLINE);
+	bool using_magicline = !ISSET(NO_NEWLINES);
 		/* Whether an automatic newline should be added at end-of-buffer. */
 	bool right_side_up = TRUE;
 		/* There *is* no region, *or* it is marked forward. */
@@ -301,7 +301,7 @@ void do_cut_text(bool copy_text, bool marked, bool cut_till_eof, bool append)
 			cb_save_len = strlen(cutbottom->data);
 		}
 		/* Don't add a magic line when moving text to the cutbuffer. */
-		UNSET(FINAL_NEWLINE);
+		SET(NO_NEWLINES);
 	}
 
 	if (cut_till_eof) {
@@ -339,7 +339,7 @@ void do_cut_text(bool copy_text, bool marked, bool cut_till_eof, bool append)
 		}
 		/* Restore the magic-line behavior now that we're done fiddling. */
 		if (using_magicline)
-			SET(FINAL_NEWLINE);
+			UNSET(NO_NEWLINES);
 	} else
 #endif /* !NANO_TINY */
 
@@ -358,8 +358,8 @@ bool is_cuttable(bool test_cliff)
 					(openfile->mark == openfile->current &&
 					openfile->mark_x == openfile->current_x) ||
 					(test_cliff && openfile->current->data[openfile->current_x] == '\0' &&
-					((!ISSET(FINAL_NEWLINE) && openfile->current == openfile->filebot) ||
-					(ISSET(FINAL_NEWLINE) && openfile->current == openfile->filebot->prev))
+					((ISSET(NO_NEWLINES) && openfile->current == openfile->filebot) ||
+					(!ISSET(NO_NEWLINES) && openfile->current == openfile->filebot->prev))
 #endif
 					)) {
 #ifndef NANO_TINY
@@ -428,7 +428,7 @@ void do_copy_text(void)
 void do_cut_till_eof(void)
 {
 	if ((openfile->current == openfile->filebot && openfile->current->data[0] == '\0') ||
-				(ISSET(FINAL_NEWLINE) && openfile->current->next == openfile->filebot &&
+				(!ISSET(NO_NEWLINES) && openfile->current->next == openfile->filebot &&
 				openfile->current->data[openfile->current_x] == '\0')) {
 		statusbar(_("Nothing was cut"));
 		return;
diff --git a/src/files.c b/src/files.c
index 8260d0d0..f9a4fd6b 100644
--- a/src/files.c
+++ b/src/files.c
@@ -557,7 +557,7 @@ void replace_marked_buffer(const char *filename)
 {
 	FILE *f;
 	int descriptor;
-	bool using_magicline = ISSET(FINAL_NEWLINE);
+	bool using_magicline = !ISSET(NO_NEWLINES);
 	linestruct *was_cutbuffer = cutbuffer;
 
 	descriptor = open_file(filename, FALSE, TRUE, &f);
@@ -566,7 +566,7 @@ void replace_marked_buffer(const char *filename)
 		return;
 
 	/* Don't add a magic line when replacing text in the buffer. */
-	UNSET(FINAL_NEWLINE);
+	SET(NO_NEWLINES);
 
 	add_undo(COUPLE_BEGIN);
 	openfile->undotop->strdata = mallocstrcpy(NULL, _("spelling correction"));
@@ -584,7 +584,7 @@ void replace_marked_buffer(const char *filename)
 
 	/* Restore the magic-line behavior now that we're done fiddling. */
 	if (using_magicline)
-		SET(FINAL_NEWLINE);
+		UNSET(NO_NEWLINES);
 
 	add_undo(COUPLE_END);
 	openfile->undotop->strdata = mallocstrcpy(NULL, _("spelling correction"));
@@ -2062,7 +2062,7 @@ bool write_marked_file(const char *name, FILE *f_open, bool tmp,
 
 	/* If we are using a magic line, and the last line of the partition
 	 * isn't blank, then add a newline at the end of the buffer. */
-	if (ISSET(FINAL_NEWLINE) && openfile->filebot->data[0] != '\0') {
+	if (!ISSET(NO_NEWLINES) && openfile->filebot->data[0] != '\0') {
 		new_magicline();
 		added_magicline = TRUE;
 	}
diff --git a/src/nano.c b/src/nano.c
index 1fe7df37..0c714926 100644
--- a/src/nano.c
+++ b/src/nano.c
@@ -380,7 +380,7 @@ void extract_buffer(linestruct **file_top, linestruct **file_bot,
 	renumber(top_save);
 
 	/* If the text doesn't end with a newline, and it should, add one. */
-	if (ISSET(FINAL_NEWLINE) && openfile->filebot->data[0] != '\0')
+	if (!ISSET(NO_NEWLINES) && openfile->filebot->data[0] != '\0')
 		new_magicline();
 }
 
@@ -477,7 +477,7 @@ void ingraft_buffer(linestruct *somebuffer)
 	renumber(top_save);
 
 	/* If the text doesn't end with a newline, and it should, add one. */
-	if (ISSET(FINAL_NEWLINE) && openfile->filebot->data[0] != '\0')
+	if (!ISSET(NO_NEWLINES) && openfile->filebot->data[0] != '\0')
 		new_magicline();
 }
 
@@ -1913,7 +1913,7 @@ void do_output(char *output, size_t output_len, bool allow_cntrls)
 #endif
 
 		/* If we've added text to the magic line, create a new magic line. */
-		if (openfile->filebot == openfile->current && ISSET(FINAL_NEWLINE)) {
+		if (openfile->filebot == openfile->current && !ISSET(NO_NEWLINES)) {
 			new_magicline();
 			if (margin > 0)
 				refresh_needed = TRUE;
@@ -2446,6 +2446,11 @@ int main(int argc, char **argv)
 	}
 #endif /* ENABLE_NANORC */
 
+	if (ISSET(FINAL_NEWLINE))
+		UNSET(NO_NEWLINES);
+	else
+		SET(NO_NEWLINES);
+
 	/* If the user wants bold instead of reverse video for hilited text... */
 	if (ISSET(BOLD_TEXT))
 		hilite_attribute = A_BOLD;
diff --git a/src/search.c b/src/search.c
index 324d8770..6930c395 100644
--- a/src/search.c
+++ b/src/search.c
@@ -681,7 +681,7 @@ ssize_t do_replace_loop(const char *needle, bool whole_word_only,
 
 	/* If "automatic newline" is enabled, and text has been added to the
 	 * magic line, make a new magic line. */
-	if (ISSET(FINAL_NEWLINE) && openfile->filebot->data[0] != '\0')
+	if (!ISSET(NO_NEWLINES) && openfile->filebot->data[0] != '\0')
 		new_magicline();
 
 	return numreplaced;
diff --git a/src/text.c b/src/text.c
index 0eeafd8f..0c75f20c 100644
--- a/src/text.c
+++ b/src/text.c
@@ -323,7 +323,7 @@ bool comment_line(undo_type action, linestruct *line, const char *comment_seq)
 		/* Length of postfix. */
 	size_t line_len = strlen(line->data);
 
-	if (ISSET(FINAL_NEWLINE) && line == openfile->filebot)
+	if (!ISSET(NO_NEWLINES) && line == openfile->filebot)
 		return FALSE;
 
 	if (action == COMMENT) {
@@ -393,7 +393,7 @@ void do_comment(void)
 	get_range((const linestruct **)&top, (const linestruct **)&bot);
 
 	/* If only the magic line is selected, don't do anything. */
-	if (top == bot && bot == openfile->filebot && ISSET(FINAL_NEWLINE)) {
+	if (top == bot && bot == openfile->filebot && !ISSET(NO_NEWLINES)) {
 		statusbar(_("Cannot comment past end of file"));
 		return;
 	}
@@ -480,7 +480,7 @@ void undo_cut(undo *u)
 	copy_from_buffer(u->cutbuffer);
 
 	/* If the final line was originally cut, remove the extra magic line. */
-	if ((u->xflags & WAS_FINAL_LINE) && ISSET(FINAL_NEWLINE) &&
+	if ((u->xflags & WAS_FINAL_LINE) && !ISSET(NO_NEWLINES) &&
 			openfile->current != openfile->filebot)
 		remove_magicline();
 
@@ -538,7 +538,7 @@ void do_undo(void)
 		/* TRANSLATORS: The next thirteen strings describe actions
 		 * that are undone or redone.  They are all nouns, not verbs. */
 		undidmsg = _("addition");
-		if ((u->xflags & WAS_FINAL_LINE) && ISSET(FINAL_NEWLINE))
+		if ((u->xflags & WAS_FINAL_LINE) && !ISSET(NO_NEWLINES))
 			remove_magicline();
 		data = charalloc(strlen(f->data) - strlen(u->strdata) + 1);
 		strncpy(data, f->data, u->begin);
@@ -578,7 +578,7 @@ void do_undo(void)
 		/* When the join was done by a Backspace at the tail of the file,
 		 * and the nonewlines flag isn't set, do not re-add a newline that
 		 * wasn't actually deleted; just position the cursor. */
-		if ((u->xflags & WAS_FINAL_BACKSPACE) && ISSET(FINAL_NEWLINE)) {
+		if ((u->xflags & WAS_FINAL_BACKSPACE) && !ISSET(NO_NEWLINES)) {
 			goto_line_posx(openfile->filebot->lineno, 0);
 			break;
 		}
@@ -716,7 +716,7 @@ void do_redo(void)
 	switch (u->type) {
 	case ADD:
 		redidmsg = _("addition");
-		if ((u->xflags & WAS_FINAL_LINE) && ISSET(FINAL_NEWLINE))
+		if ((u->xflags & WAS_FINAL_LINE) && !ISSET(NO_NEWLINES))
 			new_magicline();
 		data = charalloc(strlen(f->data) + strlen(u->strdata) + 1);
 		strncpy(data, f->data, u->begin);
@@ -757,7 +757,7 @@ void do_redo(void)
 		/* When the join was done by a Backspace at the tail of the file,
 		 * and the nonewlines flag isn't set, do not join anything, as
 		 * nothing was actually deleted; just position the cursor. */
-		if ((u->xflags & WAS_FINAL_BACKSPACE) && ISSET(FINAL_NEWLINE)) {
+		if ((u->xflags & WAS_FINAL_BACKSPACE) && !ISSET(NO_NEWLINES)) {
 			goto_line_posx(u->mark_begin_lineno, u->mark_begin_x);
 			break;
 		}
@@ -1400,7 +1400,7 @@ void update_undo(undo_type action)
 				if (u->lineno == u->mark_begin_lineno)
 					u->begin += u->mark_begin_x;
 			} else if (openfile->current == openfile->filebot &&
-						!ISSET(FINAL_NEWLINE))
+						ISSET(NO_NEWLINES))
 				u->begin = strlen(u->cutbottom->data);
 		}
 		break;
@@ -2721,7 +2721,7 @@ void do_spell(void)
 	memcpy(stash, flags, sizeof(flags));
 
 	/* Don't add an extra newline when writing out the (selected) text. */
-	UNSET(FINAL_NEWLINE);
+	SET(NO_NEWLINES);
 
 #ifndef NANO_TINY
 	if (openfile->mark)
-- 
2.18.1

