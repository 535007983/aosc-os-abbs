From a8fdec8a3e94b46320ab1c40b53fe66db57ccd4f Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Mon, 19 Dec 2016 01:13:06 +0100
Subject: [PATCH 06/69] extcon: axp288: Remove dependency on non-existing
 platform_data

When the extcon_axp288 driver was originally merged, it was merged with
a dependency on some other driver providing platform data for it.

However such another driver was never merged, so the extcon_axp288 as
merged upstream has never worked, its probe method simply always returns
-ENODEV.

This commit drops the dependency on the pdata always being there, instead
it treats not having pdata as the pdata having a NULL gpio_mux_control,
something which the code was already prepared to handle.

Note that the code for controlling the mux_control gpio is left in place,
as this may be necessary to allow the axp288 pmic to properly detect the
charger type (instead of assuming 500mA max charge current) on some
tablets. This will make it easier for future patches to add support for
this gpio by getting the gpio info from somewhere.

Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
---
 drivers/extcon/extcon-axp288.c | 25 ++++++++++---------------
 1 file changed, 10 insertions(+), 15 deletions(-)

diff --git a/drivers/extcon/extcon-axp288.c b/drivers/extcon/extcon-axp288.c
index 42f41e808292..a84fab87e201 100644
--- a/drivers/extcon/extcon-axp288.c
+++ b/drivers/extcon/extcon-axp288.c
@@ -112,7 +112,7 @@ struct axp288_extcon_info {
 	struct device *dev;
 	struct regmap *regmap;
 	struct regmap_irq_chip_data *regmap_irqc;
-	struct axp288_extcon_pdata *pdata;
+	struct gpio_desc *gpio_mux_cntl;
 	int irq[EXTCON_IRQ_END];
 	struct extcon_dev *edev;
 	struct notifier_block extcon_nb;
@@ -216,8 +216,8 @@ static int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)
 		 * If VBUS is absent Connect D+/D- lines to PMIC for BC
 		 * detection. Else connect them to SOC for USB communication.
 		 */
-		if (info->pdata->gpio_mux_cntl)
-			gpiod_set_value(info->pdata->gpio_mux_cntl,
+		if (info->gpio_mux_cntl)
+			gpiod_set_value(info->gpio_mux_cntl,
 				vbus_attach ? EXTCON_GPIO_MUX_SEL_SOC
 						: EXTCON_GPIO_MUX_SEL_PMIC);
 
@@ -271,6 +271,7 @@ static int axp288_extcon_probe(struct platform_device *pdev)
 {
 	struct axp288_extcon_info *info;
 	struct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);
+	struct axp288_extcon_pdata *pdata = pdev->dev.platform_data;
 	int ret, i, pirq, gpio;
 
 	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
@@ -280,15 +281,9 @@ static int axp288_extcon_probe(struct platform_device *pdev)
 	info->dev = &pdev->dev;
 	info->regmap = axp20x->regmap;
 	info->regmap_irqc = axp20x->regmap_irqc;
-	info->pdata = pdev->dev.platform_data;
-
-	if (!info->pdata) {
-		/* Try ACPI provided pdata via device properties */
-		if (!device_property_present(&pdev->dev,
-					"axp288_extcon_data\n"))
-			dev_err(&pdev->dev, "failed to get platform data\n");
-		return -ENODEV;
-	}
+	if (pdata)
+		info->gpio_mux_cntl = pdata->gpio_mux_cntl;
+
 	platform_set_drvdata(pdev, info);
 
 	axp288_extcon_log_rsi(info);
@@ -316,15 +311,15 @@ static int axp288_extcon_probe(struct platform_device *pdev)
 	}
 
 	/* Set up gpio control for USB Mux */
-	if (info->pdata->gpio_mux_cntl) {
-		gpio = desc_to_gpio(info->pdata->gpio_mux_cntl);
+	if (info->gpio_mux_cntl) {
+		gpio = desc_to_gpio(info->gpio_mux_cntl);
 		ret = devm_gpio_request(&pdev->dev, gpio, "USB_MUX");
 		if (ret < 0) {
 			dev_err(&pdev->dev,
 				"failed to request the gpio=%d\n", gpio);
 			return ret;
 		}
-		gpiod_direction_output(info->pdata->gpio_mux_cntl,
+		gpiod_direction_output(info->gpio_mux_cntl,
 						EXTCON_GPIO_MUX_SEL_PMIC);
 	}
 
-- 
2.11.0

